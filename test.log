commit afe672f5a3ade3010b2ef0cff5e8b82ed1d32a4d
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Fri Oct 13 03:46:26 2017 -0600

    Replaced original code with extracted method call in the rest of the move methods

diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class
index 7414b05..1c04c3c 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class and b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class differ
diff --git a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java
index 949d8ca..a27aafa 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
@@ -93,20 +93,7 @@ public class PlayerMovement {
 		
 		int newY = y - BasicMap.TILESIZE;
 		
-		if (player.isTaken(x,newY))
-			player.attack(x, newY);
-		else if (!(map.hasCollision(x, newY))){
-			player.updatePosition(x,newY);
-			y = newY;
-			if (map.isStairs(x, y)){
-				player.setOnStairs(true);
-				}
-			if (map.isWin(x, y))
-			{
-			GameScreen.setWin(true);
-			}		
-			}
-			
+		movePlayerToPos(x,newY, player,map);		
 	}
 	
 	public void moveDiagonalUpRight(Player player, BasicMap map){
@@ -117,22 +104,7 @@ public class PlayerMovement {
 		int newX = x + BasicMap.TILESIZE;
 		int newY = y - BasicMap.TILESIZE;
 		
-		if (player.isTaken(newX, newY))
-			player.attack(newX, newY);
-		else if (!(map.hasCollision(newX, newY)))	
-			{
-				player.updatePosition(newX,newY);
-				y = newY;
-				x = newX;	
-				if (map.isStairs(x, y)){
-					player.setOnStairs(true);
-					}
-				if (map.isWin(x, y))
-				{
-				GameScreen.setWin(true);
-				}
-			
-			}
+		movePlayerToPos(newX, newY, player,map);
 	}
 	
 	public void moveLeft(Player player, BasicMap map){	
@@ -140,20 +112,7 @@ public class PlayerMovement {
 		int y = player.getPosition()[1];
 	
 		int newX = x-BasicMap.TILESIZE;
-		if (player.isTaken(newX, y))
-			player.attack(newX,y);
-		else if (!(map.hasCollision(newX, y))){
-			player.updatePosition(newX,y);
-			x = newX;
-			if (map.isStairs(x, y)){
-				player.setOnStairs(true);
-						}
-			if (map.isWin(x, y))
-			{
-			GameScreen.setWin(true);
-			}
-		
-		}
+		movePlayerToPos(newX, y, player,map);
 		
 	}
 
@@ -162,35 +121,15 @@ public class PlayerMovement {
 	{
 		int x = player.getPosition()[0];
 		int y = player.getPosition()[1];
-		if (map.isStairs(x, y)){
-			player.setOnStairs(true);
-		}
-		if (map.isWin(x, y))
-		{
-			GameScreen.setWin(true);
-		}
-
+		movePlayerToPos(x, y, player,map);
 	}
 	
 	public void moveRight(Player player, BasicMap map){
 		int x = player.getPosition()[0];
 		int y = player.getPosition()[1];
 		int newX = x + BasicMap.TILESIZE;
-		if  (player.isTaken(newX, y))
-			player.attack(newX,y);
-		else if (!(map.hasCollision(newX, y))){
-				player.updatePosition(newX,y);
-			x = newX;
-			if (map.isStairs(x, y)){
-				player.setOnStairs(true);
-						}
-			if (map.isWin(x, y))
-			{
-			GameScreen.setWin(true);
-			}
-		
-			}
-		}	
+		movePlayerToPos(newX, y, player,map);
+	}	
 	
 	
 	public void moveDiagonalDownLeft(Player player, BasicMap map){
@@ -198,69 +137,23 @@ public class PlayerMovement {
 		int y = player.getPosition()[1];
 		int newX = x-BasicMap.TILESIZE;
 		int newY = y +BasicMap.TILESIZE;
-		if (player.isTaken(newX, newY))
-			player.attack(newX, newY);
-		else if (!(map.hasCollision(newX,  newY)))
-			{
-			player.updatePosition(newX,newY);
-			x = newX;
-			y = newY;
-			if (map.isStairs(x, y)){
-				player.setOnStairs(true);
-				}
-			if (map.isWin(x, y))
-			{
-			GameScreen.setWin(true);
-			}
-		
-			}
-		}
+		movePlayerToPos(newX, newY, player,map);
+	}
 		
-public void moveDown(Player player, BasicMap map){
-	int x = player.getPosition()[0];
-	int y = player.getPosition()[1];
-    int newY = y +BasicMap.TILESIZE;
-	if (player.isTaken(x, newY))
-		player.attack (x, newY);
-	else if (!(map.hasCollision(x, newY))){
-		player.updatePosition(x,newY);
-		y = newY;
-		if (map.isStairs(x, y)){
-			player.setOnStairs(true);
-			}
-		if (map.isWin(x, y))
-		{
-		GameScreen.setWin(true);
-		}
-	
-		}
-	
+	public void moveDown(Player player, BasicMap map){
+		int x = player.getPosition()[0];
+		int y = player.getPosition()[1];
+		int newY = y +BasicMap.TILESIZE;
+		movePlayerToPos(x, newY, player,map);
 	}
 
-public void moveDiagonalDownRight(Player player, BasicMap map){
-	int x = player.getPosition()[0];
-	int y = player.getPosition()[1];
-	int newX = x+BasicMap.TILESIZE;
-	int newY = y+BasicMap.TILESIZE;
-		if (player.isTaken(newX, newY)){
-			player.attack(newX, newY);
-		}
-		else if (!(map.hasCollision(newX,newY)))
-			{
-			player.updatePosition(newX,newY);
-			x = newX;
-			y = newY;
-			if (map.isStairs(x, y)){
-				player.setOnStairs(true);
-				}
-			if (map.isWin(x, y))
-			{
-			GameScreen.setWin(true);
-			}
-		
-			}
-	
-		}
+	public void moveDiagonalDownRight(Player player, BasicMap map){
+		int x = player.getPosition()[0];
+		int y = player.getPosition()[1];
+		int newX = x+BasicMap.TILESIZE;
+		int newY = y+BasicMap.TILESIZE;
+		movePlayerToPos(newX, newY, player,map);
+	}
 
 
 

commit d10e909304e29d35c503a5b4cb64a5f89e2461f1
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Fri Oct 13 03:41:55 2017 -0600

    Replaced original code with extracted method call in moveDiagonalUpRight

diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class
index aa503d9..7414b05 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class and b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class differ
diff --git a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java
index 5ec3f60..949d8ca 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
@@ -68,22 +68,7 @@ public class PlayerMovement {
 		
 		int newX = x-BasicMap.TILESIZE;
 		int newY = y-BasicMap.TILESIZE;
-		if (player.isTaken(newX, newY))
-			player.attack(newX,newY);
-		else if (!(map.hasCollision(newX, newY)))
-			{
-			player.updatePosition(newX,newY);
-			x = newX;
-			y = newY;
-			
-			if (map.isStairs(x, y)){
-				player.setOnStairs(true);
-				}
-			if (map.isWin(x, y))
-				{
-				GameScreen.setWin(true);
-				}
-			}
+		movePlayerToPos(newX, newY,player,map);
 	 }
 	
 	private void movePlayerToPos(int x, int y, Player player, BasicMap map)
@@ -99,7 +84,7 @@ public class PlayerMovement {
 			{
 			GameScreen.setWin(true);
 			}		
-			}
+		}
 	}
 
 	public void moveUp(Player player,BasicMap map){

commit e2e50d41e3f87b52926a5613b707a53600e353da
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Fri Oct 13 03:40:13 2017 -0600

    Extracted Duplicated Code and created new method

diff --git a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java
index 93ea305..5ec3f60 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
@@ -86,6 +86,21 @@ public class PlayerMovement {
 			}
 	 }
 	
+	private void movePlayerToPos(int x, int y, Player player, BasicMap map)
+	{
+		if (player.isTaken(x,y))
+			player.attack(x, y);
+		else if (!(map.hasCollision(x, y))){
+			player.updatePosition(x,y);
+			if (map.isStairs(x, y)){
+				player.setOnStairs(true);
+				}
+			if (map.isWin(x, y))
+			{
+			GameScreen.setWin(true);
+			}		
+			}
+	}
 
 	public void moveUp(Player player,BasicMap map){
 		int x = player.getPosition()[0];

commit 5e96f3b461a9591151a534eea9498e3460f18ac6
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Fri Oct 13 03:22:46 2017 -0600

    Removed all movement functionality from Player.java  and tested it

diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class
index fcc1494..37d1515 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class and b/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class
index 7e5cc20..aa503d9 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class and b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class
index f7eed60..8f2994d 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class and b/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class differ
diff --git a/Version 1.1/NewestVersion/src/playerRelated/Player.java b/Version 1.1/NewestVersion/src/playerRelated/Player.java
index 0e8a85f..dd8ea8f 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/Player.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/Player.java	
@@ -125,116 +125,38 @@ public class Player extends Entity{
 			}
 		//Input used to get keyboard controls
 		Input input = gc.getInput();
-		 
-///		int[] LeftKeys = new int[] {Input.KEY_NUMPAD7, Input.KEY_7,
-	///			Input.KEY_NUMPAD1,Input.KEY_J,
-		///		Input.KEY_LEFT,Input.KEY_U,Input.KEY_NUMPAD4};
-		
-		
-		//Diagonal Up Left
-		if (input.isKeyPressed(Input.KEY_NUMPAD7)||input.isKeyPressed(Input.KEY_7)){
-			 moveDiagonalUpLeft();
+		playerMovement.movePlayer(this, map, input);
+		
+		//Player moves in a leftward direction.
+		if (input.isKeyPressed(Input.KEY_NUMPAD7)||input.isKeyPressed(Input.KEY_7)
+				||input.isKeyPressed(Input.KEY_LEFT)||input.isKeyPressed(Input.KEY_U)
+				||input.isKeyPressed(Input.KEY_NUMPAD4)||input.isKeyPressed(Input.KEY_NUMPAD1)
+				||input.isKeyPressed(Input.KEY_J)){
+			 	currentSprite = left;
 		 }
+		//Player Moves in a rightward direction
+		else if (input.isKeyPressed(Input.KEY_NUMPAD9)||input.isKeyPressed(Input.KEY_9)
+				||input.isKeyPressed(Input.KEY_RIGHT)||input.isKeyPressed(Input.KEY_O)
+				||input.isKeyPressed(Input.KEY_NUMPAD6)||input.isKeyPressed(Input.KEY_NUMPAD3)
+				||input.isKeyPressed(Input.KEY_L)){
+				currentSprite = right;
+		}
 		
-		//Normal Up
+		//Player moves upwards
 		else if (input.isKeyPressed(Input.KEY_UP)||input.isKeyPressed(Input.KEY_8)
 				||input.isKeyPressed(Input.KEY_NUMPAD8)){
-				moveUp();
-		}
-		
-		//Diagonal Up Right
-		else if (input.isKeyPressed(Input.KEY_NUMPAD9)||input.isKeyPressed(Input.KEY_9)){
-				moveDiagonalUpRight();
+				currentSprite = up;
 		}
-
-		//Normal Left
-		else if (input.isKeyPressed(Input.KEY_LEFT)||input.isKeyPressed(Input.KEY_U)
-				||input.isKeyPressed(Input.KEY_NUMPAD4)){
-				moveLeft();
-		}
-		
-		//PASS TURN
-		else if (input.isKeyPressed(Input.KEY_NUMPAD5)||input.isKeyPressed(Input.KEY_I))
-			{
-			moveNowhere();
-			}
 		
-		//Normal Right
-		else if (input.isKeyPressed(Input.KEY_RIGHT)||input.isKeyPressed(Input.KEY_O)||
-				input.isKeyPressed(Input.KEY_NUMPAD6)){
-			moveRight();
-			}
-		
-		//Diagonal Down Left
-		else if (input.isKeyPressed(Input.KEY_NUMPAD1)||input.isKeyPressed(Input.KEY_J)){
-				moveDiagonalDownLeft();
-				}
-		
-		//Normal Down
+		//Player moves downwards or does not move at all
 		else if (input.isKeyPressed(Input.KEY_DOWN)||input.isKeyPressed(Input.KEY_K)||
-				input.isKeyPressed(Input.KEY_NUMPAD2)){
-			moveDown();
-		}
-
-		//Diagonal Down Right
-		else if (input.isKeyPressed(Input.KEY_NUMPAD3)||input.isKeyPressed(Input.KEY_L)){
-			moveDiagonalDownRight();
-		}
-		 
-	}
-
-	
-////////////METHODS DEALING WITH MOVEMENT//////////////////////
-	private void moveDiagonalUpLeft(){
-		    //Update Sprite
-   			 currentSprite = left;
-			 playerMovement.moveDiagonalUpLeft(this, map);
-		 }
-	
-	
-	private void moveUp(){
-			currentSprite = up;
-			playerMovement.moveUp(this, map);
-		}
-		
-		
-	private void moveDiagonalUpRight(){
-			currentSprite = right;
-			playerMovement.moveDiagonalUpRight(this,map);
-		}
-
-	private void moveLeft(){	
-			currentSprite = left;
-			playerMovement.moveLeft(this,map);
-		}
-		
-	private void moveNowhere()
-		{
+				input.isKeyPressed(Input.KEY_NUMPAD2)||input.isKeyPressed(Input.KEY_NUMPAD5)
+				||input.isKeyPressed(Input.KEY_I)){
 			currentSprite = down;
-			playerMovement.moveNowhere(this, map);	
 		}
-		
-	private void moveRight(){
-			currentSprite = right;
-			playerMovement.moveRight(this, map);
-		}	
-		
-		
-	private void moveDiagonalDownLeft(){
-				currentSprite = left;
-				playerMovement.moveDiagonalDownLeft(this, map);
-				}
-				
-	private void moveDown(){
-			currentSprite = down;
-			playerMovement.moveDown(this, map);
-			
+ 
 	}
 
-	private void moveDiagonalDownRight(){
-			currentSprite = right;
-			playerMovement.moveDiagonalDownRight(this, map);
-	}
 	
 	///Methods dealing with Player Status////
 	public PlayerStatus getPlayerStatus() {return playerStats;}
@@ -266,6 +188,5 @@ public class Player extends Entity{
 			x = newX;
 			y = newY;
 	}
-	
 }
 
diff --git a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java
index b70c86c..93ea305 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
@@ -1,11 +1,67 @@
 package playerRelated;
 
+import org.newdawn.slick.Input;
+
 import gameStates.GameScreen;
 import mapRelated.BasicMap;
 
 public class PlayerMovement {
 
 	
+	public void movePlayer(Player player, BasicMap map, Input input)
+	{
+		//Diagonal Up Left
+		if (input.isKeyPressed(Input.KEY_NUMPAD7)||input.isKeyPressed(Input.KEY_7)){
+			 moveDiagonalUpLeft(player,map);
+		 }
+		
+		//Normal Up
+		else if (input.isKeyPressed(Input.KEY_UP)||input.isKeyPressed(Input.KEY_8)
+				||input.isKeyPressed(Input.KEY_NUMPAD8)){
+				moveUp(player,map);
+		}
+		
+		//Diagonal Up Right
+		else if (input.isKeyPressed(Input.KEY_NUMPAD9)||input.isKeyPressed(Input.KEY_9)){
+				moveDiagonalUpRight(player,map);
+		}
+
+		//Normal Left
+		else if (input.isKeyPressed(Input.KEY_LEFT)||input.isKeyPressed(Input.KEY_U)
+				||input.isKeyPressed(Input.KEY_NUMPAD4)){
+				moveLeft(player,map);
+		}
+		
+		//PASS TURN
+		else if (input.isKeyPressed(Input.KEY_NUMPAD5)||input.isKeyPressed(Input.KEY_I))
+			{
+			moveNowhere(player,map);
+			}
+		
+		//Normal Right
+		else if (input.isKeyPressed(Input.KEY_RIGHT)||input.isKeyPressed(Input.KEY_O)||
+				input.isKeyPressed(Input.KEY_NUMPAD6)){
+			moveRight(player,map);
+			}
+		
+		//Diagonal Down Left
+		else if (input.isKeyPressed(Input.KEY_NUMPAD1)||input.isKeyPressed(Input.KEY_J)){
+				moveDiagonalDownLeft(player,map);
+				}
+		
+		//Normal Down
+		else if (input.isKeyPressed(Input.KEY_DOWN)||input.isKeyPressed(Input.KEY_K)||
+				input.isKeyPressed(Input.KEY_NUMPAD2)){
+			moveDown(player,map);
+		}
+
+		//Diagonal Down Right
+		else if (input.isKeyPressed(Input.KEY_NUMPAD3)||input.isKeyPressed(Input.KEY_L)){
+			moveDiagonalDownRight(player,map);
+		}
+
+	}
+	
 	public void moveDiagonalUpLeft(Player player,BasicMap map){
 		int x = player.getPosition()[0];
 		int y = player.getPosition()[1];

commit 56c78235d0734fac91c1ef048c5a5295601cf44f
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Fri Oct 13 03:00:38 2017 -0600

    Got rid of mock keyboard that was used for testing

diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class
index 990394a..f7eed60 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class and b/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class differ
diff --git a/Version 1.1/NewestVersion/src/playerRelated/Player.java b/Version 1.1/NewestVersion/src/playerRelated/Player.java
index 9dce9fb..0e8a85f 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/Player.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/Player.java	
@@ -34,7 +34,7 @@ public class Player extends Entity{
 	private PlayerStatus playerStats;
 	private PlayerMovement playerMovement;
 	
-	////FOR TEST PURPOSES ONLY////
+	////FOR TEST PURPOSES ONLY TO AVOID UI EXCEPTIONS////
 	public Player (int x, int y){
 		super(x,y);
 		gc = null;
@@ -51,45 +51,7 @@ public class Player extends Entity{
 		playerStats = new PlayerStatus(this);
 		playerMovement = new PlayerMovement();
 	}
-		
-	public void mockKeyBoard(char c){
-		switch(c) 
-		{
-		case 'u'://Up
-			moveUp();
-			break;
-		case 'd'://Down
-			moveDown();
-			break;
-		case 'l'://Left
-			moveLeft();
-			break;
-		case 'r'://Right
-			moveRight();
-			break;
-		case 'a'://Diagonal Up Left
-			moveDiagonalUpLeft();
-			break;
-		case 'b'://Diagonal Up Right
-			moveDiagonalUpRight();
-			break;
-		case 'c'://Diagonal Down Left
-			moveDiagonalDownLeft();
-			break;
-		case 'f'://Diagonal Down Right
-			moveDiagonalDownRight();
-			break;
-		case 'g':
-			moveNowhere();
-			break;
-		default:
-			break;
-		}
-		
-		
-	}
-	
-	
+			
 	////FOR TEST PURPOSES ONLY////
 	public Player(GameContainer gc, StateBasedGame sbg, BasicMap currentMap,int x, int y) throws SlickException{
 		//Constructor used to 
diff --git a/Version 1.1/NewestVersion/src/testRelated/PlayerTest.java b/Version 1.1/NewestVersion/src/testRelated/PlayerTest.java
index 80d54a4..1165a4b 100644
--- a/Version 1.1/NewestVersion/src/testRelated/PlayerTest.java	
+++ b/Version 1.1/NewestVersion/src/testRelated/PlayerTest.java	
@@ -57,6 +57,8 @@ public class PlayerTest {
 		PlayerStatus playerStats = player.getPlayerStatus(); 
 		assertEquals("Player has leveled up",playerStats.addExperiencePoints(2000));
 	}
+	
+	
 	@Test
 	public void testPlayerMovementMoveLeft()
 	{
@@ -76,22 +78,15 @@ public class PlayerTest {
 		PlayerMovement movement = new PlayerMovement();
 		p.setEntityArray(testArray);
 		int [] expected = {3*BasicMap.TILESIZE, 5*BasicMap.TILESIZE};
-		int [] current = p.getPosition();
 		movement.moveLeft(p, map);
-		int [] after = p.getPosition();
 		assertArrayEquals(expected, p.getPosition());
 		
 	}
 	
-	
+
 	@Test
-	public void testPlayerMovement(){
-		
-		//Mock keyboard was call upon private method player movement
-		//The private methods would've originally been called depending on input from the keyboard
-		//In it's place characters have been used to individually call each method.
-		//Reflections (Private Objects for Java) proved to carry too many complications than it was worth.
-		
+	public void testPlayerMovementMoveRight()
+	{
 		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
 		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
 		
@@ -105,61 +100,131 @@ public class PlayerTest {
 		}
 		BasicMap map = new BasicMap(testMap);
 		Player p = new Player(4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, map);
+		PlayerMovement movement = new PlayerMovement();
 		p.setEntityArray(testArray);
-		int [] expected = {3*BasicMap.TILESIZE, 5*BasicMap.TILESIZE};
-		p.mockKeyBoard('l');
-		assertArrayEquals(expected, p.getPosition());
-		p.mockKeyBoard('r');
-		expected [0] = 4*BasicMap.TILESIZE;
-		assertArrayEquals(expected, p.getPosition());
-		expected [1] = 6*BasicMap.TILESIZE;
-		p.mockKeyBoard('d');
-		assertArrayEquals(expected, p.getPosition());
-		expected [1] = 5*BasicMap.TILESIZE;
-		p.mockKeyBoard('u');
+		int [] expected = {5*BasicMap.TILESIZE, 5*BasicMap.TILESIZE};
+		movement.moveRight(p, map);
 		assertArrayEquals(expected, p.getPosition());
+	}
+	
+	@Test
+	public void testPlayerMoveDiagonalDownRight()
+	{
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
 		
-		p.mockKeyBoard('a');
-		expected [0] -= BasicMap.TILESIZE;
-		expected [1] -= BasicMap.TILESIZE;
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		BasicMap map = new BasicMap(testMap);
+		Player p = new Player(4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, map);
+		PlayerMovement movement = new PlayerMovement();
+		p.setEntityArray(testArray);
+		int [] expected = {5*BasicMap.TILESIZE, 6*BasicMap.TILESIZE};
+		movement.moveDiagonalDownRight(p, map);
 		assertArrayEquals(expected, p.getPosition());
+	}
+	
+	
+	@Test
+	public void testPlayerMoveDiagonalUpLeft()
+	{
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
 		
-		p.mockKeyBoard('b');
-		expected [0] += BasicMap.TILESIZE;
-		expected [1] -= BasicMap.TILESIZE;
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		BasicMap map = new BasicMap(testMap);
+		Player p = new Player(4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, map);
+		PlayerMovement movement = new PlayerMovement();
+		p.setEntityArray(testArray);
+		int [] expected = {3*BasicMap.TILESIZE, 4*BasicMap.TILESIZE};
+		movement.moveDiagonalUpLeft(p, map);
 		assertArrayEquals(expected, p.getPosition());
+	}
+	
+	@Test
+	public void testPlayerMoveDiagonalDownLeft()
+	{
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
 		
-		p.mockKeyBoard('c');
-		expected [0] -= BasicMap.TILESIZE;
-		expected [1] += BasicMap.TILESIZE;
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		BasicMap map = new BasicMap(testMap);
+		Player p = new Player(4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, map);
+		PlayerMovement movement = new PlayerMovement();
+		p.setEntityArray(testArray);
+		int [] expected = {3*BasicMap.TILESIZE, 6*BasicMap.TILESIZE};
+		movement.moveDiagonalDownLeft(p, map);
 		assertArrayEquals(expected, p.getPosition());
+	}
+	
+	@Test
+	public void testPlayerMoveUp()
+	{
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
 		
-		
-		p.mockKeyBoard('f');
-		expected [0] += BasicMap.TILESIZE;
-		expected [1] += BasicMap.TILESIZE;
-		
-		assertArrayEquals(expected, p.getPosition());
-		p.mockKeyBoard('y');
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		BasicMap map = new BasicMap(testMap);
+		Player p = new Player(4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, map);
+		PlayerMovement movement = new PlayerMovement();
+		p.setEntityArray(testArray);
+		int [] expected = {4*BasicMap.TILESIZE, 4*BasicMap.TILESIZE};
+		movement.moveUp(p, map);
 		assertArrayEquals(expected, p.getPosition());
-		p.mockKeyBoard('g');
-		assertArrayEquals(expected, p.getPosition());		
 	}
 	
-	/*
 	@Test
-	public void testPlayerMoveUp() throws SecurityException, NoSuchMethodException, IllegalAccessException,InvocationTargetException{
-		Player p = new Player(4*BasicMap.TILESIZE,5*BasicMap.TILESIZE);
-
-		Method privateUpMethod = Player.class.getDeclaredMethod("moveUp", String.class);
-
-		privateUpMethod.setAccessible(true);
-
-	    privateUpMethod.invoke(p, null);
-
-	}
-	*/	
+	public void testPlayerMoveDown()
+	{
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
 		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		BasicMap map = new BasicMap(testMap);
+		Player p = new Player(4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, map);
+		PlayerMovement movement = new PlayerMovement();
+		p.setEntityArray(testArray);
+		int [] expected = {4*BasicMap.TILESIZE, 6*BasicMap.TILESIZE};
+		movement.moveDown(p, map);
+		assertArrayEquals(expected, p.getPosition());
+	}
+	
+	
+	
 		
 }
 

commit 2a63b4fd6054ff1376eb459c37292a1dfcf842cf
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Fri Oct 13 02:47:28 2017 -0600

    Found that I could refactor out the mock keyboard used for only testing purposes out of the player code

diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class
index 12db5c9..990394a 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class and b/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class differ
diff --git a/Version 1.1/NewestVersion/src/testRelated/PlayerTest.java b/Version 1.1/NewestVersion/src/testRelated/PlayerTest.java
index 761ce8a..80d54a4 100644
--- a/Version 1.1/NewestVersion/src/testRelated/PlayerTest.java	
+++ b/Version 1.1/NewestVersion/src/testRelated/PlayerTest.java	
@@ -8,6 +8,7 @@ import mapRelated.BasicMap;
 import org.junit.Test;
 
 import playerRelated.Player;
+import playerRelated.PlayerMovement;
 import playerRelated.PlayerStatus;
 
 public class PlayerTest {
@@ -56,6 +57,32 @@ public class PlayerTest {
 		PlayerStatus playerStats = player.getPlayerStatus(); 
 		assertEquals("Player has leveled up",playerStats.addExperiencePoints(2000));
 	}
+	@Test
+	public void testPlayerMovementMoveLeft()
+	{
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		BasicMap map = new BasicMap(testMap);
+		Player p = new Player(4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, map);
+		PlayerMovement movement = new PlayerMovement();
+		p.setEntityArray(testArray);
+		int [] expected = {3*BasicMap.TILESIZE, 5*BasicMap.TILESIZE};
+		int [] current = p.getPosition();
+		movement.moveLeft(p, map);
+		int [] after = p.getPosition();
+		assertArrayEquals(expected, p.getPosition());
+		
+	}
+	
 	
 	@Test
 	public void testPlayerMovement(){

commit 9d92fd093f5fa7bf338f19f2fcfc8a2bf68e6433
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Fri Oct 13 02:36:35 2017 -0600

    All tests passed

diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class
index 809d845..fcc1494 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class and b/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class
index f717e5d..7e5cc20 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class and b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class differ
diff --git a/Version 1.1/NewestVersion/src/playerRelated/Player.java b/Version 1.1/NewestVersion/src/playerRelated/Player.java
index 7003184..9dce9fb 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/Player.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/Player.java	
@@ -204,7 +204,7 @@ public class Player extends Entity{
 			}
 		
 		//Diagonal Down Left
-		else if (input.isKeyPressed(Input.KEY_NUMPAD1)||input.isKeyPressed(Input.KEY_J\)){
+		else if (input.isKeyPressed(Input.KEY_NUMPAD1)||input.isKeyPressed(Input.KEY_J)){
 				moveDiagonalDownLeft();
 				}
 		
@@ -238,7 +238,7 @@ public class Player extends Entity{
 		
 	private void moveDiagonalUpRight(){
 			currentSprite = right;
-			playerMovement.moveUp(this,map);
+			playerMovement.moveDiagonalUpRight(this,map);
 		}
 
 	private void moveLeft(){	
@@ -265,7 +265,7 @@ public class Player extends Entity{
 				
 	private void moveDown(){
 			currentSprite = down;
-			playerMovement.moveDiagonalDownLeft(this, map);
+			playerMovement.moveDown(this, map);
 			
 	}
 

commit 9dc49fdc6b4685ad62735ff825a9f67384e11d4d
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Fri Oct 13 02:34:08 2017 -0600

    Extracted rest of movement

diff --git a/Version 1.1/NewestVersion/src/playerRelated/Player.java b/Version 1.1/NewestVersion/src/playerRelated/Player.java
index b9184c5..7003184 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/Player.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/Player.java	
@@ -164,6 +164,11 @@ public class Player extends Entity{
 		//Input used to get keyboard controls
 		Input input = gc.getInput();
 		 
+///		int[] LeftKeys = new int[] {Input.KEY_NUMPAD7, Input.KEY_7,
+	///			Input.KEY_NUMPAD1,Input.KEY_J,
+		///		Input.KEY_LEFT,Input.KEY_U,Input.KEY_NUMPAD4};
+		
+		
 		//Diagonal Up Left
 		if (input.isKeyPressed(Input.KEY_NUMPAD7)||input.isKeyPressed(Input.KEY_7)){
 			 moveDiagonalUpLeft();
@@ -199,7 +204,7 @@ public class Player extends Entity{
 			}
 		
 		//Diagonal Down Left
-		else if (input.isKeyPressed(Input.KEY_NUMPAD1)||input.isKeyPressed(Input.KEY_J)){
+		else if (input.isKeyPressed(Input.KEY_NUMPAD1)||input.isKeyPressed(Input.KEY_J\)){
 				moveDiagonalDownLeft();
 				}
 		
@@ -242,103 +247,32 @@ public class Player extends Entity{
 		}
 		
 	private void moveNowhere()
-			{
+		{
 			currentSprite = down;
-			if (map.isStairs(x, y)){
-				onStairs = true;
-				}
-			if (map.isWin(x, y))
-			{
-			GameScreen.setWin(true);
-			}
-		
-			}
+			playerMovement.moveNowhere(this, map);	
+		}
 		
 	private void moveRight(){
 			currentSprite = right;
-			int newX = x + BasicMap.TILESIZE;
-			if  (isTaken(newX, y))
-				attack(newX,y);
-			else if (!(map.hasCollision(newX, y))){
-				updatePosition(newX,y);
-				x = newX;
-				if (map.isStairs(x, y)){
-					onStairs = true;
-					}
-				if (map.isWin(x, y))
-				{
-				GameScreen.setWin(true);
-				}
-			
-				}
-			}	
+			playerMovement.moveRight(this, map);
+		}	
 		
 		
 	private void moveDiagonalDownLeft(){
 				currentSprite = left;
-				int newX = x-BasicMap.TILESIZE;
-				int newY = y +BasicMap.TILESIZE;
-				if (isTaken(newX, newY))
-					attack(newX, newY);
-				else if (!(map.hasCollision(newX,  newY)))
-					{
-					updatePosition(newX,newY);
-					x = newX;
-					y = newY;
-					if (map.isStairs(x, y)){
-						onStairs = true;
-						}
-					if (map.isWin(x, y))
-					{
-					GameScreen.setWin(true);
-					}
-				
-					}
+				playerMovement.moveDiagonalDownLeft(this, map);
 				}
 				
 	private void moveDown(){
 			currentSprite = down;
-			int newY = y +BasicMap.TILESIZE;
-			if (isTaken(x, newY))
-				attack (x, newY);
-			else if (!(map.hasCollision(x, newY))){
-				updatePosition(x,newY);
-				y = newY;
-				if (map.isStairs(x, y)){
-					onStairs = true;
-					}
-				if (map.isWin(x, y))
-				{
-				GameScreen.setWin(true);
-				}
+			playerMovement.moveDiagonalDownLeft(this, map);
 			
-				}
-			
-			}
+	}
 
 	private void moveDiagonalDownRight(){
 			currentSprite = right;
-			int newX = x+BasicMap.TILESIZE;
-			int newY = y+BasicMap.TILESIZE;
-				if (isTaken(newX, newY)){
-					attack(newX, newY);
-				}
-				else if (!(map.hasCollision(newX,newY)))
-					{
-					updatePosition(newX,newY);
-					x = newX;
-					y = newY;
-					if (map.isStairs(x, y)){
-						onStairs = true;
-						}
-					if (map.isWin(x, y))
-					{
-					GameScreen.setWin(true);
-					}
-				
-					}
-			
-				}
+			playerMovement.moveDiagonalDownRight(this, map);
+	}
 	
 	///Methods dealing with Player Status////
 	public PlayerStatus getPlayerStatus() {return playerStats;}
diff --git a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java
index ddad229..b70c86c 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
@@ -115,9 +115,96 @@ public class PlayerMovement {
 		}
 
 	}
+	
+	public void moveRight(Player player, BasicMap map){
+		int x = player.getPosition()[0];
+		int y = player.getPosition()[1];
+		int newX = x + BasicMap.TILESIZE;
+		if  (player.isTaken(newX, y))
+			player.attack(newX,y);
+		else if (!(map.hasCollision(newX, y))){
+				player.updatePosition(newX,y);
+			x = newX;
+			if (map.isStairs(x, y)){
+				player.setOnStairs(true);
+						}
+			if (map.isWin(x, y))
+			{
+			GameScreen.setWin(true);
+			}
+		
+			}
+		}	
+	
+	
+	public void moveDiagonalDownLeft(Player player, BasicMap map){
+		int x = player.getPosition()[0];
+		int y = player.getPosition()[1];
+		int newX = x-BasicMap.TILESIZE;
+		int newY = y +BasicMap.TILESIZE;
+		if (player.isTaken(newX, newY))
+			player.attack(newX, newY);
+		else if (!(map.hasCollision(newX,  newY)))
+			{
+			player.updatePosition(newX,newY);
+			x = newX;
+			y = newY;
+			if (map.isStairs(x, y)){
+				player.setOnStairs(true);
+				}
+			if (map.isWin(x, y))
+			{
+			GameScreen.setWin(true);
+			}
+		
+			}
+		}
+		
+public void moveDown(Player player, BasicMap map){
+	int x = player.getPosition()[0];
+	int y = player.getPosition()[1];
+    int newY = y +BasicMap.TILESIZE;
+	if (player.isTaken(x, newY))
+		player.attack (x, newY);
+	else if (!(map.hasCollision(x, newY))){
+		player.updatePosition(x,newY);
+		y = newY;
+		if (map.isStairs(x, y)){
+			player.setOnStairs(true);
+			}
+		if (map.isWin(x, y))
+		{
+		GameScreen.setWin(true);
+		}
+	
+		}
+	
+	}
 
-
-
+public void moveDiagonalDownRight(Player player, BasicMap map){
+	int x = player.getPosition()[0];
+	int y = player.getPosition()[1];
+	int newX = x+BasicMap.TILESIZE;
+	int newY = y+BasicMap.TILESIZE;
+		if (player.isTaken(newX, newY)){
+			player.attack(newX, newY);
+		}
+		else if (!(map.hasCollision(newX,newY)))
+			{
+			player.updatePosition(newX,newY);
+			x = newX;
+			y = newY;
+			if (map.isStairs(x, y)){
+				player.setOnStairs(true);
+				}
+			if (map.isWin(x, y))
+			{
+			GameScreen.setWin(true);
+			}
+		
+			}
+	
+		}
 
 
 

commit b313119d4550390247e17da076de5c52da8b06d7
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Fri Oct 13 02:17:30 2017 -0600

    Extracted Move nowhere, move left, move diagonal right

diff --git a/Version 1.1/NewestVersion/src/playerRelated/Player.java b/Version 1.1/NewestVersion/src/playerRelated/Player.java
index 5245972..b9184c5 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/Player.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/Player.java	
@@ -233,45 +233,12 @@ public class Player extends Entity{
 		
 	private void moveDiagonalUpRight(){
 			currentSprite = right;
-			int newX = x + BasicMap.TILESIZE;
-			int newY = y - BasicMap.TILESIZE;
-			
-			if (isTaken(newX, newY))
-				attack(newX, newY);
-			else if (!(map.hasCollision(newX, newY)))	
-				{
-					updatePosition(newX,newY);
-					y = newY;
-					x = newX;	
-					if (map.isStairs(x, y)){
-						onStairs = true;
-						}
-					if (map.isWin(x, y))
-					{
-					GameScreen.setWin(true);
-					}
-				
-				}
+			playerMovement.moveUp(this,map);
 		}
 
 	private void moveLeft(){	
 			currentSprite = left;
-			int newX = x-BasicMap.TILESIZE;
-			if (isTaken(newX, y))
-				attack(newX,y);
-			else if (!(map.hasCollision(newX, y))){
-				updatePosition(newX,y);
-				x = newX;
-				if (map.isStairs(x, y)){
-					onStairs = true;
-					}
-				if (map.isWin(x, y))
-				{
-				GameScreen.setWin(true);
-				}
-			
-			}
-			
+			playerMovement.moveLeft(this,map);
 		}
 		
 	private void moveNowhere()
diff --git a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java
index bfba6a9..ddad229 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
@@ -52,6 +52,71 @@ public class PlayerMovement {
 			}
 			
 	}
+	
+	public void moveDiagonalUpRight(Player player, BasicMap map){
+		
+		int x = player.getPosition()[0];
+		int y = player.getPosition()[1];
+		
+		int newX = x + BasicMap.TILESIZE;
+		int newY = y - BasicMap.TILESIZE;
+		
+		if (player.isTaken(newX, newY))
+			player.attack(newX, newY);
+		else if (!(map.hasCollision(newX, newY)))	
+			{
+				player.updatePosition(newX,newY);
+				y = newY;
+				x = newX;	
+				if (map.isStairs(x, y)){
+					player.setOnStairs(true);
+					}
+				if (map.isWin(x, y))
+				{
+				GameScreen.setWin(true);
+				}
+			
+			}
+	}
+	
+	public void moveLeft(Player player, BasicMap map){	
+		int x = player.getPosition()[0];
+		int y = player.getPosition()[1];
+	
+		int newX = x-BasicMap.TILESIZE;
+		if (player.isTaken(newX, y))
+			player.attack(newX,y);
+		else if (!(map.hasCollision(newX, y))){
+			player.updatePosition(newX,y);
+			x = newX;
+			if (map.isStairs(x, y)){
+				player.setOnStairs(true);
+						}
+			if (map.isWin(x, y))
+			{
+			GameScreen.setWin(true);
+			}
+		
+		}
+		
+	}
+
+
+	public void moveNowhere(Player player, BasicMap map)
+	{
+		int x = player.getPosition()[0];
+		int y = player.getPosition()[1];
+		if (map.isStairs(x, y)){
+			player.setOnStairs(true);
+		}
+		if (map.isWin(x, y))
+		{
+			GameScreen.setWin(true);
+		}
+
+	}
+
+
 
 
 

commit 031e4cdc61545cdec909087a17134dbdbd1567ef
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 23:11:47 2017 -0600

    Extracted moveUp

diff --git a/Version 1.1/NewestVersion/src/playerRelated/Player.java b/Version 1.1/NewestVersion/src/playerRelated/Player.java
index 43b1ab3..5245972 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/Player.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/Player.java	
@@ -219,29 +219,15 @@ public class Player extends Entity{
 	
 ////////////METHODS DEALING WITH MOVEMENT//////////////////////
 	private void moveDiagonalUpLeft(){
-			 currentSprite = left;
+		    //Update Sprite
+   			 currentSprite = left;
 			 playerMovement.moveDiagonalUpLeft(this, map);
 		 }
 	
 	
 	private void moveUp(){
 			currentSprite = up;
-			int newY = y - BasicMap.TILESIZE;
-			if (isTaken(x,newY))
-				attack(x, newY);
-			else if (!(map.hasCollision(x, newY))){
-				updatePosition(x,newY);
-				y = newY;
-				if (map.isStairs(x, y)){
-					onStairs = true;
-					}
-				if (map.isWin(x, y))
-				{
-				GameScreen.setWin(true);
-				}
-			
-			}
-			
+			playerMovement.moveUp(this, map);
 		}
 		
 		
diff --git a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java
index 8bc0c0e..bfba6a9 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
@@ -29,6 +29,30 @@ public class PlayerMovement {
 				}
 			}
 	 }
+	
+
+	public void moveUp(Player player,BasicMap map){
+		int x = player.getPosition()[0];
+		int y = player.getPosition()[1];
+		
+		int newY = y - BasicMap.TILESIZE;
+		
+		if (player.isTaken(x,newY))
+			player.attack(x, newY);
+		else if (!(map.hasCollision(x, newY))){
+			player.updatePosition(x,newY);
+			y = newY;
+			if (map.isStairs(x, y)){
+				player.setOnStairs(true);
+				}
+			if (map.isWin(x, y))
+			{
+			GameScreen.setWin(true);
+			}		
+			}
+			
+	}
+
 
 
 

commit 2b8d4dbbef4e83c44449cc35732894c6f1e7082d
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 23:05:17 2017 -0600

    Updated Player References

diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets.class b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets.class
index f2bf88e..6482446 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets.class and b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class
index 7b63e1c..809d845 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class and b/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class
index 9259de6..f717e5d 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class and b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class differ
diff --git a/Version 1.1/NewestVersion/src/gameStates/GameScreenAssets.java b/Version 1.1/NewestVersion/src/gameStates/GameScreenAssets.java
index a0baa77..a75668f 100644
--- a/Version 1.1/NewestVersion/src/gameStates/GameScreenAssets.java	
+++ b/Version 1.1/NewestVersion/src/gameStates/GameScreenAssets.java	
@@ -78,7 +78,7 @@ public class GameScreenAssets {
 
 	    //Draw Player Level
 	    g.setColor(Color.yellow);
-	    g.drawString("Lvl: "+player.getCurrentLevel(),10, 450);
+	    g.drawString("Lvl: "+player.getPlayerStatus().getPlayerLevel(),10, 450);
 	    
 	    g.setColor(Color.white);
 	    ///Draw Health Bar
diff --git a/Version 1.1/NewestVersion/src/playerRelated/Player.java b/Version 1.1/NewestVersion/src/playerRelated/Player.java
index c18efa0..43b1ab3 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/Player.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/Player.java	
@@ -32,6 +32,7 @@ public class Player extends Entity{
 	private Image shadow;		
 
 	private PlayerStatus playerStats;
+	private PlayerMovement playerMovement;
 	
 	////FOR TEST PURPOSES ONLY////
 	public Player (int x, int y){
@@ -39,6 +40,7 @@ public class Player extends Entity{
 		gc = null;
 		name = "P";
 		playerStats = new PlayerStatus(this);
+		playerMovement = new PlayerMovement();
 	}
 	
 	public Player (int x, int y, BasicMap map){
@@ -47,6 +49,7 @@ public class Player extends Entity{
 		gc = null;
 		name = "P";
 		playerStats = new PlayerStatus(this);
+		playerMovement = new PlayerMovement();
 	}
 		
 	public void mockKeyBoard(char c){
@@ -217,24 +220,7 @@ public class Player extends Entity{
 ////////////METHODS DEALING WITH MOVEMENT//////////////////////
 	private void moveDiagonalUpLeft(){
 			 currentSprite = left;
-			int newX = x-BasicMap.TILESIZE;
-			int newY = y-BasicMap.TILESIZE;
-			if (isTaken(newX, newY))
-				attack(newX,newY);
-			else if (!(map.hasCollision(newX, newY)))
-				{
-				updatePosition(newX,newY);
-				x = newX;
-				y = newY;
-				
-				if (map.isStairs(x, y)){
-					onStairs = true;
-					}
-				if (map.isWin(x, y))
-					{
-					GameScreen.setWin(true);
-					}
-				}
+			 playerMovement.moveDiagonalUpLeft(this, map);
 		 }
 	
 	
@@ -401,12 +387,18 @@ public class Player extends Entity{
 			
 				}
 	
+	///Methods dealing with Player Status////
 	public PlayerStatus getPlayerStatus() {return playerStats;}
-	
+
+	public void loadStats(int newLevel, int newExp, int newHealth)
+	{
+		playerStats = new PlayerStatus(this,newLevel, newExp, newHealth);
+	}
+			
 	
 ///////////METHODS DEALING WITH COMBAT///////////////////	
 	
-	private void attack(int monsterX, int monsterY){
+	void attack(int monsterX, int monsterY){
 		int criticalHitLimit = playerStats.getCriticaHitLimit();
 		int missFactor = playerStats.getMissFactor();
 		CombatManager.attackLoop(this,criticalHitLimit, missFactor, monsterX, monsterY);	
@@ -418,13 +410,7 @@ public class Player extends Entity{
 	public boolean getOnStairs(){return onStairs;}
 	
 	public void setOnStairs(boolean var){onStairs = var;}
-
-	///Methods dealing loading////
-	public void loadStats(int newLevel, int newExp, int newHealth)
-	{
-			playerStats = new PlayerStatus(this,newLevel, newExp, newHealth);
-	}
-		
+	
 		
 	public void setPosition(int newX, int newY)
 	{
diff --git a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java
index 90b3e8b..8bc0c0e 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
@@ -1,6 +1,35 @@
 package playerRelated;
 
+import gameStates.GameScreen;
+import mapRelated.BasicMap;
+
 public class PlayerMovement {
 
+	
+	public void moveDiagonalUpLeft(Player player,BasicMap map){
+		int x = player.getPosition()[0];
+		int y = player.getPosition()[1];
+		
+		int newX = x-BasicMap.TILESIZE;
+		int newY = y-BasicMap.TILESIZE;
+		if (player.isTaken(newX, newY))
+			player.attack(newX,newY);
+		else if (!(map.hasCollision(newX, newY)))
+			{
+			player.updatePosition(newX,newY);
+			x = newX;
+			y = newY;
+			
+			if (map.isStairs(x, y)){
+				player.setOnStairs(true);
+				}
+			if (map.isWin(x, y))
+				{
+				GameScreen.setWin(true);
+				}
+			}
+	 }
+
+
 
 }

commit 7bea36b2ca6bfdada80465f426de4d8e7a7ee35f
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 22:47:41 2017 -0600

    Updated Player references in other classes to refer to player status instead

diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets.class b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets.class
index 0324cba..f2bf88e 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets.class and b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/SavingGame.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/SavingGame.class
index 609a6e7..1174989 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/SavingGame.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/SavingGame.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class b/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class
index e4d4ca4..e5a391d 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class and b/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class
index e6ba7f4..7b63e1c 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class and b/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class differ
diff --git a/Version 1.1/NewestVersion/src/gameStates/GameScreenAssets.java b/Version 1.1/NewestVersion/src/gameStates/GameScreenAssets.java
index b3677f7..a0baa77 100644
--- a/Version 1.1/NewestVersion/src/gameStates/GameScreenAssets.java	
+++ b/Version 1.1/NewestVersion/src/gameStates/GameScreenAssets.java	
@@ -96,8 +96,8 @@ public class GameScreenAssets {
         //Draw Experience Bar
         g.setColor(Color.white);
 	    g.drawString("EXP", 80, 480);
-	    g.drawString(""+player.getExperiencePoints()+"/"+player.getPointsNextLevel(), 420, 480);
-	    Rectangle expBar = new Rectangle(110, 480, 300*player.getExperiencePoints()/player.getPointsNextLevel(), 20);
+	    g.drawString(""+player.getPlayerStatus().getExperiencePoints()+"/"+player.getPlayerStatus().getPointsNextLevel(), 420, 480);
+	    Rectangle expBar = new Rectangle(110, 480, 300*player.getPlayerStatus().getExperiencePoints()/player.getPlayerStatus().getPointsNextLevel(), 20);
         GradientFill fillGreen = new GradientFill(110, 0, new Color(90, 255, 20),
                                              480 + 300, 0, new Color(40, 180, 40));
         g.setColor(Color.darkGray);
diff --git a/Version 1.1/NewestVersion/src/inputRelated/SavingGame.java b/Version 1.1/NewestVersion/src/inputRelated/SavingGame.java
index 9425991..9bcae83 100644
--- a/Version 1.1/NewestVersion/src/inputRelated/SavingGame.java	
+++ b/Version 1.1/NewestVersion/src/inputRelated/SavingGame.java	
@@ -10,12 +10,14 @@ import java.util.LinkedList;
 import managers.MonsterManager;
 import monsterRelated.BasicMonster;
 import playerRelated.Player;
+import playerRelated.PlayerStatus;
 
 public class SavingGame {
 		
 	public static void SaveGame(GameScreenAssets gsa, Player player, MonsterManager monsterManage){
 		try
 		{
+			PlayerStatus playerStatus = player.getPlayerStatus();
 			FileWriter fw = new FileWriter("save.txt");
 			PrintWriter pw = new PrintWriter(fw);
 			//First Write Floor number. Newline.
@@ -24,9 +26,9 @@ public class SavingGame {
 			pw.println(player.getPosition()[0]);
 			pw.println(player.getPosition()[1]);
 			//Player level
-			pw.println(player.getCurrentLevel());
+			pw.println(playerStatus.getPlayerLevel());
 			//Player experience points. new line
-			pw.println(player.getExperiencePoints());
+			pw.println(playerStatus.getExperiencePoints());
 			//Player health points. new line.
 			pw.println(player.getHealthPoints());
 			//Start loop for saving monster info
diff --git a/Version 1.1/NewestVersion/src/managers/CombatManager.java b/Version 1.1/NewestVersion/src/managers/CombatManager.java
index 23724fc..6e6b1ce 100644
--- a/Version 1.1/NewestVersion/src/managers/CombatManager.java	
+++ b/Version 1.1/NewestVersion/src/managers/CombatManager.java	
@@ -113,7 +113,7 @@ public class CombatManager {
 	private static void monsterDies(Player player, BasicMonster currentFoe){
 		GameScreenAssets.queueTextLog.addFirst("You've Killed the monster!");
 		SoundManager.playSoundEffect("res/sound/SFX/MonsterDie.wav");
-		player.addExperiencePoints(currentFoe.getExpPointGain());
+		player.getPlayerStatus().addExperiencePoints(currentFoe.getExpPointGain());
 		battleHappening = false;
 		monsterList.remove(currentFoe);
 	
diff --git a/Version 1.1/NewestVersion/src/playerRelated/Player.java b/Version 1.1/NewestVersion/src/playerRelated/Player.java
index d62fa59..c18efa0 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/Player.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/Player.java	
@@ -401,7 +401,6 @@ public class Player extends Entity{
 			
 				}
 	
-///////////METHOD DEALING WITH LEVELING UP////////////////////
 	public PlayerStatus getPlayerStatus() {return playerStats;}
 	
 	

commit 8c11853bf440fff23960aa79448cf9be802a49d9
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 22:44:34 2017 -0600

    Removed all player stats methods except for linking ref to player status class and updated Test Methods

diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets.class b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets.class
index d9187f5..0324cba 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets.class and b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets1.class b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets1.class
index 64663f7..2a8e60a 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets1.class and b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets1.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/SavingGame.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/SavingGame.class
index 79a2e72..609a6e7 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/SavingGame.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/SavingGame.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class b/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class
index 0cbab7a..e4d4ca4 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class and b/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/Entity.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/Entity.class
index 6ac51b9..1efc33a 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/Entity.class and b/VERSION W.I.P/version w.i.p/bin/monsterRelated/Entity.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class
index b065ed2..e6ba7f4 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class and b/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerStatus.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerStatus.class
index c139bb8..1717c2a 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerStatus.class and b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerStatus.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerTest.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerTest.class
index 20c2511..a7b42d7 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerTest.class and b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class
index a63590e..12db5c9 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class and b/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class differ
diff --git a/Version 1.1/NewestVersion/src/playerRelated/Player.java b/Version 1.1/NewestVersion/src/playerRelated/Player.java
index 574af33..d62fa59 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/Player.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/Player.java	
@@ -402,21 +402,7 @@ public class Player extends Entity{
 				}
 	
 ///////////METHOD DEALING WITH LEVELING UP////////////////////
-	public String addExperiencePoints(int points){
-		return addExperiencePoints(points);
-	}
-	
-	//Method used when the player levels up
-	private boolean levelUp(){
-		return playerStats. levelUp();
-	}
-
-		
-	public int getCurrentLevel(){return playerStats.getPlayerLevel();}
-	
-	public int getExperiencePoints(){return playerStats.getExperiencePoints();}
-	
-	public int getPointsNextLevel() {return playerStats.getPointsNextLevel();}
+	public PlayerStatus getPlayerStatus() {return playerStats;}
 	
 	
 ///////////METHODS DEALING WITH COMBAT///////////////////	
diff --git a/Version 1.1/NewestVersion/src/testRelated/PlayerTest.java b/Version 1.1/NewestVersion/src/testRelated/PlayerTest.java
index 345adc7..761ce8a 100644
--- a/Version 1.1/NewestVersion/src/testRelated/PlayerTest.java	
+++ b/Version 1.1/NewestVersion/src/testRelated/PlayerTest.java	
@@ -8,6 +8,7 @@ import mapRelated.BasicMap;
 import org.junit.Test;
 
 import playerRelated.Player;
+import playerRelated.PlayerStatus;
 
 public class PlayerTest {
 
@@ -16,20 +17,21 @@ public class PlayerTest {
 	@Test
 	public void testExperiencePoints(){
 		Player player = new Player (10, 10);
-		player.addExperiencePoints(10);
-		assertEquals(0, player.getExperiencePoints());
-		assertEquals(20,player.getPointsNextLevel());
-		player.addExperiencePoints(20);
-		assertEquals(40,player.getPointsNextLevel());
-		player.addExperiencePoints(40);
-		assertEquals(80,player.getPointsNextLevel());
-		player.addExperiencePoints(80);
-		assertEquals(160,player.getPointsNextLevel());
-		player.addExperiencePoints(160);
-		assertEquals(320,player.getPointsNextLevel());	
-		player.addExperiencePoints(320);
-		assertEquals(640,player.getPointsNextLevel());	
-		assertEquals(7, player.getCurrentLevel());
+		PlayerStatus playerStats = player.getPlayerStatus(); 
+		playerStats.addExperiencePoints(10);
+		assertEquals(0, playerStats.getExperiencePoints());
+		assertEquals(20,playerStats.getPointsNextLevel());
+		playerStats.addExperiencePoints(20);
+		assertEquals(40,playerStats.getPointsNextLevel());
+		playerStats.addExperiencePoints(40);
+		assertEquals(80,playerStats.getPointsNextLevel());
+		playerStats.addExperiencePoints(80);
+		assertEquals(160,playerStats.getPointsNextLevel());
+		playerStats.addExperiencePoints(160);
+		assertEquals(320,playerStats.getPointsNextLevel());	
+		playerStats.addExperiencePoints(320);
+		assertEquals(640,playerStats.getPointsNextLevel());	
+		assertEquals(7, playerStats.getPlayerLevel());
 		
 	}
 
@@ -37,19 +39,22 @@ public class PlayerTest {
 	public void testNegativeExperiencePoints(){
 		//Arrange
 		Player player = new Player (10,10);		
-		assertEquals("Can't gain negative EXP",player.addExperiencePoints(-100));
+		PlayerStatus playerStats = player.getPlayerStatus(); 
+		assertEquals("Can't gain negative EXP",playerStats.addExperiencePoints(-100));
 	}
 	@Test
 	public void test_NoLevelUp() {
 		Player player = new Player(10,10);
-		assertEquals(null, player.addExperiencePoints(1));
+		PlayerStatus playerStats = player.getPlayerStatus(); 
+		assertEquals(null,playerStats.addExperiencePoints(1));
 	}
 	
 	
 	@Test 
 	public void testPlayerLevelUp(){
 		Player player = new Player (10,10);		
-		assertEquals("Player has leveled up",player.addExperiencePoints(2000));
+		PlayerStatus playerStats = player.getPlayerStatus(); 
+		assertEquals("Player has leveled up",playerStats.addExperiencePoints(2000));
 	}
 	
 	@Test

commit b83fe819054307734db4a3a8833079dec32c629c
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 22:38:30 2017 -0600

    Tested Extracted Methods after minor extraction bug fixes

diff --git a/Version 1.1/NewestVersion/src/playerRelated/Player.java b/Version 1.1/NewestVersion/src/playerRelated/Player.java
index 3f216eb..574af33 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/Player.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/Player.java	
@@ -403,18 +403,7 @@ public class Player extends Entity{
 	
 ///////////METHOD DEALING WITH LEVELING UP////////////////////
 	public String addExperiencePoints(int points){
-		if (points <0)
-			return "Can't gain negative EXP";
-		
-		//Add points given
-		experiencePoints += points;
-		if (levelUp())
-		{
-			GameScreenAssets.queueTextLog.add("Woohoo! Player has leveled Up!");
-	//		SoundManager.playSoundEffect("res/sound/SFX/Level Up Ding.wav");
-			return "Player has leveled up";
-		}
-		return null;
+		return addExperiencePoints(points);
 	}
 	
 	//Method used when the player levels up
diff --git a/Version 1.1/NewestVersion/src/playerRelated/PlayerStatus.java b/Version 1.1/NewestVersion/src/playerRelated/PlayerStatus.java
index 99b615c..747380e 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/PlayerStatus.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/PlayerStatus.java	
@@ -1,5 +1,7 @@
 package playerRelated;
 
+import gameStates.GameScreenAssets;
+
 public class PlayerStatus {
 
 	
@@ -27,6 +29,21 @@ public class PlayerStatus {
 			criticalHitLimit = 30+5*(newLevel-1);	
 			missFactor = 10 - 5*(newLevel-1);
 		}
+		
+		public String addExperiencePoints(int points){
+			if (points <0)
+				return "Can't gain negative EXP";
+			
+			//Add points given
+			experiencePoints += points;
+			if (levelUp())
+			{
+				GameScreenAssets.queueTextLog.add("Woohoo! Player has leveled Up!");
+		//		SoundManager.playSoundEffect("res/sound/SFX/Level Up Ding.wav");
+				return "Player has leveled up";
+			}
+			return null;
+		}
 	
     	//Method used when the player levels up
 		public boolean levelUp(){

commit e63b315b7e9a3902329b5280bc0034dfa734e883
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 22:33:19 2017 -0600

    Extracted level up and using original code to call old code. Had to move variables over. Resolved most conflicts before further extraction.

diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/GameWindowSettings.class b/VERSION W.I.P/version w.i.p/bin/gameStates/GameWindowSettings.class
index ac52f1d..5beec11 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/GameWindowSettings.class and b/VERSION W.I.P/version w.i.p/bin/gameStates/GameWindowSettings.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/Ver2GameDriver.class b/VERSION W.I.P/version w.i.p/bin/gameStates/Ver2GameDriver.class
index 0ebe611..06ea483 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/Ver2GameDriver.class and b/VERSION W.I.P/version w.i.p/bin/gameStates/Ver2GameDriver.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class b/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class
index 7a95005..3d4cbd6 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class and b/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMap$GameWindowSettings.class b/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMap$GameWindowSettings.class
new file mode 100644
index 0000000..9449cf7
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMap$GameWindowSettings.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMap.class b/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMap.class
index 275e7f5..d6c0544 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMap.class and b/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMap.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/Entity.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/Entity.class
index efdb99e..6ac51b9 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/Entity.class and b/VERSION W.I.P/version w.i.p/bin/monsterRelated/Entity.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class
index e79595c..b065ed2 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class and b/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class
new file mode 100644
index 0000000..9259de6
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerMovement.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerStatus.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerStatus.class
new file mode 100644
index 0000000..c139bb8
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerStatus.class differ
diff --git a/Version 1.1/NewestVersion/src/gameStates/GameWindowSettings.java b/Version 1.1/NewestVersion/src/gameStates/GameWindowSettings.java
index 9be5ea1..4110695 100644
--- a/Version 1.1/NewestVersion/src/gameStates/GameWindowSettings.java	
+++ b/Version 1.1/NewestVersion/src/gameStates/GameWindowSettings.java	
@@ -4,12 +4,6 @@ import mapRelated.BasicMap;
 
 public class GameWindowSettings {
 
-	private static final int screenWidth = BasicMap.TILESIZE*BasicMap.widthByTiles;
-	private static final int screenHeight = BasicMap.TILESIZE*BasicMap.heightByTiles;
-	
-	public static int getScreenWidth() {return screenWidth;}
-	public static int getScreenHeight() {return screenHeight;}
-	
-	
+
 	
 }
diff --git a/Version 1.1/NewestVersion/src/gameStates/Ver2GameDriver.java b/Version 1.1/NewestVersion/src/gameStates/Ver2GameDriver.java
index 75aa4a6..66effe9 100644
--- a/Version 1.1/NewestVersion/src/gameStates/Ver2GameDriver.java	
+++ b/Version 1.1/NewestVersion/src/gameStates/Ver2GameDriver.java	
@@ -6,6 +6,8 @@ import java.util.logging.Logger;
 import org.newdawn.slick.AppGameContainer;
 import org.newdawn.slick.SlickException;
 
+import mapRelated.BasicMap;
+
 //Driver Used to run the game
 //Contains Main Method
 public class Ver2GameDriver {	
@@ -14,8 +16,8 @@ public class Ver2GameDriver {
 		
 		//All the code below is how we get this game rolling and running.
 		
-		final int screenWidth = GameWindowSettings.getScreenWidth(); // Set screen width to 35 tiles long (35*32px)
-		final int screenHeight = GameWindowSettings.getScreenHeight(); // Set screen height to 16 tile long (16*32px)
+		final int screenWidth = BasicMap.GameWindowSettings.getScreenWidth(); // Set screen width to 35 tiles long (35*32px)
+		final int screenHeight =BasicMap.GameWindowSettings.getScreenHeight(); // Set screen height to 16 tile long (16*32px)
 		
 			try
 			{
diff --git a/Version 1.1/NewestVersion/src/managers/MonsterManager.java b/Version 1.1/NewestVersion/src/managers/MonsterManager.java
index 084c68a..cf65bd7 100644
--- a/Version 1.1/NewestVersion/src/managers/MonsterManager.java	
+++ b/Version 1.1/NewestVersion/src/managers/MonsterManager.java	
@@ -29,8 +29,8 @@ public class MonsterManager {
 	private int level = 1;
 	private BasicMap currentMap;
 	private String[][] entityArray;
-	private int screenWidth = GameWindowSettings.getScreenWidth();
-	private int screenHeight = GameWindowSettings.getScreenHeight();
+	private int screenWidth = BasicMap.GameWindowSettings.getScreenWidth();
+	private int screenHeight = BasicMap.GameWindowSettings.getScreenHeight();
 	
 	
 	//Monster Type1
diff --git a/Version 1.1/NewestVersion/src/monsterRelated/Entity.java b/Version 1.1/NewestVersion/src/monsterRelated/Entity.java
index 67e5d76..9d00bfc 100644
--- a/Version 1.1/NewestVersion/src/monsterRelated/Entity.java	
+++ b/Version 1.1/NewestVersion/src/monsterRelated/Entity.java	
@@ -23,8 +23,8 @@ public class Entity {
 	//Map entity stands upon currently
 	protected BasicMap map;
 	
-	private final int screenWidth = GameWindowSettings.getScreenWidth();
-	private final int screenHeight = GameWindowSettings.getScreenHeight();
+	private final int screenWidth = BasicMap.GameWindowSettings.getScreenWidth();
+	private final int screenHeight = BasicMap.GameWindowSettings.getScreenHeight();
 	
 	//Location of entity
 	public Entity (int x,int y){
@@ -125,6 +125,7 @@ public class Entity {
 	public int getHealthPoints(){return healthPoints;}
 	public int getMaxHealthPoints() {return maxHealthPoints;}
 	
+	public void setMaxHealthPoints(int healthPoints) { if (healthPoints > 0) {maxHealthPoints = healthPoints;}}
 	
 	
 	
diff --git a/Version 1.1/NewestVersion/src/playerRelated/Player.java b/Version 1.1/NewestVersion/src/playerRelated/Player.java
index ddd8e85..3f216eb 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/Player.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/Player.java	
@@ -24,26 +24,21 @@ public class Player extends Entity{
 	//Used for stair case movement 
 	private boolean onStairs;
 	
-	//Variables used for Combat and related aspects
-	private int experiencePoints = 0;
-	private int pointsNextLevel = 10;
-	
-	private int playerLevel = 1;
-	private int criticalHitLimit= 30;
-	private int missFactor = 10;
-	
 	//Basic Sprite Variables
 	private SpriteSheet sheet;
 	private Animation currentSprite, up, down,left,right;
 
 	//Limited Vision Effect
 	private Image shadow;		
+
+	private PlayerStatus playerStats;
 	
 	////FOR TEST PURPOSES ONLY////
 	public Player (int x, int y){
 		super(x,y);
 		gc = null;
 		name = "P";
+		playerStats = new PlayerStatus(this);
 	}
 	
 	public Player (int x, int y, BasicMap map){
@@ -51,6 +46,7 @@ public class Player extends Entity{
 		this.map = map;
 		gc = null;
 		name = "P";
+		playerStats = new PlayerStatus(this);
 	}
 		
 	public void mockKeyBoard(char c){
@@ -423,36 +419,23 @@ public class Player extends Entity{
 	
 	//Method used when the player levels up
 	private boolean levelUp(){
-		
-		if (experiencePoints >= pointsNextLevel){
-			playerLevel++;
-			
-			//Increase Maximum Health & Heal Up Completely
-			maxHealthPoints += 50;
-			healthPoints = maxHealthPoints;
-			criticalHitLimit += 5;
-			if (missFactor > 5)
-				missFactor -= 1;
-
-			//Decrease Experience Points used up
-			//Increase amount needed to next level
-			experiencePoints = experiencePoints-pointsNextLevel;
-			pointsNextLevel *= 2;
-			return true;
-			}
-		return false;
+		return playerStats. levelUp();
 	}
 
 		
-	public int getCurrentLevel(){return playerLevel;}
+	public int getCurrentLevel(){return playerStats.getPlayerLevel();}
+	
+	public int getExperiencePoints(){return playerStats.getExperiencePoints();}
+	
+	public int getPointsNextLevel() {return playerStats.getPointsNextLevel();}
 	
-	public int getExperiencePoints(){return experiencePoints;}
 	
-	public int getPointsNextLevel() {return pointsNextLevel;}
 ///////////METHODS DEALING WITH COMBAT///////////////////	
 	
 	private void attack(int monsterX, int monsterY){
-	CombatManager.attackLoop(this,criticalHitLimit, missFactor, monsterX, monsterY);	
+		int criticalHitLimit = playerStats.getCriticaHitLimit();
+		int missFactor = playerStats.getMissFactor();
+		CombatManager.attackLoop(this,criticalHitLimit, missFactor, monsterX, monsterY);	
 	}
 	
 	
@@ -464,22 +447,16 @@ public class Player extends Entity{
 
 	///Methods dealing loading////
 	public void loadStats(int newLevel, int newExp, int newHealth)
-		{
-		playerLevel = newLevel;
-		experiencePoints = newExp;
-		pointsNextLevel = 10*(2*(newLevel));
-		maxHealthPoints = 30 + 50*(newLevel-1);
-		healthPoints = newHealth;
-		criticalHitLimit = 30+5*(newLevel-1);	
-		missFactor = 10 - 5*(newLevel-1);
-		}
+	{
+			playerStats = new PlayerStatus(this,newLevel, newExp, newHealth);
+	}
 		
 		
-		public void setPosition(int newX, int newY)
-		{
+	public void setPosition(int newX, int newY)
+	{
 			x = newX;
 			y = newY;
-		}
+	}
 	
 }
 
diff --git a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java
index 28691b3..90b3e8b 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
@@ -2,4 +2,5 @@ package playerRelated;
 
 public class PlayerMovement {
 
+
 }
diff --git a/Version 1.1/NewestVersion/src/playerRelated/PlayerStatus.java b/Version 1.1/NewestVersion/src/playerRelated/PlayerStatus.java
index 89139e2..99b615c 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/PlayerStatus.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/PlayerStatus.java	
@@ -2,4 +2,62 @@ package playerRelated;
 
 public class PlayerStatus {
 
+	
+	//Variables used for Combat and related aspects
+	private int experiencePoints = 0;
+	private int pointsNextLevel = 10;
+	
+	private int playerLevel = 1;
+	private int criticalHitLimit= 30;
+	private int missFactor = 10;
+
+	private Player player;
+		public PlayerStatus(Player p)
+		{
+			player =p;
+		}
+		
+		public PlayerStatus(Player p,int newLevel, int newExp, int newHealth)
+		{
+			playerLevel = newLevel;
+			experiencePoints = newExp;
+			pointsNextLevel = 10*(2*(newLevel));
+			player.setMaxHealthPoints (30 + 50*(newLevel-1));
+			player.addHealthPoints(newHealth-player.getHealthPoints());
+			criticalHitLimit = 30+5*(newLevel-1);	
+			missFactor = 10 - 5*(newLevel-1);
+		}
+	
+    	//Method used when the player levels up
+		public boolean levelUp(){
+			
+			if (experiencePoints >= pointsNextLevel){
+				
+				playerLevel++;
+				
+				//Increase Maximum Health & Heal Up Completely
+				
+				int increaseMaxHealth = player.getMaxHealthPoints() + 50;
+				player.setMaxHealthPoints(increaseMaxHealth);
+				player.addHealthPoints(increaseMaxHealth- player.getHealthPoints());
+				criticalHitLimit += 5;
+				if (missFactor > 5)
+					missFactor -= 1;
+
+				//Decrease Experience Points used up
+				//Increase amount needed to next level
+				experiencePoints = experiencePoints-pointsNextLevel;
+				pointsNextLevel *= 2;
+				return true;
+				}
+			return false;
+		}
+		
+		public int getCriticaHitLimit() {return criticalHitLimit;}
+		public int getMissFactor() {return missFactor;}
+		public int getPlayerLevel() {return playerLevel;}
+
+		public int getExperiencePoints() {return experiencePoints;}
+		public int getPointsNextLevel() {return pointsNextLevel;}
+
 }

commit 5ef9d58fa41f4aeb7430cf1b040b3f1add0a398e
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 21:17:56 2017 -0600

    Created Classes to start shortening Long Class player.java

diff --git a/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java
new file mode 100644
index 0000000..28691b3
--- /dev/null
+++ b/Version 1.1/NewestVersion/src/playerRelated/PlayerMovement.java	
@@ -0,0 +1,5 @@
+package playerRelated;
+
+public class PlayerMovement {
+
+}
diff --git a/Version 1.1/NewestVersion/src/playerRelated/PlayerStatus.java b/Version 1.1/NewestVersion/src/playerRelated/PlayerStatus.java
new file mode 100644
index 0000000..89139e2
--- /dev/null
+++ b/Version 1.1/NewestVersion/src/playerRelated/PlayerStatus.java	
@@ -0,0 +1,5 @@
+package playerRelated;
+
+public class PlayerStatus {
+
+}

commit ccfedf22bea5308a6b81fa4997e12e9f33540943
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 21:11:59 2017 -0600

    Made Game window an inline class of basic map

diff --git a/Version 1.1/NewestVersion/src/mapRelated/BasicMap.java b/Version 1.1/NewestVersion/src/mapRelated/BasicMap.java
index 97214da..aab9af3 100644
--- a/Version 1.1/NewestVersion/src/mapRelated/BasicMap.java	
+++ b/Version 1.1/NewestVersion/src/mapRelated/BasicMap.java	
@@ -10,6 +10,9 @@ import org.newdawn.slick.tiled.TiledMap;
 //Limit: Limited to Tiled Program Loading										//
 //////////////////////////////////////////////////////////////////////////////////
 
+
+
+
 public class BasicMap
 {
 	private TiledMap map;
@@ -19,6 +22,8 @@ public class BasicMap
 	public static final int heightByTiles = 16;
 	public static final int TILESIZE = 32;
 	
+	
+	
 	////////////FOR TESTS ONLY//////////////
 	////////////////////////////////////////
 	public BasicMap(char [][] newArray){
@@ -129,4 +134,15 @@ public class BasicMap
     else
     	return false;
 	}
+
+	public static class GameWindowSettings{
+		private static final int screenWidth = TILESIZE*widthByTiles;
+		private static final int screenHeight = TILESIZE*heightByTiles;
+		
+		public static int getScreenWidth() {return screenWidth;}
+		public static int getScreenHeight() {return screenHeight;}
+		
+		
+	}
+
 }

commit 9215db4dfaff54a8728ddcfb36510c7b1a6a3187
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 21:08:42 2017 -0600

    Refactored GameWindow To derive its information from basicMap

diff --git a/Version 1.1/NewestVersion/src/gameStates/GameWindowSettings.java b/Version 1.1/NewestVersion/src/gameStates/GameWindowSettings.java
index 0d482ea..9be5ea1 100644
--- a/Version 1.1/NewestVersion/src/gameStates/GameWindowSettings.java	
+++ b/Version 1.1/NewestVersion/src/gameStates/GameWindowSettings.java	
@@ -1,11 +1,15 @@
 package gameStates;
 
+import mapRelated.BasicMap;
+
 public class GameWindowSettings {
 
-	private static final int screenWidth =1120;
-	private static final int screenHeight = 512;
+	private static final int screenWidth = BasicMap.TILESIZE*BasicMap.widthByTiles;
+	private static final int screenHeight = BasicMap.TILESIZE*BasicMap.heightByTiles;
 	
 	public static int getScreenWidth() {return screenWidth;}
 	public static int getScreenHeight() {return screenHeight;}
 	
+	
+	
 }

commit 03500d54c53a3d597057ef288d1e418c871b2c26
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 21:03:11 2017 -0600

    Refactored Entity.java screenheight/width

diff --git a/Version 1.1/NewestVersion/src/monsterRelated/Entity.java b/Version 1.1/NewestVersion/src/monsterRelated/Entity.java
index e4e09f0..67e5d76 100644
--- a/Version 1.1/NewestVersion/src/monsterRelated/Entity.java	
+++ b/Version 1.1/NewestVersion/src/monsterRelated/Entity.java	
@@ -171,8 +171,6 @@ public class Entity {
 	}	
 	
 	public void setName(String name){this.name = name;}
-
-
 }
 	
 

commit 5744247f116754398bc8d38b8520994d5462a7ca
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 20:53:38 2017 -0600

    Conflicting code clean up in adjacent project

diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/Game1.class b/VERSION W.I.P/version w.i.p/bin/gameStates/Game1.class
deleted file mode 100644
index 0ddf52c..0000000
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/Game1.class and /dev/null differ
diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonsterTest.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonsterTest.class
deleted file mode 100644
index f4513cd..0000000
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonsterTest.class and /dev/null differ
diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/Entity.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/Entity.class
index ec3e43d..efdb99e 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/Entity.class and b/VERSION W.I.P/version w.i.p/bin/monsterRelated/Entity.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/EntityTest.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/EntityTest.class
deleted file mode 100644
index cfe0fc3..0000000
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/EntityTest.class and /dev/null differ
diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/PrintingTests.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/PrintingTests.class
deleted file mode 100644
index bf13131..0000000
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/PrintingTests.class and /dev/null differ
diff --git a/VERSION W.I.P/version w.i.p/src/gameStates/Game1.java b/VERSION W.I.P/version w.i.p/src/gameStates/Game1.java
deleted file mode 100644
index 9aab808..0000000
--- a/VERSION W.I.P/version w.i.p/src/gameStates/Game1.java	
+++ /dev/null
@@ -1,223 +0,0 @@
-package gameStates;
-
-import inputRelated.ButtonAction;
-import inputRelated.LoadingGame;
-import inputRelated.SlideOutMenu;
-
-import java.util.LinkedList;
-
-import managers.CombatManager;
-import managers.MonsterManager;
-import managers.SoundManager;
-import mapRelated.BasicMap;
-import monsterRelated.Entity;
-
-import org.newdawn.slick.GameContainer;
-import org.newdawn.slick.Graphics;
-import org.newdawn.slick.Image;
-import org.newdawn.slick.Input;
-import org.newdawn.slick.SlickException;
-import org.newdawn.slick.openal.SoundStore;
-import org.newdawn.slick.state.BasicGameState;
-import org.newdawn.slick.state.StateBasedGame;
-
-import playerRelated.Player;
-
-public class Game1 extends BasicGameState {
-
-	//Used for quitting the game
-	private GameContainer gc;
-	private GameScreenAssets gameAssets;
-	
-	//Entity Stuff
-	private Player player;
-	private String[][] entityArray;
-	
-	//Handles Monsters on screen
-	private MonsterManager monsters;
-	
-	private BasicMap currentMap;
-	
-	//Counters for delaying textlog and monsters
-	private int textLogCounter = 0;//Must implement as private//Can possibly renamed Text log speed???
-
-	//Volume
-	private float volume = 1.0f;
-	
-	private LinkedList<BasicMap> totalLevels = new LinkedList<BasicMap>();
-	
-	
-	//State ID
-	public static final int ID = 1;
-
-	private boolean loadedGame = false;
-	
-	//Menu will put into game screen assets later.
-	SlideOutMenu menu;
-	
-	
-	
-	@Override
-	public void init(GameContainer gc, StateBasedGame stateGame) throws SlickException {
-		
-		if (loadedGame)
-			LoadingGame.initLoadingGame();
-		else{
-			
-		
-		//Used for changing game states
-		this.gc = gc;
-		gameAssets = new GameScreenAssets();
-
-        
-        //Draw Menu
-        menu = new SlideOutMenu(gc, stateGame, ID, new Image ("res/interface/menu2.png"), 1065, 50 );
-        menu.add(new ButtonAction(){ 
-    		public void perform(){
-    		//SoundManager.changeSound("res/sound/Play At Your Own Risk.wav");//I warned you. Not even sorry.	
-    		SoundManager.playSoundEffect("res/sound/SFX/Sword Swing.wav");
-    		}
-    		});
-    	
-		//Load ALL  Maps of game
-		//might move to map class???
-		BasicMap floorOne = new BasicMap("res/map/floor1.tmx");
-		BasicMap floorTwo = new BasicMap("res/map/floor2.tmx");
-		BasicMap floorThree = new BasicMap("res/map/floor3.tmx");
-		BasicMap floorFour = new BasicMap("res/map/floor4.tmx");
-		BasicMap floorFive = new BasicMap("res/map/floor5.tmx");
-		BasicMap floorSix = new BasicMap("res/map/floor6.tmx");
-		BasicMap floorSeven = new BasicMap("res/map/floor7.tmx");
-		//Add them to the Linked List, last level first.
-		totalLevels.add(floorSeven);
-		totalLevels.add(floorSix);
-		totalLevels.add(floorFive);
-        totalLevels.add(floorFour);
-		totalLevels.add(floorThree);
-		totalLevels.add(floorTwo);
-		totalLevels.add(floorOne);
-		//Get current map from the end.
-		currentMap = totalLevels.removeLast();
-		
-		
-		//Create player's character 
-		player = new Player(gc, stateGame,currentMap, 4*32, 5*32);
-		
-		//Place player's character onto map
-		initEntityArray();
-		
-		monsters = new MonsterManager(currentMap);
-		monsters.init(entityArray, currentMap);		
-		CombatManager.setMonsterList(monsters.getMonsterList());
-		
-		player.setEntityArray(monsters.getEntityArray());
-		
-		GameScreenAssets.statusUpdate = "Game is Now In Session";
-		}
-	}
-	
-	public void setLoadedGame(boolean value){loadedGame =value;}
-	
-	private void initEntityArray (){
-		String [][] newArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
-		entityArray = newArray;
-		for (int i = 0; i < BasicMap.widthByTiles; i++)
-		{
-			for (int c = 0; c < BasicMap.heightByTiles; c++)
-			{
-				entityArray[i][c] = " ";
-			}
-		}
-		entityArray[((Entity)player).getPosition()[0]/32][((Entity)player).getPosition()[1]/32] = player.getName();
-	}
-	
-	
-	@Override
-	public void render(GameContainer gc, StateBasedGame stateGame, Graphics g)
-			throws SlickException {
-		
-		//Render Map, Monsters, Player, GameScreen Assets
-		currentMap.render();
-		monsters.render(g);
-		player.render(g);
-		gameAssets.render(g, player);
-		menu.render(gc, g);
-		
-	}
-	
-	@Override
-	public void keyReleased (int key,char c){
-	switch (key){
-	case Input.KEY_Q:
-		gc.exit();//Exits game. 	
-		break;
-	case Input.KEY_1:
-		//Source of sound effect: https://www.freesound.org/people/JoelAudio/sounds/77611/
-		SoundManager.playSoundEffect("res/sound/SFX/Sword Swing.wav");
-		break;
-	case Input.KEY_M: 
-	case Input.KEY_ESCAPE:
-
-		//Put slide out menu here
-		
-		break;		
-	//Decrease volume
-	case Input.KEY_A:
-		volume -= 0.1f;
-        if (volume < 0.0f)
-           volume = 0.0f;
-		SoundStore.get().setSoundVolume(volume);
-		SoundStore.get().setMusicVolume(volume);
-		break;
-		
-	//Increase volume
-	case Input.KEY_S:
-		volume += 0.1f;
-        if (volume > 1.0f)
-           volume = 1.0f;
-        SoundStore.get().setSoundVolume(volume);
-        SoundStore.get().setMusicVolume(volume);
-
-		}
-	}
-
-	//Counters used to delay the text log and the movement of monsters
-	private int monsterCounter = 0; //Must combine later
-	
-	
-	@Override
-	public void update(GameContainer gc, StateBasedGame stateGame, int delta)
-			throws SlickException {
-		//Always let the player move.
-		player.update(monsterCounter);
-		
-		textLogCounter = gameAssets.updateTextLog(textLogCounter);
-		
-		//Prevent Monster from fleeing
-		if (CombatManager.battleHappening == false&&monsters.getMonsterList()!= null){
-			monsters.update(player.getPosition(), monsterCounter);
-			monsterCounter++;
-			if (monsterCounter > 400)//Used to delay the monster's movement
-				monsterCounter = 0;
-			}
-		
-		//Load a new floor if the stairs are stepped on.
-		if (player.getOnStairs()&&totalLevels.peekLast()!= null){
-			currentMap = totalLevels.removeLast();
-			player.setMap(currentMap);
-			monsters.clearMonsters();
-			monsters.init(entityArray, currentMap);		
-			CombatManager.setMonsterList(monsters.getMonsterList());
-			player.setEntityArray(monsters.getEntityArray());
-			gameAssets.increaseFloorLevel();
-			SoundManager.changeSound("res/sound/Tank Battle.wav");
-			player.setOnStairs(false);
-		}
-	}
-	
-	@Override
-	public int getID() {
-		return ID;
-	}
-
-}
diff --git a/VERSION W.I.P/version w.i.p/src/gameStates/StateManager.java b/VERSION W.I.P/version w.i.p/src/gameStates/StateManager.java
deleted file mode 100644
index 96ee281..0000000
--- a/VERSION W.I.P/version w.i.p/src/gameStates/StateManager.java	
+++ /dev/null
@@ -1,22 +0,0 @@
-package gameStates;
-
-import org.newdawn.slick.GameContainer;
-import org.newdawn.slick.SlickException;
-import org.newdawn.slick.state.StateBasedGame;
-
-public class StateManager extends StateBasedGame {
-
-		public StateManager(String name) {
-		super(name);
-	}
-
-	@Override
-	public void initStatesList(GameContainer gc) throws SlickException {
-		addState(new Menu());//Very very important. Basically initializes the list of states in this game.
-		addState(new TransitionScreen());
-		addState(new Game());
-		addState(new LoadGame());
-		addState(new GameOver());
-	}
-
-}
diff --git a/VERSION W.I.P/version w.i.p/src/gameStates/TransitionScreen.java b/VERSION W.I.P/version w.i.p/src/gameStates/TransitionScreen.java
deleted file mode 100644
index 2698167..0000000
--- a/VERSION W.I.P/version w.i.p/src/gameStates/TransitionScreen.java	
+++ /dev/null
@@ -1,91 +0,0 @@
-package gameStates;
-
-import org.newdawn.slick.Animation;
-import org.newdawn.slick.Color;
-import org.newdawn.slick.GameContainer;
-import org.newdawn.slick.Graphics;
-import org.newdawn.slick.Image;
-import org.newdawn.slick.Input;
-import org.newdawn.slick.SlickException;
-import org.newdawn.slick.state.BasicGameState;
-import org.newdawn.slick.state.StateBasedGame;
-import org.newdawn.slick.state.transition.FadeInTransition;
-import org.newdawn.slick.state.transition.FadeOutTransition;
-
-public class TransitionScreen extends BasicGameState {
-	public static final int ID = 4;
-	
-	private StateBasedGame sbg;
-	private Image controlImage;
-	private Image explanationImage;
-	private Animation animationIntro;
-	private Image panicImage;
-	private int slide = 0;
-	
-	@Override
-	public void init(GameContainer gc, StateBasedGame sbg)
-			throws SlickException {
-		this.sbg = sbg;
-		Image [] animationImages = {new Image ("res/player/intro1.png"),
-									new Image ("res/player/intro2.png"),
-									new Image ("res/player/intro3.png"),
-									new Image ("res/player/intro4.png"),
-									new Image ("res/player/intro5.png"),
-									new Image ("res/player/intro6.png"),
-									new Image ("res/player/intro7.png"),
-									new Image ("res/player/intro8.png"),
-									new Image ("res/player/intro9.png"),
-									new Image ("res/player/intro10.png"),
-									new Image ("res/player/intro11.png")};
-		int [] duration = {100,100,100,100,100,100,100,100,100,100,100000};
-		animationIntro = new Animation (animationImages, duration, false);
-		controlImage = new Image("res/interface/controls.png"); 
-		panicImage = new Image("res/interface/panicSlide.png");
-		explanationImage = new Image("res/interface/explanation.png");
-	}
-	
-
-	@Override
-	public void render(GameContainer arg0, StateBasedGame sbg, Graphics g)
-			throws SlickException {
-		animationIntro.draw(0,0);
-		if (slide == 1)
-			panicImage.draw(0,0);
-		if (slide == 2)
-			explanationImage.draw(0,0);
-		if (slide ==3)
-			explanationImage.draw(0,0);
-	}
-	
-	@Override
-	public void keyReleased (int key,char c){
-		switch (key){		
-		
-		case Input.KEY_W:
-			
-			break;
-		default:
-			if (slide >=4)
-				sbg.enterState(Game.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));	
-			else 
-				if (slide == 0)
-					slide++;
-				else if (slide == 1)
-					slide = 4;
-		}
-	}
-
-	@Override
-	public void update(GameContainer gc, StateBasedGame sbg, int delta)
-			throws SlickException {
-		animationIntro.update(delta);
-	}
-
-	@Override
-	public int getID() {
-		return ID;
-	}
-
-	
-	
-}
diff --git a/VERSION W.I.P/version w.i.p/src/gameStates/Ver2GameDriver1.java b/VERSION W.I.P/version w.i.p/src/gameStates/Ver2GameDriver1.java
deleted file mode 100644
index 777a726..0000000
--- a/VERSION W.I.P/version w.i.p/src/gameStates/Ver2GameDriver1.java	
+++ /dev/null
@@ -1,33 +0,0 @@
-package gameStates;
-
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import org.newdawn.slick.AppGameContainer;
-import org.newdawn.slick.SlickException;
-
-
-public class Ver2GameDriver {	
-
-	public static void main (String [] args){
-		
-		//All the code below is how we get this game rolling and running.
-		
-		int screenWidth = 1120; // Set screen width to 35 tiles long (35*32px)
-		int screenHeight = 512; // Set screen height to 16 tile long (16*32px)
-			
-			try
-			{
-				AppGameContainer appgc;
-				appgc = new AppGameContainer(new StateManager("Basic Game Template"),screenWidth,screenHeight,false);
-				appgc.start();
-			}
-			catch (SlickException ex)
-			{
-				Logger.getLogger(StateManager.class.getName()).log(Level.SEVERE, null, ex);
-			}
-	
-	}
-
-
-}
diff --git a/VERSION W.I.P/version w.i.p/src/inputRelated/BasicButton.java b/VERSION W.I.P/version w.i.p/src/inputRelated/BasicButton.java
deleted file mode 100644
index dfdc8f7..0000000
--- a/VERSION W.I.P/version w.i.p/src/inputRelated/BasicButton.java	
+++ /dev/null
@@ -1,95 +0,0 @@
-package inputRelated;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.newdawn.slick.Color;
-import org.newdawn.slick.Graphics;
-import org.newdawn.slick.Image;
-import org.newdawn.slick.SlickException;
-import org.newdawn.slick.gui.GUIContext;
-import org.newdawn.slick.gui.MouseOverArea;
-import org.newdawn.slick.state.StateBasedGame;
-
-public class BasicButton extends MouseOverArea {
-
-
-	//Source :https://evilzone.org/java/%28java-fames-tut%29-slick2d-buttons-buttons-buttons/
-	 private boolean activated = false;
-	 private boolean lastMouseOver = false;
-	 private final Image inactiveButton;
-	 private boolean unclickable = false;
-	 private final Image activeButton;
-     private final StateBasedGame sbg;
-     private final int stateID;
-
-     private final List <ButtonAction> actions = new ArrayList <ButtonAction>();
- 	
-     
-     public BasicButton(GUIContext container, int x, int y,
-			StateBasedGame sbg, int stateID, Image inactiveButton, Image activeButton) throws SlickException {
-		 	super(container, inactiveButton, x, y);
-	        super.setMouseDownColor(Color.white);
-	        super.setMouseOverColor(Color.yellow);
-	        super.setMouseOverImage(activeButton);
-	        this.sbg = sbg;
-	        this.stateID = stateID;
-	 
-	        this.inactiveButton = inactiveButton;
-	        this.activeButton = activeButton;
-	}
-	public void add(ButtonAction action){
-		actions.add(action);
-	}
-	
-	public void setUnClickable(boolean unclickable){
-			this.unclickable = unclickable;
-	}
-	
-	 @Override
-	    public void mouseMoved(int oldx, int oldy, int newx, int newy) {
-	        if (sbg.getCurrentStateID() == stateID) {
-	            if (isMouseOver() && !lastMouseOver && !isActivated()) {
-	                lastMouseOver = true;
-	            } else if (!isMouseOver()) {
-	                lastMouseOver = false;
-	            }
-	        }
-	        super.mouseMoved(oldx, oldy, newx, newy);
-	    }
-	 
-	    @Override
-	    public void render(GUIContext guic, Graphics g) {
-	        if (activated&&!unclickable) {
-	            g.drawImage(activeButton, getX(), getY());
-	        } else {
-	            g.drawImage(inactiveButton, getX(), getY());
-	            super.render(guic, g);
-	        }
-	    }
-	 
-	    public boolean isActivated() {
-	        return activated;
-	    }
-	 
-	    protected void setActivated(boolean b) {
-	        activated = b;
-	    }
-	    
-	
-	    @Override
-	    public void mousePressed(int button, int x, int y) {
-	        if (isMouseOver() && sbg.getCurrentStateID() == stateID) {
-	            activated = !activated;
-	            for (ButtonAction action: actions){
-	            	action.perform();
-	            }
-	        }
-	        super.mousePressed(button, x, y);
-	    }
-	    public List <ButtonAction>getActions(){return actions;}
-	 
-}
-	
-	
-
diff --git a/VERSION W.I.P/version w.i.p/src/inputRelated/LoadingGame.java b/VERSION W.I.P/version w.i.p/src/inputRelated/LoadingGame.java
deleted file mode 100644
index b331bc2..0000000
--- a/VERSION W.I.P/version w.i.p/src/inputRelated/LoadingGame.java	
+++ /dev/null
@@ -1,18 +0,0 @@
-package inputRelated;
-
-public class LoadingGame {
-	
-	
-	public LoadingGame(String filename){
-		//Read first 
-		
-		
-		
-		
-	}
-	
-	public static void initLoadingGame(){
-		
-	}
-
-}
diff --git a/VERSION W.I.P/version w.i.p/src/inputRelated/MainMenuButtons.java b/VERSION W.I.P/version w.i.p/src/inputRelated/MainMenuButtons.java
deleted file mode 100644
index d5cae3a..0000000
--- a/VERSION W.I.P/version w.i.p/src/inputRelated/MainMenuButtons.java	
+++ /dev/null
@@ -1,87 +0,0 @@
-package inputRelated;
-
-import gameStates.LoadGame;
-import gameStates.Menu;
-import gameStates.TransitionScreen;
-
-
-import managers.SoundManager;
-
-import org.newdawn.slick.Color;
-import org.newdawn.slick.GameContainer;
-import org.newdawn.slick.Graphics;
-import org.newdawn.slick.Image;
-import org.newdawn.slick.SlickException;
-import org.newdawn.slick.state.StateBasedGame;
-import org.newdawn.slick.state.transition.FadeInTransition;
-import org.newdawn.slick.state.transition.FadeOutTransition;
-
-public class MainMenuButtons {
-	
-	//Button Variables
-	private BasicButton loadGameButton;
-	private BasicButton newGameButton;
-	
-	
-	//Used to for the actions of the buttons
-	private StateBasedGame sbg;
-	private boolean savedGameExists = false;
-	
-	public MainMenuButtons (GameContainer gc, StateBasedGame stateGame) throws SlickException{
-	
-	sbg = stateGame;
-	
-
-	//Get the images of the buttons in their inactive/active states
-	Image inactiveNewGame = new Image("res/interface/newGame.png");
-	Image activeNewGame = new Image("res/interface/newGameMouseOver.png");
-	Image inactiveLoad = new Image ("res/interface/continueInActive.png");
-	Image activeLoad = new Image("res/interface/continueActive.png");
-	
-	
-	newGameButton = new BasicButton(gc, 390, 350, 
-									    stateGame, Menu.ID, inactiveNewGame, activeNewGame);
-	loadGameButton = new BasicButton(gc, 590, 350, 
-										stateGame, Menu.ID, inactiveLoad, activeLoad);
-	
-	newGameButton.setMouseDownImage(activeNewGame);
-	newGameButton.setMouseOverImage(activeNewGame);
-	
-	if (!savedGameExists){//Given that a saved game does not exist deactivate this button
-		loadGameButton.setUnClickable(true);	
-		loadGameButton.setMouseOverImage(inactiveLoad);
-		loadGameButton.setMouseOverColor(Color.white);
-		}
-	
-	//Creates an anon class for the button's action.
-	newGameButton.add(new ButtonAction(){ 
-		public void perform(){
-		sbg.enterState(TransitionScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));	
-	//	SoundManager.changeSound("res/sound/Play At Your Own Risk.wav");//I warned you. Not even sorry.
-		SoundManager.changeSound("res/sound/Catacombs.wav");
-		}
-		});
-	
-	
-	//Creates an anon class for the button's action.
-	loadGameButton.add(new ButtonAction(){ 
-		public void perform(){
-		if (savedGameExists)
-			sbg.enterState(LoadGame.ID, new FadeOutTransition(Color.white), new FadeInTransition(Color.white) );	
-		}
-		});
-	}
-	
-	public void setLoadGameState(boolean savedGameExists){
-	//TO WORK ON METHOD: This is used to activate the load game button.	
-	//And associated actions
-	}
-	
-	
-	public void render(GameContainer gc, Graphics g){
-		 newGameButton.render(gc, g);//Draw the buttons on screen.
-		 loadGameButton.render(gc,g);
-	}
-	
-	
-}
diff --git a/VERSION W.I.P/version w.i.p/src/inputRelated/SavingGame.java b/VERSION W.I.P/version w.i.p/src/inputRelated/SavingGame.java
deleted file mode 100644
index 89751ec..0000000
--- a/VERSION W.I.P/version w.i.p/src/inputRelated/SavingGame.java	
+++ /dev/null
@@ -1,37 +0,0 @@
-package inputRelated;
-
-import java.util.LinkedList;
-
-import monsterRelated.BasicMonster;
-import playerRelated.Player;
-
-public class SavingGame {
-	
-	BasicMonster [] monsters;
-	
-	
-	public SavingGame(LinkedList <BasicMonster> monsterList, Player player, int floorLevel){
-		//Spawn Monsters in the same location they originally were.
-		//So save their positions. Their health too.
-		//Line will read monsterType, X, Y, health
-		//Get Player position, exp points, health-points. 
-		//Save floor level.
-	}
-	
-	
-	
-	public static void SaveGame(){
-		//First Write Floor number. Newline.
-		//Player position. new line
-		//Player exp points. new line
-		//Player health points. new line.
-		//Write === to signify stop and to read new data
-		//Write monster type
-		//Write monster x-coordinate
-		//Write monster y-coordinate
-		//Write monster health.
-		//Repeat process until linked list is empty.
-		//Write another *** to stop reading.
-	}
-
-}
diff --git a/VERSION W.I.P/version w.i.p/src/inputRelated/SlideOutMenu.java b/VERSION W.I.P/version w.i.p/src/inputRelated/SlideOutMenu.java
deleted file mode 100644
index a17ddff..0000000
--- a/VERSION W.I.P/version w.i.p/src/inputRelated/SlideOutMenu.java	
+++ /dev/null
@@ -1,79 +0,0 @@
-package inputRelated;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.newdawn.slick.Color;
-import org.newdawn.slick.GameContainer;
-import org.newdawn.slick.Graphics;
-import org.newdawn.slick.Image;
-import org.newdawn.slick.SlickException;
-import org.newdawn.slick.gui.GUIContext;
-import org.newdawn.slick.gui.MouseOverArea;
-import org.newdawn.slick.state.StateBasedGame;
-
-public class SlideOutMenu extends MouseOverArea{
-
-	
-	private StateBasedGame sbg;
-	private GUIContext gc;
-	private final List <ButtonAction> actions = new ArrayList <ButtonAction>();
- 	private boolean activated = false;
-	private int stateID;
-	private boolean menuOpen = false;
-//	private BasicButton returnButton;
-	private BasicButton exitGameButton;
- 	
-	public SlideOutMenu(GUIContext container,StateBasedGame game, int stateID,  Image image, int x, int y) throws SlickException {
-		super(container, image, x, y);
-		sbg = game;
-		gc = container;
-		this.stateID = stateID;
-	    super.setMouseOverColor(Color.yellow);
-	    exitGameButton = new BasicButton(container, 1140, y+315, game, 
-	    		stateID, new Image ("res/interface/exitGame.png"), new Image ("res/interface/exitGameMouseOver.png"));
-	  	 
-		exitGameButton.add(new ButtonAction(){
-			public void perform(){
-				((GameContainer)gc).exit();	
-			}	
-		});
-
-	}
-
-	   public void render(GameContainer gc, Graphics g) {
-	          super.render(gc, g);
-	          exitGameButton.render(gc,g);
-	   }
-	
-	
-	   public boolean isActivated() {
-	        return activated;
-	    }
-	 
-	public void add(ButtonAction action){
-		actions.add(action);
-	}
-	
-	@Override
-    public void mousePressed(int button, int x, int y) {
-		if (isMouseOver() && sbg.getCurrentStateID() == stateID) {
-            activated = !activated;
-            System.out.println("Test");
-            if (menuOpen == false){
-            	setX(300);
-            	exitGameButton.setX(610);
-            	menuOpen = true;
-            }
-            else{
-            	setX(1065);
-            	exitGameButton.setX(1150);
-            	menuOpen = false;
-            }
-        super.mousePressed(button, x, y);
-       }
-    }
-    
-	public void setMenuOpenTrue(){menuOpen = true;}
-	
-}
diff --git a/VERSION W.I.P/version w.i.p/src/managers/CombatManager.java b/VERSION W.I.P/version w.i.p/src/managers/CombatManager.java
deleted file mode 100644
index ac21c69..0000000
--- a/VERSION W.I.P/version w.i.p/src/managers/CombatManager.java	
+++ /dev/null
@@ -1,134 +0,0 @@
-/////////////////////////////////////////////////////////////
-//Combat  Manager                                          //
-//Purpose: Deal with the combat inside the game		       //
-//Limit: Monsters will only attack if players attack       // 
-//Monsters will freeze movement if one monster is being    //
-//attacked.  											   //
-//Features: Sends messages about the combat to text log	   //
-//Group: SENG 301 Group 16			            		   //
-/////////////////////////////////////////////////////////////
-
-package managers;
-
-import gameStates.GameScreenAssets;
-
-import java.util.LinkedList;
-import java.util.Random;
-
-import monsterRelated.BasicMonster;
-import monsterRelated.Entity;
-import playerRelated.Player;
-
-public class CombatManager {
-	
-	public static boolean battleHappening = false;
-	private Player player;//Will use later for when the monster moves on its own.
-	private static LinkedList <BasicMonster> monsterList = new LinkedList<BasicMonster>();
-	
-	public void setPlayerRef (Player player){this.player = player;}
-	public static void setMonsterList(LinkedList <BasicMonster> monsters){monsterList = monsters;}
-	
-	
-	public static String attackLoop(Player player, int criticalHitLimit, int missFactor, int monsterX, int monsterY ){
-		battleHappening = true;
-		if (getMonsterRef(monsterX, monsterY) == null)
-		{
-			GameScreenAssets.statusUpdate = "You are attacking a ghost! Oh no! Run away before it gets you!";
-			battleHappening = false;
-			return "Error! No Monster Found to Fight";
-		}
-		else
-		{
-			BasicMonster currentFoe = getMonsterRef(monsterX,monsterY);
-		//	while (currentFoe.search("P")&&currentFoe.getAlive()&&player.getAlive()){
-				actualCombat(currentFoe, player, criticalHitLimit, missFactor);
-				//delay();
-			//}
-					
-		}
-		return null;
-	}
-	
-	
-	//Add delay
-	private static void delay(){for (double i = 0; i < 10000000; i++);}
-	
-	
-	private static void actualCombat(BasicMonster currentFoe, Player player, int criticalHitLimit, int missFactor){
-		int attack = generateAttack(criticalHitLimit);
-		if (attack <= missFactor){
-			GameScreenAssets.queueTextLog.addFirst("You missed!");
-			//delay();
-			attack = generateAttack(currentFoe.damageLimit);
-			player.subtractHealth(attack);	
-			GameScreenAssets.queueTextLog.addFirst("Monster attacks back! Damage Done: "+attack);
-			}
-		
-		else if (attack > missFactor && attack <= criticalHitLimit-missFactor)
-		{
-		
-		GameScreenAssets.queueTextLog.addFirst("Average Hit: "+attack); 
-		currentFoe.subtractHealth(attack);
-			if (currentFoe.getHealthPoints() <= 0)
-			{
-
-				GameScreenAssets.queueTextLog.addFirst("You've Killed the monster!");
-				player.addExperiencePoints(currentFoe.getExpPointGain());
-				battleHappening = false;
-				monsterList.remove(currentFoe);
-				//delay();
-				return;
-			}
-			//delay();
-			attack = generateAttack(currentFoe.damageLimit);
-			player.subtractHealth(attack);	
-			GameScreenAssets.queueTextLog.addFirst("Monster attacks back! Damage Done: "+attack);
-			//delay();
-		}
-		
-		else 
-		{
-		currentFoe.subtractHealth(attack);	
-		GameScreenAssets.queueTextLog.addFirst("Critical Hit: "+attack);
-			if (currentFoe.getHealthPoints() <= 0)
-			{
-				GameScreenAssets.queueTextLog.addFirst("You've Killed the monster!");
-				player.addExperiencePoints(currentFoe.getExpPointGain());
-				battleHappening = false;
-				monsterList.remove(currentFoe);
-			//	delay();
-				return;
-			}
-		//	delay();
-			attack = generateAttack(currentFoe.damageLimit);
-			player.subtractHealth(attack);	
-			GameScreenAssets.queueTextLog.addFirst("Monster attacks back! Damage Done: "+attack);
-	//		delay();
-		}
-	}
-	
-	
-	private static int generateAttack(int criticalHitLimit){
-		Random gen = new Random();
-		int attack = gen.nextInt(criticalHitLimit);
-		return attack;
-	}
-	
-	
-	
-	private static BasicMonster getMonsterRef(int x, int y){
-		BasicMonster monsterFound = null;
-		int [] monsterPosition = new int [2];
-		for (int i = 0; i < monsterList.size(); i++)
-			{
-			monsterPosition = monsterList.get(i).getPosition();
-			if (monsterPosition[0] == x && monsterPosition[1] == y)
-				{
-				monsterFound = monsterList.get(i);
-				}
-			}
-		return monsterFound;
-	}
-	
-
-}
diff --git a/VERSION W.I.P/version w.i.p/src/managers/MonsterManager.java b/VERSION W.I.P/version w.i.p/src/managers/MonsterManager.java
deleted file mode 100644
index a44fac3..0000000
--- a/VERSION W.I.P/version w.i.p/src/managers/MonsterManager.java	
+++ /dev/null
@@ -1,311 +0,0 @@
-/////////////////////////////////////////////////////////////
-//Monster Manager                                          //
-//Purpose: Manage Multiple Monsters in a level		       //
-//Limit: Clunky in spawning its monsters. Currently only   // 
-//handles one type of monster.                             //
-//Features: Randomly spawns three monsters per level. 	   //
-//Group: SENG 301 Group 16			            		   //
-/////////////////////////////////////////////////////////////
-
-
-
-package managers;
-
-import java.util.LinkedList;
-import java.util.Random;
-
-import mapRelated.BasicMap;
-import monsterRelated.BasicMonster;
-
-import org.newdawn.slick.Animation;
-import org.newdawn.slick.Graphics;
-import org.newdawn.slick.Image;
-import org.newdawn.slick.SlickException;
-import org.newdawn.slick.SpriteSheet;
-
-import playerRelated.Player;
-
-public class MonsterManager {
-
-	
-	private Player player;
-	private LinkedList<BasicMonster> monsterList = new LinkedList<BasicMonster>();
-	private int level;
-	private BasicMap currentMap;
-	private String[][] entityArray;
-	
-	
-	//Monster Type1
-	//Might Rename as "Soldiers" or "Guards"
-	//Because they will march between two points like guards on patrol.
-	private Image basicMonsterImage;
-	private SpriteSheet basicMonsterSheet;
-	private Animation basicMonsterAnimation;
-	
-	//Monster Type2
-	//Will name wanderers
-	//Since they will freely wander the entire screen
-	private Image wanderImage;
-	private Image wanderImage2;
-	
-	//Monster Type3
-	//Will name hives
-	//Since they will think collectively and 'swarm' the player
-	private Image hiveImage;
-	
-	
-	//For test purposes Only
-	public MonsterManager(){
-		
-	}
-	//For test purposes only
-	
-	public MonsterManager(BasicMap map){
-		currentMap = map;
-	}
-	
-	
-	public String checkEntityArray(String [][] entityArray){
-		if (entityArray.length*entityArray[0].length != 35*16)
-			return "Entity Array Not Expected Size";
-		
-		for (String[] row: entityArray){
-			for (String s:row)
-			{
-				if (s == null)
-					return "EntityArray cannot have null objects";
-			}
-		}
-		
-		boolean playerFound = false;
-		for(String[] row:entityArray)
-		{
-			for (String s: row)
-			{
-				if (s.equals("P"))
-					playerFound = true;
-			}
-		}
-		
-		if (!playerFound)
-			return "Player not in EntityArray"; 
-		
-		return null;
-	}
-	
-	
-	public String setEntityArray(String [][]entityArray){
-		if ( checkEntityArray(entityArray) != null)
-		{
-			return "Invalid Entity Array";
-		}
-		this.entityArray = entityArray;
-		return null;
-	}
-	
-	//To do later: Put this into a private object and change this method to a private method.
-	//OLD CODE BELOW THIS CODE + NOTES.
-	public int[] findValidPlacement(int monsterPathSize, BasicMap map, String [][] array){
-		Random gen = new Random();
-		int newX = gen.nextInt(34)*BasicMap.TILESIZE;
-		int newY = gen.nextInt(15)*BasicMap.TILESIZE;
-		int[]  newPosition = {newX, newY};
-		
-		for (int i = 0; i < BasicMap.widthByTiles; i ++){
-			for (int c = 0; c < BasicMap.heightByTiles; c++){
-				if (checkValidPlacement(newPosition, monsterPathSize, map, array) == null){
-					return newPosition;
-					}
-				newPosition[0] = (newX+i*BasicMap.TILESIZE)%(1120-32);
-				newPosition[1] = (newY+c*BasicMap.TILESIZE)%(512-32);
-				}
-
-			}
-		return null;
-	}
-	
-
-	///////IMPORTANT!! PLEASE READ!!!/////////////////
-	////This is what the code was before I did some refactoring. It should pass TestOneSpot EntityArray only test
-	///And it should pass the the test find placement one spot left map array only
-	
-	//Reasons for changing: Monsters ended up spawning to one side of the screen biasedly
-	//Predictable non-changing spawning.
-	
-	//Helpful tips: If you want to comment back in/ comment out quickly. Highly the piece of code. Ctrl+shift+c.
-	//Ctrl + D : Deletes current line of code.
-	
-	
-//	public int[] OLDfindValidPlacement(int monsterPathSize, BasicMap map, String [][] array){
-//		int newX = 0;
-//		int newY = 0;
-//		int[]  newPosition = {newX, newY};
-//		
-//		for (int i = 0; i < BasicMap.widthByTiles; i ++){
-//			for (int c = 0; c < BasicMap.heightByTiles; c++){
-//				if (checkValidPlacement(newPosition, monsterPathSize, map, array) == null){
-//					return newPosition;
-//					}
-//				newPosition[0] = i*BasicMap.TILESIZE;
-//				newPosition[1] = c*BasicMap.TILESIZE;
-//				}
-//
-//			}
-//		return null;
-//	}
-	
-	
-	public String checkValidPlacement(int[]newPosition, int monsterPathSize, BasicMap map, String [][] array){
-		Boolean allClear = true;
-		int checkX = newPosition[0];
-		int checkY = newPosition[1];
-		for (int i = 0;i < monsterPathSize; i++)
-		{
-			if (checkX >= 1120 || checkY >= 512)
-				return "Out of Bounds";
-			if (array[checkX/BasicMap.TILESIZE][checkY/BasicMap.TILESIZE] != " "){
-				allClear = false;
-				return "Entity Overlap";
-				}
-			if (map.hasCollision(checkX, checkY))
-				{
-				allClear = false;
-				return "Map Overlap";
-				}
-			
-			checkX += BasicMap.TILESIZE;
-		}
-
-		if (allClear){
-			return null;
-		}
-		else{
-			return "Invalid Spot";
-		}
-
-	}
-	
-	
-	
-	private void loadMonsterTypes() throws SlickException{
-		basicMonsterSheet= new SpriteSheet("res/monster/dummySheet.png",32,32); 
-		basicMonsterImage = basicMonsterSheet.getSubImage(0, 0);
-	}
-	
-	
-	public void init(String [][] entityArray, BasicMap currentMap) throws SlickException{
-		if (checkEntityArray(entityArray) !=null)
-			return;
-		this.entityArray = entityArray;
-		loadMonsterTypes();
-
-		BasicMonster monster1 = null;
-		
-		//Fixes needed for below after the tests are done
-		//You'll notice that below there is a lot of repeated code.
-		//Goal: Get rid of the repeated code. Automate it in a for Loop perhaps? <---suggestion only. 
-		//With an integer that relates with the map level.
-		
-		
-		int[] spawnPosition = findValidPlacement (4, currentMap, entityArray);
-		while (spawnPosition == null)
-			spawnPosition = findValidPlacement (4, currentMap, entityArray);
-		
-		monster1 = new BasicMonster(currentMap,basicMonsterImage, spawnPosition[0], spawnPosition[1]);
-		monsterList.add(monster1);
-		monster1.setPath(spawnPosition[0], spawnPosition[0]+3*BasicMap.TILESIZE);
-		entityArray[monster1.getPosition()[0]/BasicMap.TILESIZE]
-				   [monster1.getPosition()[1]/BasicMap.TILESIZE] = monster1.getName();
-		
-		spawnPosition = findValidPlacement (4, currentMap, entityArray);
-		while (spawnPosition == null)
-			spawnPosition = findValidPlacement (4, currentMap, entityArray);
-		
-		
-		monster1 = new BasicMonster(currentMap,basicMonsterImage, spawnPosition[0], spawnPosition[1]);
-		monsterList.add(monster1);
-		entityArray[monster1.getPosition()[0]/BasicMap.TILESIZE]
-				   [monster1.getPosition()[1]/BasicMap.TILESIZE] = monster1.getName();
-			monster1.setPath(spawnPosition[0], spawnPosition[0]+3*BasicMap.TILESIZE);
-		
-		spawnPosition = findValidPlacement (4, currentMap, entityArray);
-		while (spawnPosition == null)
-			spawnPosition = findValidPlacement (4, currentMap, entityArray);
-		
-		monster1 = new BasicMonster(currentMap, basicMonsterImage, spawnPosition[0], spawnPosition[1]);
-		monsterList.add(monster1);
-		entityArray[monster1.getPosition()[0]/BasicMap.TILESIZE]
-				   [monster1.getPosition()[1]/BasicMap.TILESIZE] = monster1.getName();
-		monster1.setPath(spawnPosition[0], spawnPosition[0]+3*BasicMap.TILESIZE);
-		
-	
-		BasicMonster [] monsters = monsterList.toArray(new BasicMonster [monsterList.size()]);
-		for (BasicMonster m: monsters){
-			m.setEntityArray(entityArray);
-			}
-		setMap(currentMap);
-	}
-	
-	//Calls render method for every monster inside the list.
-	public void render(Graphics g) throws SlickException{
-		
-		BasicMonster [] monsters = monsterList.toArray(new BasicMonster [monsterList.size()]);
-		for (BasicMonster m: monsters){
-			m.render(g);
-			}
-		
-	}
-	
-	//Calls update method for every monster inside list
-	public void update(int[] playerPosition, int counter){
-
-		BasicMonster [] monsters = monsterList.toArray(new BasicMonster [monsterList.size()]);
-		for (BasicMonster m: monsters){
-			m.update(playerPosition, counter);
-			}
-	}
-	
-	
-	//Returns the entityArray with the monsters placed on them
-	public String [][] getEntityArray(){return entityArray;}	
-		
-	//Returns the linked list of monsters
-	public LinkedList<BasicMonster> getMonsterList() {return monsterList;}
-	
-	
-	//May or may not be needed. Depending.
-	//////Method to change level and change the amount of monsters.
-	public void setLevel(int currentLevel, BasicMap map){
-		//Current level = #ofmonsters*(level/2)
-	}
-	
-	//Calls the setMap function for all the monsters inside the list
-	public void setMap(BasicMap newMap){
-
-		BasicMonster [] monsters = monsterList.toArray(new BasicMonster [monsterList.size()]);
-		for (BasicMonster m: monsters){
-			m.setMap(newMap);
-			}
-		
-	}
-	
-	//Clears the monsters for the next Level
-	public String clearMonsters(){
-		for (int i = 0; i < BasicMap.widthByTiles; i++){
-			for (int c = 0; c <BasicMap.heightByTiles; c ++){
-				if (entityArray[i][c] != "P")
-					entityArray[i][c] = " ";
-			}
-		}
-		if (checkEntityArray (entityArray) != null){
-			return "Error! You accidentally cleared the player";//"Technically this checks if you've created an array
-		}														//Of proper size, no nulls AND a player inside it.
-		while (!monsterList.isEmpty()) {
-	        monsterList.removeFirst();//Just removes all monsters.
-	    }
-		return null;
-	}
-	
-	
-	
-}
diff --git a/VERSION W.I.P/version w.i.p/src/managers/SoundManager.java b/VERSION W.I.P/version w.i.p/src/managers/SoundManager.java
deleted file mode 100644
index 56c4264..0000000
--- a/VERSION W.I.P/version w.i.p/src/managers/SoundManager.java	
+++ /dev/null
@@ -1,60 +0,0 @@
-package managers;
-	import java.io.IOException;
-
-import org.newdawn.slick.openal.Audio;
-import org.newdawn.slick.openal.AudioLoader;
-import org.newdawn.slick.openal.SoundStore;
-import org.newdawn.slick.util.ResourceLoader;
-
-public class SoundManager {
-	 
-		/** The wav sound effect */
-		private static Audio wavEffect;
-	    public SoundManager(String filename) {
-	 
-	        try {
-	 
-		    //load Wav sound
-		    wavEffect = AudioLoader.getAudio("WAV", ResourceLoader.getResourceAsStream(filename));
-			wavEffect.playAsMusic(1.0f,1.0f, true);  
-	        } catch (IOException e) {
-		    e.printStackTrace();
-		}
-	    	SoundStore.get().poll(0);
-			
-	    }
-	 
-		public void update() {
-			wavEffect.playAsMusic(1.0f,1.0f, true);  
-			SoundStore.get().poll(0);
-		}
-		
-		public static void changeSound (String filename){
-			try{
-			wavEffect = AudioLoader.getAudio("WAV", ResourceLoader.getResourceAsStream(filename));
-			wavEffect.playAsMusic(1.0f,1.0f, true);  
-			}
-			catch (IOException e){
-				e.printStackTrace();
-			}
-		}
-		
-		public static void playSoundEffect(String filename){
-			try{
-				wavEffect = AudioLoader.getAudio("WAV", ResourceLoader.getResourceAsStream(filename));
-				wavEffect.playAsSoundEffect(1.0f,1.0f, false);  	
-			}
-			catch (IOException e){
-				e.printStackTrace();
-			}
-
-		}
-	 
-		
-		public static void lowerVolume (){
-			
-			
-		}
-		
-}
-
diff --git a/VERSION W.I.P/version w.i.p/src/monsterRelated/BasicMonster.java b/VERSION W.I.P/version w.i.p/src/monsterRelated/BasicMonster.java
deleted file mode 100644
index 052afc0..0000000
--- a/VERSION W.I.P/version w.i.p/src/monsterRelated/BasicMonster.java	
+++ /dev/null
@@ -1,240 +0,0 @@
-package monsterRelated;
-
-
-import java.util.Random;
-
-import mapRelated.BasicMap;
-
-import org.newdawn.slick.Animation;
-import org.newdawn.slick.Graphics;
-import org.newdawn.slick.Image;
-import org.newdawn.slick.SlickException;
-import org.newdawn.slick.SpriteSheet;
-
-
-public class BasicMonster extends Entity{
-
-	protected boolean isActiveState = false;
-	protected Image monsterImage;
-	protected Animation monsterAnimation;
-	protected double monsterSightRange;
-	protected char direction;
-	public int damageLimit = 20;//This can be overridden by its children later. Just watch for it.
-	private BasicMap map;
-	private int pathStart = 7*BasicMap.TILESIZE, pathEnd = 9*BasicMap.TILESIZE;
-	
-	
-	private int counter;
-	
-
-	///////////////////////////////////
-	//////////For TEST ONLY////////////
-	public BasicMonster(BasicMap map, int x, int y, int counter){
-		super(x,y);
-		this.counter = counter;
-		this.map = map;
-		name = "M";
-		monsterSightRange = 2;
-		counter = 0;
-		direction = 'R';
-		maxHealthPoints = 1000;
-		healthPoints = maxHealthPoints;
-		}
-
-	//////////For TEST ONLY////////////
-	///////////////////////////////////
-	
-	
-	
-	
-
-	
-	
-	public BasicMonster(BasicMap currentMap, Animation monsterLook,int x, int y) throws SlickException
-	{
-		super(x,y);
-		map = currentMap;
-		name = "M";
-		monsterSightRange = 2;
-		SpriteSheet basicMonsterSheet= new SpriteSheet("res/monster/dummySheet.png",32,32); 
-		monsterImage = basicMonsterSheet.getSubImage(0, 0);
-		monsterAnimation = monsterLook;
-		monsterAnimation.setAutoUpdate(true);
-		counter = 0;
-		direction = 'R';
-		maxHealthPoints = 10;
-		healthPoints = maxHealthPoints;
-	}
-
-	public BasicMonster(BasicMap currentMap, Image monsterLook,int x, int y)
-	{
-		super(x,y);
-		map = currentMap;
-		name = "M";
-		monsterSightRange = 2;
-		monsterImage = monsterLook;
-		counter = 0;
-		direction = 'R';
-		maxHealthPoints = 10;
-		healthPoints = maxHealthPoints;
-	}
-
-	///////Methods dealing with the state of the monster///////
-	public boolean getMonsterState(){return isActiveState;}
-	
-	
-	public void setMonsterState(boolean foundPlayer){
-		isActiveState = foundPlayer;
-	}
-	
-	public void actDead() throws SlickException{
-		monsterImage = new Image ("res/monster/dead.png");
-	}
-	
-	
-	public int getExpPointGain() {return maxHealthPoints/2;}
-	
-	
-	
-	public void render(Graphics g) throws SlickException{
-		if (!alive)
-			actDead();
-		g.drawImage(monsterImage, (int)x, (int)y);
-	//	monsterAnimation.draw((int)x, (int)y);
-	}
-	
-	
-	public String update(int [] playerPosition, int counter)
-	{
-		this.counter = counter;
-		oldx = x;
-		oldy = y;
-		
-		//Check for Overlap
-		if (entityArray[playerPosition[0]/32][playerPosition[1]/32] == " " ||
-			entityArray[playerPosition[0]/32][playerPosition[1]/32] == "M"){
-			return "Player has disappeared from the map.";}
-
-		
-		isActiveState = search("P");
-		if (isActiveState){
-			//This is supposed to use a more intelligent wander.
-//			x = findClosestSpot(getPosition(), playerPosition)[0];
-//			y = findClosestSpot(getPosition(),playerPosition)[1];
-			wander(playerPosition);
-//			Game.queueTextLog.addFirst ("Monster has spotted you!");
-		}
-		else{
-			wander(playerPosition);
-		}
-		
-		return null;
-	}
-		
-////////////////////////////////////////////////	
-	///More advanced version of search not properly implmented or used
-//	private boolean monsterSees(int[] playerPosition){
-//		double distance = Math.sqrt((double)( (playerPosition[0]- x)^2+(playerPosition[1]-y)^2));
-//		if (distance < monsterSightRange)
-//			return true;
-//		else
-//			return false;
-//	}
-//	
-	
-	////////////////////////////////////////////
-	/////////////Movement Methods///////////////
-	////////////////////////////////////////////
-	
-	public void setPath (int start, int end){
-		pathStart = start;
-		pathEnd = end;}
-	
-	
-	private void wander(int [] playerPosition){
-	if (!alive)
-		return;
-	
-	int newX1 = x+BasicMap.TILESIZE;
-	int newX2 = x-BasicMap.TILESIZE;	
-	if ((newX2>= 0 || newX1<=1048)&&counter >= 400){
-		//Change Direction
-		if (x > pathEnd)
-			direction = 'L';
-
-		//move rightwards	
-		if (direction == 'R'&&x <= pathEnd&&!isTaken(newX1,y)){
-			if (map.hasCollision(newX1, y))
-			{
-				direction = 'L';
-				return;
-			}
-			updatePosition(newX1,y);
-			x = newX1;
-			
-			}
-		//move leftwards
-		else if (direction == 'L' && x >= pathStart&&!isTaken(newX2,y)){
-				if (map.hasCollision(newX2, y))
-				{
-					direction = 'R';
-					return;
-				}
-				updatePosition(newX2,y);
-				x = newX2;
-				//Change Direction
-				if (x  < pathStart){
-					direction = 'R';
-				}
-		}
-			
-		counter = 0;
-	}
-	else
-		counter++;
-	}
-	
-	
-/////////////////////////////////////////////////////////////////////////
-//////////////////////// To Be Implemented //////////////////////////////	
-/////////////////////////////////////////////////////////////////////////
-	
-	////Used for a more intelligent wander
-	////Will most likely be adapted for following fleeing players.
-	public int[] findClosestSpot(int[]current, int[] player)
-	{	
-		oldx = x;
-		oldy = y;
-		Random gen = new Random();
-		int newY = gen.nextInt(y+32-(y-1))+y-32;
-		int newX = gen.nextInt(x+32-(x-1))+x-32;
-		if (current[0] == player[0]&& current[1]!= player[1]){
-			if(!isTaken(x, newY))
-			{	
-				newX = x;
-			}
-		}
-			
-		else if (current[1] == player[1]&& current[0] != player[0])
-		{
-			while(!isTaken(newX, y))
-			{
-				newY = y;
-				newX = gen.nextInt(x+1-(x-1))+x-1;			}
-		}
-		
-		else if (current[1]!= player[1]&& current[0]!= player[0])
-		{
-			while(!isTaken(x, newY))
-			{	
-				newX = gen.nextInt(x+32-(x-32))+x-32;
-				newY = gen.nextInt(y+32-(y-32))+y-32;	
-			}
-		}
-		int [] newPosition = {newX,newY};
-		return newPosition;
-	}
-
-	
-	
-}
diff --git a/VERSION W.I.P/version w.i.p/src/monsterRelated/BasicMonsterTest.java b/VERSION W.I.P/version w.i.p/src/monsterRelated/BasicMonsterTest.java
deleted file mode 100644
index 61792b5..0000000
--- a/VERSION W.I.P/version w.i.p/src/monsterRelated/BasicMonsterTest.java	
+++ /dev/null
@@ -1,129 +0,0 @@
-package monsterRelated;
-
-import static org.junit.Assert.*;
-import mapRelated.BasicMap;
-
-import org.junit.Test;
-import org.newdawn.slick.SlickException;
-
-public class BasicMonsterTest {
-	
-	
-	@Test
-	public void testGenericMove() throws SlickException{
-		//Arrange Data
-		BasicMap map = new BasicMap();
-		
-		BasicMonster b = new BasicMonster (map, 4*32, 5*32, 0);
-		String [][] test = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
-		for (int i = 0; i < BasicMap.widthByTiles; i++){
-			for (int c = 0; c < BasicMap.heightByTiles; c++){
-				test [i][c] = " ";
-				}
-			}
-		test[5][4] = "P";		
-		b.setEntityArray(test);
-		
-		//Act
-		int [] testPosition = {5*32,4*32};//Not in the way player
-		int [] monsterPos = {5*32, 5*32};//Monster's supposed current position
-			
-		//Assert
-		assertEquals(false, b.isTaken(5*32,5*32));
-		
-		//Act
-		b.update(testPosition,4000);//Move over by one.
-		
-		//Assert
-		assertArrayEquals(monsterPos, b.getPosition());
-		
-	}
-	
-	
-	@Test
-	public void testPlayerMissing(){
-		
-		//Arrange Data
-		BasicMap map = new BasicMap();
-		BasicMonster b = new BasicMonster (map, 4*32, 5*32, 0);
-		String [][] test = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
-		for (int i = 0; i < BasicMap.widthByTiles; i++){
-			for (int c = 0; c < BasicMap.heightByTiles; c++){
-				test [i][c] = " ";
-				}
-			}
-		b.setEntityArray(test);
-		int[] testPosition = {5*BasicMap.TILESIZE, 8*BasicMap.TILESIZE};
-		assertEquals(false, b.isTaken(testPosition[0], testPosition[1]));
-		
-		//Assert and Act
-		assertEquals("Player has disappeared from the map.",b.update(testPosition,4000));//Has an error message.
-	
-	}
-	
-	@Test
-	public void testExpPointGain() throws SlickException{
-		BasicMap map = new BasicMap();
-		
-		BasicMonster m = new BasicMonster (map, 10,10,100);
-		assertEquals(1000, m.getMaxHealthPoints());
-		assertEquals(500, m.getExpPointGain());
-	}
-	
-///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-////////////////TESTS ABILITY TO SELECT A VALID SPOT WHEN NOT BLOCKED BY ANYTHING//////////////////////////////////
-//	@Test
-//	public void testClosestSpotNotNear() throws SlickException{
-//		BasicMap map = new BasicMap();
-//		
-//		BasicMonster b = new BasicMonster(map, 4*32, 5*32, 0);
-//		int [] expected = {7*32,9*32};
-//		int [] test = b.getPosition();
-//		
-//		assertArrayEquals(expected, test);
-//	}
-/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
-///////////////TESTS ABILITY TO NOT OVERLAP OBSTACLES///////////////////////////////////////////////////////////////////	
-//	@Test
-//	public void testClosestSpotNear() throws SlickException{
-//		
-//		fail("Not yet implemented");
-//	}
-//	
-//	public void testClosestSpotObstacle()throws SlickException{
-//			
-//			fail("Not yet implemented");
-//	}
-//		
-////////////////////////////////////////////////////////////////////////////////////////////////////	
-/////////////////////TESTS FOR BOUNDARIES IN CLOSEST SPOT//////////////////////////////////////////
-//	@Test
-//	public void testClosestSpotWallLeft()throws SlickException{
-//		
-//		fail("Not yet implemented");
-//	}
-//	
-//		
-//	
-//	@Test
-//	public void testClosestSpotWallRight()throws SlickException{
-//		
-//		fail("Not yet implemented");
-//	}
-//	
-//	public void testClosestSpotWallUp()throws SlickException{
-//		
-//		fail("Not yet implemented");
-//	}
-//	
-//	public void testClosestSpotWallDown()throws SlickException{
-//		
-//		fail("Not yet implemented");
-//	}
-//	
-//	
-//	
-//	
-//	
-
-}
diff --git a/VERSION W.I.P/version w.i.p/src/monsterRelated/Entity.java b/VERSION W.I.P/version w.i.p/src/monsterRelated/Entity.java
deleted file mode 100644
index a85f131..0000000
--- a/VERSION W.I.P/version w.i.p/src/monsterRelated/Entity.java	
+++ /dev/null
@@ -1,152 +0,0 @@
-package monsterRelated;
-
-import mapRelated.BasicMap;
-
-public class Entity {
-	
-	//Has both the old position and current position 
-	protected int oldx = 0, oldy = 0;
-	protected int x,y;
-	
-	//Used to check for overlap with other monsters
-	protected String [][] entityArray;
-	
-	//Name is created (note: never let it equal to 1 )
-	protected String name;
-	
-	//Variables related with the health of the character
-	protected int healthPoints = 200;
-	protected int maxHealthPoints = 200;
-	protected boolean alive = true;
-	
-	
-	protected BasicMap map;
-	
-	//Every Entity Uses this.
-	public Entity (int x,int y){
-		this.x = x;
-		this.y = y;
-	}
-	
-/////////////////////////////////////////////////
-//METHODS USED FOR SEARCHING UPDATING LOCATION IN ENTITY ARRAY
-/////////////////////////////////////////////////
-	protected String updatePosition(int x, int y){
-		if (!alive)
-			return null;
-		oldx = this.x;
-		oldy = this.y;
-		entityArray[oldx/BasicMap.TILESIZE][oldy/BasicMap.TILESIZE] = " ";
-		entityArray[x/BasicMap.TILESIZE][y/BasicMap.TILESIZE] = name;
-		this.x = x;
-		this.y = y;
-		
-		return null;
-	}
-
-	protected boolean isTaken(int x, int y){
-		if (x <0 || y <0)
-			return false;
-		int xTile = x/BasicMap.TILESIZE;
-		int yTile = y/BasicMap.TILESIZE;
-		boolean isTaken = false;
-		if (entityArray[xTile][yTile] != " ")
-			isTaken = true;
-		return isTaken;
-	}
-	
-	
-	public boolean search(String name){
-			boolean found = false;
-			//Search looks within the range of 2
-			for (int row = (x/BasicMap.TILESIZE-2); row < (x/BasicMap.TILESIZE+2); row++)
-			{
-				for (int column = (y/BasicMap.TILESIZE)-2; column < y/BasicMap.TILESIZE+2; column++)
-				{
-					//If within bounds of the map.
-					if (row >= 0 && row < BasicMap.heightByTiles && column >= 0 && column <= BasicMap.widthByTiles)
-					{
-						if (entityArray[row][column]!= null&&entityArray[row][column].equals(name))
-						{
-							found = true;
-							break;
-						}
-					}
-					
-				}	
-			}	
-			return found;
-	}
-	
-/////////////////////////////////////////
-///////////Combat Methods////////////////
-/////////////////////////////////////////
-	public String subtractHealth(int points){
-		if (points < 0)
-			return "Cannot subtract negative health points";
-		
-		if (healthPoints - points <= 0){
-			alive = false;
-			entityArray[x/BasicMap.TILESIZE][y/BasicMap.TILESIZE] = " ";
-			healthPoints = 0;
-		}
-		else
-			healthPoints -= points;
-		return null;
-	}
-	
-	
-	public String addHealthPoints(int points){
-		if (points < 0)
-			return "Cannot add negative health points";
-			
-		if (healthPoints+points > maxHealthPoints)
-			healthPoints = maxHealthPoints;
-		else
-			healthPoints += points;
-		
-		return null;
-	}
-	
-	public int getHealthPoints(){return healthPoints;}
-	public int getMaxHealthPoints() {return maxHealthPoints;}
-	
-	
-	
-	
-	
-	
-	/////GENERAL GET/SET METHODS///////////////////////////
-	public String setEntityArray(String[][] entityArray){
-		
-		if (entityArray.length*entityArray[0].length != 35*16)
-			return "Entity Array Not Expected Size";
-		
-		for (String[] row: entityArray){
-			for (String s:row)
-			{
-				if (s == null)
-					return "EntityArray cannot have null objects";
-			}
-		}
-		this.entityArray = entityArray;
-		
-		return null;}
-	
-	public String[][]getEntityArray(){return entityArray;}
-	public boolean getAlive(){return alive;}
-	
-	public String getName(){return name;}	
-	
-	public int[] getPosition(){
-		int[] position = new int[2];
-		position[0] = x;
-		position[1] = y;
-		return position;
-	}
-	
-	public void setMap(BasicMap map){
-		this.map = map;//Just In case we're loading new floors.
-	}	
-	
-}
diff --git a/VERSION W.I.P/version w.i.p/src/monsterRelated/EntityTest.java b/VERSION W.I.P/version w.i.p/src/monsterRelated/EntityTest.java
deleted file mode 100644
index 3d53565..0000000
--- a/VERSION W.I.P/version w.i.p/src/monsterRelated/EntityTest.java	
+++ /dev/null
@@ -1,292 +0,0 @@
-package monsterRelated;
-
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import mapRelated.BasicMap;
-
-import org.junit.Test;
-
-public class EntityTest {
-	
-///////ENTITY ARRAY TESTS///////////
-	
-	@Test
-	public void testValidEntityArray(){
-		
-			Entity e = new Entity(3*32,7*32);
-			
-			String [][] testArray = new String [35][16];
-
-			for (int i = 0; i < BasicMap.widthByTiles; i++)
-			{
-				for (int c = 0; c < BasicMap.heightByTiles; c++)
-				{
-					testArray[i][c] = " ";
-				}
-			}
-			
-			//Act and assert
-			assertEquals(null,e.setEntityArray(testArray));	
-	}
-	
-	@Test
-	public void testInvalidEntityArray(){
-		Entity e = new Entity(3*32,4*32);
-		String [][] testArray = new String [25][15];
-		assertEquals("Entity Array Not Expected Size",e.setEntityArray(testArray));
-	}
-
-	@Test
-	public void testNullEntityArray(){
-		Entity e = new Entity(3*32,4*32);
-		String [][] testArray = new String [35][16];
-		assertEquals("EntityArray cannot have null objects", e.setEntityArray(testArray));
-		
-	}
-	
-	
-
-//TEST SEARCH	
-	
-	@Test
-	public void testSearchOneCreature() {
-		//Arrange
-		Entity c = new Entity(4*32,4*32);
-		String [][] test = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
-		for (int i = 0; i < BasicMap.widthByTiles; i++)
-		{
-			for (int d = 0; d < BasicMap.heightByTiles; d++)
-			{
-				test[i][d] = " ";
-			}
-		}
-		test[3][4] = "M";	
-		
-		//Act and Assert
-		assertEquals(null,c.setEntityArray(test));
-		
-		String[][] test1 = c.getEntityArray();
-		//Test if the we /definitely/ have the same array inside this creature
-		assertArrayEquals(test, test1);
-		//Test to see if there is a Player nearby
-		assertEquals(false, c.search("P"));
-		//Test to see if there is an 'M' or essentially if it can spot itself
-		assertEquals(true, c.search("M"));
-	}
-	
-	//Test update position
-	@Test(expected= ArrayIndexOutOfBoundsException.class)
-	public void testInvalidPostion(){
-		Entity e = new Entity(5*32,5*32);
-		String [][] test = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
-		for (int i = 0; i < BasicMap.widthByTiles; i++)
-		{
-			for (int d = 0; d < BasicMap.heightByTiles; d++)
-			{
-				test[i][d] = " ";
-			}
-		}
-		e.setEntityArray(test);
-		e.updatePosition(-100,-100);
-	}
-	
-	
-	
-	
-	
-	
-	@Test
-	public void testWanderCreature(){
-		//Arrange
-		Entity c = new Entity(3*32, 4*32);
-		c.name = "M";
-		String [][] test = new String[35][16];
-		for (int i = 0; i <BasicMap.widthByTiles; i++)
-		{
-			for (int d = 0; d < BasicMap.heightByTiles; d++)
-				test[i][d] = " ";
-		}
-		//Act
-		c.setEntityArray(test);
-		c.updatePosition(5*32, 7*32);
-		c.updatePosition(2*32, 4*32);
-		c.updatePosition(5*32, 5*32);
-		
-
-		String [][] test2 = new String[35][16];
-		for (int i = 0; i <BasicMap.widthByTiles; i++)
-		{
-			for (int d = 0; d < BasicMap.heightByTiles; d++)
-				test2[i][d] = " ";
-		}
-		test2[5][5] = "M";
-	
-		assertArrayEquals(test2,c.getEntityArray());
-		
-	}
-	
-	@Test
-	public void testSetPositionOneCreature(){
-		//Test Set-Up
-		Entity c = new Entity(3*32, 4*32);
-		c.name = "M";
-		//We /have/ to create an array with " " in every spot.
-		//Hence the terrible need for loop logic.
-		String [][] test = new String[35][16];
-		for (int i = 0; i <BasicMap.widthByTiles; i++)
-		{
-			for (int d = 0; d < BasicMap.heightByTiles; d++)
-				test[i][d] = " ";
-		}
-		//Writes an 'M' in a spot that we later erase.
-		test[3][4] = "M";
-		c.setEntityArray(test);
-		
-		//Updates the position of the creature
-		c.updatePosition(4*32, 4*32);
-		
-		//Create a blank another array to compare to
-		String[][] testEntity = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
-		for (int i = 0; i <BasicMap.widthByTiles; i++)
-		{
-			for (int d = 0; d < BasicMap.heightByTiles; d++)
-				testEntity[i][d] = " ";
-		}
-		//Manually store the new position
-		testEntity[4][4] = "M";
-		//Get the entityArray for this creature 
-		String[][] entityArray = c.getEntityArray();
-		//Check if they are the same.
-		assertArrayEquals(testEntity, entityArray);
-	}
-	
-	@Test
-	public void testTwoMovingCreatures(){
-		Entity c = new Entity(5*32,2*32);
-		Entity c2 = new Entity(7*32,9*32);
-		
-		String [][] testEntity = new String[BasicMap.widthByTiles][ BasicMap.heightByTiles];
-		
-		for (int i = 0; i <BasicMap.widthByTiles; i++)
-		{
-			for (int d = 0; d < BasicMap.heightByTiles; d++)
-				testEntity[i][d] = " ";
-		}
-		testEntity[3][5] = "T";
-		testEntity[5][5] = "B";
-		c.setEntityArray(testEntity);
-		c2.setEntityArray(testEntity);
-		
-		c.updatePosition(9*32, 9*32);
-		c2.updatePosition(5*32, 1*32);
-		
-		assertEquals(true, c2.isTaken(9*32, 9*32)); //C2 knows where the update position of c
-		assertArrayEquals(c.getEntityArray(), c2.getEntityArray());//They both have the same array
-		
-	}
-	
-	@Test
-	public void testIsTakenNegativeInput(){
-		Entity e = new Entity (4*32,5*32);
-		assertEquals(false, e.isTaken(-10,-20));	
-	}
-	
-	
-	
-	@Test
-	public void testIsTakenOneCreature(){
-		//Set-Up Test
-		String[][] testEntity = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
-		for (int i = 0; i <BasicMap.widthByTiles; i++)
-		{
-			for (int d = 0; d < BasicMap.heightByTiles; d++)
-				testEntity[i][d] = " ";
-		}
-		testEntity[3][5] = "T";
-		Entity c = new Entity(3*32, 5*32);
-		c.name = "T";
-		c.setEntityArray(testEntity);
-		
-		//The entity array should know there is something in the array.
-		assertEquals(false, c.isTaken(4*32,5*32));
-		assertEquals(true,c.isTaken(3*32,5*32));
-	}
-	
-	@Test
-	public void testIsTakenTwoCreatures(){
-		String[][] testEntity = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
-		for (int i = 0; i <BasicMap.widthByTiles; i++)
-		{
-			for (int d = 0; d < BasicMap.heightByTiles; d++)
-				testEntity[i][d] = " ";
-		}
-		testEntity[3][5] = "T";
-		testEntity[5][5] = "B";
-		Entity c = new Entity(3*32, 5*32);
-		Entity c2 = new Entity(5*32, 5*32);
-		c.name = "T";
-		c2.name = "B";
-		c.setEntityArray(testEntity);
-		c2.setEntityArray(testEntity);
-		//The entity array should know there is something in the array.
-		assertEquals(false, c.isTaken(4*32,5*32));
-		assertEquals(true,c.isTaken(5*32,5*32));
-		assertEquals(false, c2.isTaken(2*32, 6*32));
-		assertEquals(true, c.isTaken(3*32,5*32));
-	}
-	
-	
-///////////////////////////////////////////////////////////////////////////////////////////////	
-//Combat METHOD TESTS
-///////////////////////////////////////////////////////////////////////////////////////////////	
-	@Test
-	public void testSubtractNegativePoints(){
-		Entity e = new Entity (4,5);
-		assertEquals("Cannot subtract negative health points", e.subtractHealth(-10));		
-	}
-	
-	
-	
-	
-	@Test
-	public void testUpdateHealthPoints(){
-		Entity e = new Entity (4,5);
-		assertEquals(null, e.subtractHealth(10));
-		
-	}
-	@Test
-	public void testDead(){
-		Entity e = new Entity(4,5);
-		String [][] testArray = new String [35][16];
-		for (int i = 0; i < BasicMap.widthByTiles; i++)
-		{
-			for (int c = 0; c < BasicMap.heightByTiles; c++)
-			{
-				testArray[i][c] = " ";
-			}
-		}
-		e.setEntityArray(testArray);
-		e.subtractHealth(1000);
-		
-		assertEquals(false, e.getAlive());
-		assertEquals(0, e.getHealthPoints());
-	}
-	
-	
-	@Test
-	public void testAddValidHealthPoints(){
-		Entity e = new Entity(4,5);
-		assertEquals(null, e.addHealthPoints(50));
-		assertEquals(null, e.addHealthPoints(120));
-		assertEquals(200, e.getHealthPoints());
-	}
-	
-	@Test
-	public void testAddNegativeHealthPoints(){
-		Entity e = new Entity(4,5);
-		assertEquals("Cannot add negative health points", e.addHealthPoints(-50));	
-		
-	}
-	
-
-}
diff --git a/VERSION W.I.P/version w.i.p/src/monsterRelated/PrintingTests.java b/VERSION W.I.P/version w.i.p/src/monsterRelated/PrintingTests.java
deleted file mode 100644
index 6a29831..0000000
--- a/VERSION W.I.P/version w.i.p/src/monsterRelated/PrintingTests.java	
+++ /dev/null
@@ -1,49 +0,0 @@
-package monsterRelated;
-
-import mapRelated.BasicMap;
-
-public class PrintingTests {
-	
-	///THIS IS A TERRIBLE TERRIBLE HABIT AND BAD PRACTICE WITH CODING
-	//BUT I LIKE PRINTING ALL VALUES IN ORDER TO NARROW DOWN THE PROBLEM OF THINGS
-	//So yeah....
-	
-	
-	public static void printEntityArray (String[][] entityArray){
-		System.out.println("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-		for (int i = 0; i < BasicMap.heightByTiles; i++)
-		{
-		
-			for (int c = 0; c < BasicMap.widthByTiles; c++){
-
-				System.out.print("|");
-				System.out.print(entityArray[c][i]);
-				System.out.print("|");
-			}	
-			System.out.println("");
-			System.out.println("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-			
-		}
-		
-	}
-
-	
-	public static void printCharArray (char[][] mapArray){
-		System.out.println("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-		for (int i = 0; i < BasicMap.heightByTiles; i++)
-		{
-		
-			for (int c = 0; c < BasicMap.widthByTiles; c++){
-
-				System.out.print("|");
-				System.out.print(mapArray[c][i]);
-				System.out.print("|");
-			}	
-			System.out.println("");
-			System.out.println("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
-			
-		}
-		
-	}
-
-}
diff --git a/VERSION W.I.P/version w.i.p/src/playerRelated/Player.java b/VERSION W.I.P/version w.i.p/src/playerRelated/Player.java
deleted file mode 100644
index d4f7696..0000000
--- a/VERSION W.I.P/version w.i.p/src/playerRelated/Player.java	
+++ /dev/null
@@ -1,421 +0,0 @@
-package playerRelated;
-
-import gameStates.GameOver;
-import gameStates.GameScreenAssets;
-import managers.CombatManager;
-import managers.SoundManager;
-import mapRelated.BasicMap;
-import monsterRelated.Entity;
-
-import org.newdawn.slick.Animation;
-import org.newdawn.slick.Color;
-import org.newdawn.slick.GameContainer;
-import org.newdawn.slick.Graphics;
-import org.newdawn.slick.Image;
-import org.newdawn.slick.Input;
-import org.newdawn.slick.SlickException;
-import org.newdawn.slick.SpriteSheet;
-import org.newdawn.slick.state.StateBasedGame;
-import org.newdawn.slick.state.transition.FadeInTransition;
-import org.newdawn.slick.state.transition.FadeOutTransition;
-
-public class Player extends Entity{
-	
-	//Variables used for Slick 2 Game Components
-	private final GameContainer gc;
-	private final StateBasedGame sbg;
-	
-	//Used for stair case movement 
-	private boolean onStairs;
-	
-	//Variables used for Combat and related aspects
-	private int experiencePoints = 0;
-	private int pointsNextLevel = 1000;
-
-	private int playerLevel = 1;
-	private int damageIncrease = 0;//Could be increased for level ups
-	private int criticalHitLimit= 30;
-	private int missFactor = 5;
-	
-	//Basic Sprite Variables
-	private SpriteSheet sheet;
-	private Animation currentSprite, up, down,left,right;
-
-	//Limited Vision Effect
-	private Image shadow;		
-	
-	////FOR TEST PURPOSES ONLY////
-	public Player (int x, int y){
-		super(x,y);
-		gc = null;
-		sbg = null;
-		name = "P";
-	}
-	////FOR TEST PURPOSES ONLY////
-		
-		
-	public Player(GameContainer gc, StateBasedGame sbg, BasicMap currentMap,int x, int y) throws SlickException{
-		//Constructor used to 
-		super(x,y);
-		
-		//Variables for the usage outside functions
-		this.gc = gc;
-		this.sbg = sbg;
-		map = currentMap;
-		
-		//Initialize Variables
-		name = "P";
-		sheet = new SpriteSheet("res/player/template2.png", 32,32);
-		shadow = new Image("res/player/largerShadow.png");
-		loadPlayerSprite(sheet);
-		
-	}
-	
-	private void loadPlayerSprite(SpriteSheet playerSheet){
-				//Load Sprite Images for Player
-				Image [] upSprite = {sheet.getSubImage(0,3),
-								     sheet.getSubImage(1,3),
-								     sheet.getSubImage(2,3),
-								     sheet.getSubImage(3,3)};
-				Image [] downSprite = {sheet.getSubImage(0,0),
-					     			  sheet.getSubImage(1,0),
-					     			  sheet.getSubImage(2,0),
-					     			  sheet.getSubImage(3,0)};
-				Image [] rightSprite = {sheet.getSubImage(0,2),
-										sheet.getSubImage(1,2),
-										sheet.getSubImage(2,2),
-										sheet.getSubImage(3,2)};
-				
-				Image [] leftSprite = {sheet.getSubImage(0,1),
-					     			   sheet.getSubImage(1,1),
-					     			   sheet.getSubImage(2,1),
-					     			   sheet.getSubImage(3,1)};
-
-				//Set the duration of Animation in Milliseconds	
-				int [] duration = {300,300,300,300};
-				
-				//Initialize Animations
-				up = new Animation(upSprite, duration, false);
-				down = new Animation (downSprite, duration, false);
-				left = new Animation(leftSprite, duration, false);
-				right = new Animation (rightSprite,duration,false);		
-				currentSprite = down;
-				currentSprite.setAutoUpdate(true);
-				up.setAutoUpdate(true);
-				left.setAutoUpdate(true);
-				right.setAutoUpdate(true);
-	}
-	
-	
-	
-	public void render(Graphics g){
-	currentSprite.draw((int) x, (int) y);//Draw what the Current sprite should look like.
-	g.drawImage(shadow,(int)x-1110, (int)y-850); //Draw Shadow with a particular offset for the spotlight
-	}
-	
-	
-	public void update(long delta){
-		
-		//If the player is not alive change game state.
-		if (!alive){
-			
-			GameScreenAssets.queueTextLog.add( "Your player be dead");
-			
-			//Change state of game to game over state.
-			sbg.enterState(GameOver.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));
-			//Change Sound to Game Over State's sound
-			SoundManager.changeSound("res/sound/A Time To Lose.wav");
-			}
-		
-		
-		
-		//Input used to get keyboard controls
-		Input input = gc.getInput();
-		 
-		//Diagonal Up Left
-		if (input.isKeyPressed(Input.KEY_NUMPAD7)||input.isKeyPressed(Input.KEY_7)){
-			 moveDiagonalUpLeft();
-		 }
-		
-		//Normal Up
-		else if (input.isKeyPressed(Input.KEY_UP)||input.isKeyPressed(Input.KEY_8)
-				||input.isKeyPressed(Input.KEY_NUMPAD8)){
-				moveUp();
-		}
-		
-		//Diagonal Up Right
-		else if (input.isKeyPressed(Input.KEY_NUMPAD9)||input.isKeyPressed(Input.KEY_9)){
-				moveDiagonalUpRight();
-		}
-
-		//Normal Left
-		else if (input.isKeyPressed(Input.KEY_LEFT)||input.isKeyPressed(Input.KEY_U)
-				||input.isKeyPressed(Input.KEY_NUMPAD4)){
-				moveLeft();
-		}
-		
-		//PASS TURN
-		else if (input.isKeyPressed(Input.KEY_NUMPAD5)||input.isKeyPressed(Input.KEY_I))
-			{
-			moveNowhere();
-			}
-		
-		//Normal Right
-		else if (input.isKeyPressed(Input.KEY_RIGHT)||input.isKeyPressed(Input.KEY_O)||
-				input.isKeyPressed(Input.KEY_NUMPAD6)){
-			moveRight();
-			}
-		
-		//Diagonal Down Left
-		else if (input.isKeyPressed(Input.KEY_NUMPAD1)||input.isKeyPressed(Input.KEY_J)){
-				moveDiagonalDownLeft();
-				}
-		
-		//Normal Down
-		else if (input.isKeyPressed(Input.KEY_DOWN)||input.isKeyPressed(Input.KEY_K)||
-				input.isKeyPressed(Input.KEY_NUMPAD2)){
-			moveDown();
-		}
-
-		//Diagonal Down Right
-		else if (input.isKeyPressed(Input.KEY_NUMPAD3)||input.isKeyPressed(Input.KEY_L)){
-			moveDiagonalDownRight();
-		}
-		 
-	}
-
-	
-////////////METHODS DEALING WITH MOVEMENT//////////////////////
-	
-	private void moveDiagonalUpLeft(){
-			 currentSprite = left;
-			int newX = x-BasicMap.TILESIZE;
-			int newY = y-BasicMap.TILESIZE;
-			if (isTaken(newX, newY))
-				attack(newX,newY);
-			else if (!(map.hasCollision(newX, newY)))
-				{
-				updatePosition(newX,newY);
-				x = newX;
-				y = newY;
-				
-				if (map.isStairs(x, y)){
-					onStairs = true;
-					}
-				}
-		 }
-	
-	
-	private void moveUp(){
-			currentSprite = up;
-			int newY = y - BasicMap.TILESIZE;
-			if (isTaken(x,newY))
-				attack(x, newY);
-			else if (!(map.hasCollision(x, newY))){
-				updatePosition(x,newY);
-				y = newY;
-				if (map.isStairs(x, y)){
-					onStairs = true;
-					}
-			}
-		}
-		
-		
-	private void moveDiagonalUpRight(){
-			currentSprite = right;
-			int newX = x + BasicMap.TILESIZE;
-			int newY = y - BasicMap.TILESIZE;
-			
-			if (isTaken(newX, newY))
-				attack(newX, newY);
-			else if (!(map.hasCollision(newX, newY)))	
-				{
-					updatePosition(newX,newY);
-					y = newY;
-					x = newX;	
-					if (map.isStairs(x, y)){
-						onStairs = true;
-						}
-				}
-		}
-
-	private void moveLeft(){	
-			currentSprite = left;
-			int newX = x-BasicMap.TILESIZE;
-			if (isTaken(newX, y))
-				attack(newX,y);
-			else if (!(map.hasCollision(newX, y))){
-				updatePosition(newX,y);
-				x = newX;
-				if (map.isStairs(x, y)){
-					onStairs = true;
-					}
-			}
-			
-		}
-		
-	private void moveNowhere()
-			{
-			currentSprite = down;
-			if (map.isStairs(x, y)){
-				onStairs = true;
-				}
-		
-			}
-		
-	private void moveRight(){
-			currentSprite = right;
-			int newX = x + BasicMap.TILESIZE;
-			if  (isTaken(newX, y))
-				attack(newX,y);
-			else if (!(map.hasCollision(newX, y))){
-				updatePosition(newX,y);
-				x = newX;
-				if (map.isStairs(x, y)){
-					onStairs = true;
-					}
-				}
-			}	
-		
-		
-	private void moveDiagonalDownLeft(){
-				currentSprite = left;
-				int newX = x-BasicMap.TILESIZE;
-				int newY = y +BasicMap.TILESIZE;
-				if (isTaken(newX, newY))
-					attack(newX, newY);
-				else if (!(map.hasCollision(newX,  newY)))
-					{
-					updatePosition(newX,newY);
-					x = newX;
-					y = newY;
-					if (map.isStairs(x, y)){
-						onStairs = true;
-						}
-					}
-				}
-				
-	private void moveDown(){
-			currentSprite = down;
-			int newY = y +BasicMap.TILESIZE;
-			if (isTaken(x, newY))
-				attack (x, newY);
-			else if (!(map.hasCollision(x, newY))){
-				updatePosition(x,newY);
-				y = newY;
-				if (map.isStairs(x, y)){
-					onStairs = true;
-					}
-				}
-			
-			}
-
-	private void moveDiagonalDownRight(){
-			currentSprite = right;
-			int newX = x+BasicMap.TILESIZE;
-			int newY = y+BasicMap.TILESIZE;
-				if (isTaken(newX, newY)){
-					attack(newX, newY);
-				}
-				else if (!(map.hasCollision(newX,newY)))
-					{
-					updatePosition(newX,newY);
-					x = newX;
-					y = newY;
-					if (map.isStairs(x, y)){
-						onStairs = true;
-						}
-					}
-			
-				}
-	
-///////////METHOD DEALING WITH LEVELING UP////////////////////
-	public String addExperiencePoints(int points){
-		if (points <0)
-			return "Can't gain negative EXP";
-		
-		//Add points given
-		experiencePoints += points;
-		if (levelUp())
-		{
-			GameScreenAssets.queueTextLog.add("Woohoo! Player has leveled Up!");
-			return "Player has leveled up";
-		}
-		
-			
-		return null;
-	}
-	
-	private boolean levelUp(){
-		
-		if (experiencePoints >= pointsNextLevel){
-			playerLevel++;
-			//Increase Maximum Health & Heal Up Completely
-			maxHealthPoints += playerLevel*maxHealthPoints/3;
-			healthPoints = maxHealthPoints;
-				
-			//Decrease Experience Points used up
-			//Increase amount needed to next level
-			experiencePoints = experiencePoints-pointsNextLevel;
-			pointsNextLevel *= playerLevel;
-			return true;
-			}
-		return false;
-		
-	}
-
-		
-	
-	
-	public int getExperiencePoints(){return experiencePoints;}
-	
-	public int getPointsNextLevel() {return pointsNextLevel;}
-///////////METHODS DEALING WITH COMBAT///////////////////	
-	
-	private void attack(int monsterX, int monsterY){
-	CombatManager.attackLoop(this,criticalHitLimit, missFactor, monsterX, monsterY);	
-	}
-	
-	
-//////////Method dealing with stairs///////////////
-
-	public boolean getOnStairs(){return onStairs;}
-	
-	public void setOnStairs(boolean var){onStairs = var;}
-
-	
-//////////////////////////////////////////////////////////////////////////////////////////////////////
-//////////////////////////////////////////////////////////////////////////////////////////////////////	
-//////////////////////////////////////////////////////////////////////////////////////////////////////	
-	//ALL CODE BELOW WAS CREATED IN ATTEMPT TO SMOOTH OUT MOVEMENT/////////
-	
-	///////////THAT STILL NEEDS TO BE IMPLEMENTED./////////////
-	
-	private float getDistanceX(int current_x, int target_x)
-	{
-		float distance_x = Math.abs(current_x-target_x);
-		return distance_x;
-	}
-	
-	private float getDistanceY(int current_y, int target_y){
-		float distance_y = Math.abs(current_y-target_y);
-		return distance_y;
-	}
-	
-	
-	
-	private void delayTimer(){
-		for (long i = 0; i <10000;i++)
-		{
-		}
-	}
-	
-	
-		private void moveTowardsY(int current_y, int target_y)
-	{			
-
-		//FUNCTION RENDER SMOOTHER TRANSITIONS
-		//Has to increment y until it's reach the target y
-		//calls render appropriately.
-	}
-}
diff --git a/Version 1.1/NewestVersion/src/monsterRelated/Entity.java b/Version 1.1/NewestVersion/src/monsterRelated/Entity.java
index 1b47b54..e4e09f0 100644
--- a/Version 1.1/NewestVersion/src/monsterRelated/Entity.java	
+++ b/Version 1.1/NewestVersion/src/monsterRelated/Entity.java	
@@ -1,5 +1,6 @@
 package monsterRelated;
 
+import gameStates.GameWindowSettings;
 import mapRelated.BasicMap;
 
 public class Entity {
@@ -22,8 +23,8 @@ public class Entity {
 	//Map entity stands upon currently
 	protected BasicMap map;
 	
-	private final int screenWidth = 1120;
-	private final int screenHeight = 512;
+	private final int screenWidth = GameWindowSettings.getScreenWidth();
+	private final int screenHeight = GameWindowSettings.getScreenHeight();
 	
 	//Location of entity
 	public Entity (int x,int y){
@@ -170,5 +171,8 @@ public class Entity {
 	}	
 	
 	public void setName(String name){this.name = name;}
-	
+
+
 }
+	
+

commit 922474dc46ad412f02602268654bdbe2a98c0c86
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 19:42:47 2017 -0600

    Changed MonsterManager screenwidth referneces to call GameWindowSettings class

diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/GameWindowSettings.class b/VERSION W.I.P/version w.i.p/bin/gameStates/GameWindowSettings.class
new file mode 100644
index 0000000..ac52f1d
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/gameStates/GameWindowSettings.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/Ver2GameDriver.class b/VERSION W.I.P/version w.i.p/bin/gameStates/Ver2GameDriver.class
index 1f913be..0ebe611 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/Ver2GameDriver.class and b/VERSION W.I.P/version w.i.p/bin/gameStates/Ver2GameDriver.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class b/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class
index 4dd5075..0cbab7a 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class and b/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class b/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class
index 80bc054..7a95005 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class and b/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class differ
diff --git a/Version 1.1/NewestVersion/src/managers/MonsterManager.java b/Version 1.1/NewestVersion/src/managers/MonsterManager.java
index 8811653..084c68a 100644
--- a/Version 1.1/NewestVersion/src/managers/MonsterManager.java	
+++ b/Version 1.1/NewestVersion/src/managers/MonsterManager.java	
@@ -13,6 +13,8 @@ import org.newdawn.slick.Image;
 import org.newdawn.slick.SlickException;
 import org.newdawn.slick.SpriteSheet;
 
+import gameStates.GameWindowSettings;
+
 /////////////////////////////////////////////////////////////
 //Monster Manager                                          //
 //Purpose: Manage Multiple Monsters in a level		       //
@@ -27,9 +29,8 @@ public class MonsterManager {
 	private int level = 1;
 	private BasicMap currentMap;
 	private String[][] entityArray;
-	private int screenWidth = 1120;
-	private int screenHeight = 512;
-	
+	private int screenWidth = GameWindowSettings.getScreenWidth();
+	private int screenHeight = GameWindowSettings.getScreenHeight();
 	
 	
 	//Monster Type1

commit db6e36527213c130d625ece3f925df82fe3efc10
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 12:19:28 2017 -0600

    Changed Ver2GameDriver screenwidth references to call GameWindowSettings class

diff --git a/Version 1.1/NewestVersion/src/gameStates/Ver2GameDriver.java b/Version 1.1/NewestVersion/src/gameStates/Ver2GameDriver.java
index f537b4b..75aa4a6 100644
--- a/Version 1.1/NewestVersion/src/gameStates/Ver2GameDriver.java	
+++ b/Version 1.1/NewestVersion/src/gameStates/Ver2GameDriver.java	
@@ -14,8 +14,8 @@ public class Ver2GameDriver {
 		
 		//All the code below is how we get this game rolling and running.
 		
-		final int screenWidth = 1120; // Set screen width to 35 tiles long (35*32px)
-		final int screenHeight = 512; // Set screen height to 16 tile long (16*32px)
+		final int screenWidth = GameWindowSettings.getScreenWidth(); // Set screen width to 35 tiles long (35*32px)
+		final int screenHeight = GameWindowSettings.getScreenHeight(); // Set screen height to 16 tile long (16*32px)
 		
 			try
 			{

commit a3f983074c22c6297ad96afcf3eaded236a9ee1b
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 12:17:23 2017 -0600

    changed extracted values to static

diff --git a/Version 1.1/NewestVersion/src/gameStates/GameWindowSettings.java b/Version 1.1/NewestVersion/src/gameStates/GameWindowSettings.java
index 5afdbd1..0d482ea 100644
--- a/Version 1.1/NewestVersion/src/gameStates/GameWindowSettings.java	
+++ b/Version 1.1/NewestVersion/src/gameStates/GameWindowSettings.java	
@@ -2,11 +2,10 @@ package gameStates;
 
 public class GameWindowSettings {
 
-	private final int screenWidth = 1120;
-	private final int screenHeight = 800;
-	
-	public int getScreenWidth() {return screenWidth;}
-	public int getScreenHeight() {return screenHeight;}
+	private static final int screenWidth =1120;
+	private static final int screenHeight = 512;
 	
+	public static int getScreenWidth() {return screenWidth;}
+	public static int getScreenHeight() {return screenHeight;}
 	
 }

commit dc6666c2c666a16e51d3d852f9c751aca4c7200b
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 12:16:13 2017 -0600

    Fixing screenwidth/screenheight shotgun surgery problem. Created GameWindow Class

diff --git a/Version 1.1/NewestVersion/src/gameStates/GameWindowSettings.java b/Version 1.1/NewestVersion/src/gameStates/GameWindowSettings.java
new file mode 100644
index 0000000..5afdbd1
--- /dev/null
+++ b/Version 1.1/NewestVersion/src/gameStates/GameWindowSettings.java	
@@ -0,0 +1,12 @@
+package gameStates;
+
+public class GameWindowSettings {
+
+	private final int screenWidth = 1120;
+	private final int screenHeight = 800;
+	
+	public int getScreenWidth() {return screenWidth;}
+	public int getScreenHeight() {return screenHeight;}
+	
+	
+}

commit ed7a45e3729eeec4a5426880e15299835f245587
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 12:13:13 2017 -0600

    Deleted uneeded ButtonAction.java file

diff --git a/Version 1.1/NewestVersion/src/inputRelated/ButtonAction.java b/Version 1.1/NewestVersion/src/inputRelated/ButtonAction.java
deleted file mode 100644
index 2d20a32..0000000
--- a/Version 1.1/NewestVersion/src/inputRelated/ButtonAction.java	
+++ /dev/null
@@ -1,4 +0,0 @@
-package inputRelated;
-
-
-

commit 963727fa410ee04fd5ce1fbf929379fea9a02942
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 12:12:33 2017 -0600

    Moved Lazy Class 'ButtonAction' to inside BasicButton

diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/BasicButton$ButtonAction.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/BasicButton$ButtonAction.class
new file mode 100644
index 0000000..da8f3fc
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/inputRelated/BasicButton$ButtonAction.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/BasicButton.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/BasicButton.class
index b99edd5..31dee3c 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/BasicButton.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/BasicButton.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons$1.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons$1.class
index f745251..ab6dc83 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons$1.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons$1.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons$2.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons$2.class
index 7389e05..73a324d 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons$2.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons$2.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons.class
index 7cd5f35..5e1805e 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons$1.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons$1.class
index 787b0c0..78eb17c 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons$1.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons$1.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons$2.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons$2.class
index 6a746da..d9bae54 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons$2.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons$2.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons.class
index da41599..0202c77 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/SlideOutMenu$1.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/SlideOutMenu$1.class
index bbe653f..408b51e 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/SlideOutMenu$1.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/SlideOutMenu$1.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/SlideOutMenu.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/SlideOutMenu.class
index 2a41c5c..7d6564b 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/SlideOutMenu.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/SlideOutMenu.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class b/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class
index 61535aa..80bc054 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class and b/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class differ
diff --git a/Version 1.1/NewestVersion/src/inputRelated/BasicButton.java b/Version 1.1/NewestVersion/src/inputRelated/BasicButton.java
index 6b787ac..4494e4a 100644
--- a/Version 1.1/NewestVersion/src/inputRelated/BasicButton.java	
+++ b/Version 1.1/NewestVersion/src/inputRelated/BasicButton.java	
@@ -52,8 +52,8 @@ public class BasicButton extends MouseOverArea {
 	}
      
     //Method to add actions to a button to perform
-	public void add(ButtonAction action){
-		actions.add(action);
+	public void add(BasicButton.ButtonAction buttonAction){
+		actions.add(buttonAction);
 	}
 	
 	//Disables button
@@ -111,6 +111,12 @@ public class BasicButton extends MouseOverArea {
 	
 	//Gets the list of actions for the button
     public List <ButtonAction>getActions(){return actions;}
+  
+    
+    //Source :https://evilzone.org/java/%28java-fames-tut%29-slick2d-buttons-buttons-buttons/
+    public interface ButtonAction {
+    	public void perform();
+    }
 }
 	
 	
diff --git a/Version 1.1/NewestVersion/src/inputRelated/ButtonAction.java b/Version 1.1/NewestVersion/src/inputRelated/ButtonAction.java
index 0083640..2d20a32 100644
--- a/Version 1.1/NewestVersion/src/inputRelated/ButtonAction.java	
+++ b/Version 1.1/NewestVersion/src/inputRelated/ButtonAction.java	
@@ -1,9 +1,4 @@
 package inputRelated;
 
 
-//Source :https://evilzone.org/java/%28java-fames-tut%29-slick2d-buttons-buttons-buttons/
-public interface ButtonAction {
-	public void perform();
 
-
-}
diff --git a/Version 1.1/NewestVersion/src/inputRelated/EndGameButtons.java b/Version 1.1/NewestVersion/src/inputRelated/EndGameButtons.java
index 9995a91..0520984 100644
--- a/Version 1.1/NewestVersion/src/inputRelated/EndGameButtons.java	
+++ b/Version 1.1/NewestVersion/src/inputRelated/EndGameButtons.java	
@@ -46,14 +46,14 @@ public class EndGameButtons {
 		quitGameButton.setMouseOverImage(mouseOverQuitGame);
 		
 		//Creates an anon class for the button's action.
-		newGameButton.add(new ButtonAction(){ 
+		newGameButton.add(new BasicButton.ButtonAction(){ 
 			public void perform(){
 			sbg.enterState(GameScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));	
 			}
 			});
 		
 		//Creates an anon class for the button's action.
-		quitGameButton.add(new ButtonAction(){ 
+		quitGameButton.add(new BasicButton.ButtonAction(){ 
 			public void perform(){
 				//Delete game/Over write old game here
 				((GameContainer)gc).exit();	
diff --git a/Version 1.1/NewestVersion/src/inputRelated/MainMenuButtons.java b/Version 1.1/NewestVersion/src/inputRelated/MainMenuButtons.java
index 91c9760..b67c76a 100644
--- a/Version 1.1/NewestVersion/src/inputRelated/MainMenuButtons.java	
+++ b/Version 1.1/NewestVersion/src/inputRelated/MainMenuButtons.java	
@@ -66,7 +66,7 @@ public class MainMenuButtons {
 		loadGameButton.setMouseOverImage(new Image("res/interface/continueMouseOver.png"));
 	}	
 	//Creates an anon class for the button's action.
-	newGameButton.add(new ButtonAction(){ 
+	newGameButton.add(new BasicButton.ButtonAction(){ 
 		public void perform(){
 		sbg.enterState(TransitionScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));	
 		}
@@ -74,7 +74,7 @@ public class MainMenuButtons {
 	
 	
 	//Creates an anon class for the button's action.
-	loadGameButton.add(new ButtonAction(){ 
+	loadGameButton.add(new BasicButton.ButtonAction(){ 
 		public void perform(){
 		if (savedGameExists){
 			GameScreen.setLoadedGame(true);
diff --git a/Version 1.1/NewestVersion/src/inputRelated/SlideOutMenu.java b/Version 1.1/NewestVersion/src/inputRelated/SlideOutMenu.java
index 0ab58e9..690caa4 100644
--- a/Version 1.1/NewestVersion/src/inputRelated/SlideOutMenu.java	
+++ b/Version 1.1/NewestVersion/src/inputRelated/SlideOutMenu.java	
@@ -47,7 +47,7 @@ public class SlideOutMenu extends MouseOverArea{
 	    		stateID, new Image ("res/interface/saveExit.png"), new Image ("res/interface/saveExit.png"));
 	    
 	    exitGameButton.setMouseOverImage(new Image("res/interface/saveExitMouseOver.png"));
-		exitGameButton.add(new ButtonAction(){
+		exitGameButton.add(new BasicButton.ButtonAction(){
 			public void perform(){
 				((GameContainer)gc).exit();	
 			}	
diff --git a/Version 1.1/NewestVersion/src/managers/MonsterManager.java b/Version 1.1/NewestVersion/src/managers/MonsterManager.java
index b23e495..8811653 100644
--- a/Version 1.1/NewestVersion/src/managers/MonsterManager.java	
+++ b/Version 1.1/NewestVersion/src/managers/MonsterManager.java	
@@ -231,7 +231,7 @@ public class MonsterManager {
 			if (newMonsterXPositions[i] == 0 && newMonsterYPositions[i] == 0)
 				break;
 			monster = new BasicMonster(currentMap, basicMonsterAnimation, basicMonsterImage, newMonsterXPositions[i], newMonsterYPositions[i]);
-			monster.setHealthPoints(newMonsterHealths[i]);
+			monster.addHealthPoints(newMonsterHealths[i]);
 			monster.setPath(newMonsterXPositions[i], newMonsterXPositions[i]+3*BasicMap.TILESIZE);
 			newEntityArray[monster.getPosition()[0]/BasicMap.TILESIZE]
 			     	   [monster.getPosition()[1]/BasicMap.TILESIZE] = monster.getName();

commit 54800babdc840a5147df239298f47aac976e282f
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 12:05:46 2017 -0600

    All tests pass extraction

diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class
index aeb49be..74554ff 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class and b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class differ
diff --git a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java
index 00a00f3..e1991f1 100644
--- a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
+++ b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
@@ -136,7 +136,7 @@ public class BasicMonster extends Entity{
 		
 		isActiveState = search("P");
 		if (isActiveState || (isAttacked&&!isActiveState)){
-			findClosestSpot(playerPosition);
+			updatePosition(MapSpotCalculator.findClosestSpot(map,playerPosition,this)[0], MapSpotCalculator.findClosestSpot(map,playerPosition,this)[1]);
 		}
 		else{
 			wander(playerPosition);
@@ -198,16 +198,7 @@ public class BasicMonster extends Entity{
 	else
 		counter++;
 	}
-	
-	//Used to find closestSpot near the player
-	public void findClosestSpot(int[] player)
-	{
-		int[] newPosition = MapSpotCalculator.findClosestSpot(map, player, this);
-		updatePosition(newPosition[0],newPosition[1]);
 		
-	}			
-
-	
 	
 
 }

commit 771418902122a50914220634c85a2be293e58647
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 12:03:03 2017 -0600

    Replacing original method with extracted method

diff --git a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java
index 7072ccb..00a00f3 100644
--- a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
+++ b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
@@ -205,20 +205,6 @@ public class BasicMonster extends Entity{
 		int[] newPosition = MapSpotCalculator.findClosestSpot(map, player, this);
 		updatePosition(newPosition[0],newPosition[1]);
 		
-	/*	if (x == player[0]&& y!= player[1]){
-			int[] newPosition = MapSpotCalculator.closestSpotHorizontal(map, player, this);
-			updatePosition(newPosition[0],newPosition[1]);				
-			}
-		else if (y == player[1]&& x != player[0])
-		{
-			int[] newPosition = MapSpotCalculator.closestSpotVertical(map, player, this);
-			updatePosition(newPosition[0],newPosition[1]);				
-		}
-		else if (y!= player[1]&& x!= player[0])
-		{
-			int[] newPosition = MapSpotCalculator.closestSpotDiagonal(map, player, this);
-			updatePosition(newPosition[0],newPosition[1]);
-		}*/
 	}			
 
 	

commit 581789ff2e90ccf589fe17d9154c81faf4317e4c
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 12:02:24 2017 -0600

    All tests pass

diff --git a/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class b/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class
index 04f229e..97f9ea6 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class and b/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class
index a594613..aeb49be 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class and b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class differ

commit 16d07e8e01dbc240b093afd36474fd056fe77242
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 12:02:09 2017 -0600

    Extracted getClosestPosition

diff --git a/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java b/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java
index fb073f3..b0dd154 100644
--- a/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java	
+++ b/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java	
@@ -4,6 +4,34 @@ import monsterRelated.Entity;
 
 public class MapSpotCalculator {
 	
+	public static int[] findClosestSpot(BasicMap map, int[] player, Entity entity)
+	{
+		int x = entity.getPosition()[0];
+		int y = entity.getPosition()[1];
+		
+		int newX = 0;
+		int newY = 0;
+		
+		int[] foundPosition = new int[] {-1,-1};
+
+		if (x == player[0]&& y!= player[1]){
+			int[] newPosition = MapSpotCalculator.closestSpotHorizontal(map, player, entity);
+			foundPosition = new int[] {newPosition[0],newPosition[1]};				
+			}
+		else if (y == player[1]&& x != player[0])
+		{
+			int[] newPosition = MapSpotCalculator.closestSpotVertical(map, player, entity);
+			foundPosition=new int[]{newPosition[0],newPosition[1]};				
+		}
+		else if (y!= player[1]&& x!= player[0])
+		{
+			int[] newPosition = MapSpotCalculator.closestSpotDiagonal(map, player, entity);
+			foundPosition=new int[]{newPosition[0],newPosition[1]};
+		}
+		return foundPosition;
+	}
+	
+	
 	//Finds closest diagonal spots towards player
 	public static int[] closestSpotDiagonal(BasicMap map, int [] player,Entity entity)
 	{
diff --git a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java
index 7ad0dcb..7072ccb 100644
--- a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
+++ b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
@@ -202,7 +202,10 @@ public class BasicMonster extends Entity{
 	//Used to find closestSpot near the player
 	public void findClosestSpot(int[] player)
 	{
-		if (x == player[0]&& y!= player[1]){
+		int[] newPosition = MapSpotCalculator.findClosestSpot(map, player, this);
+		updatePosition(newPosition[0],newPosition[1]);
+		
+	/*	if (x == player[0]&& y!= player[1]){
 			int[] newPosition = MapSpotCalculator.closestSpotHorizontal(map, player, this);
 			updatePosition(newPosition[0],newPosition[1]);				
 			}
@@ -215,7 +218,7 @@ public class BasicMonster extends Entity{
 		{
 			int[] newPosition = MapSpotCalculator.closestSpotDiagonal(map, player, this);
 			updatePosition(newPosition[0],newPosition[1]);
-		}
+		}*/
 	}			
 
 	

commit 343666c5d7510c72ddf783f85f6a9beafdb582db
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 11:58:04 2017 -0600

    All tests pass

diff --git a/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class b/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class
index 2fe47e3..04f229e 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class and b/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class
index 5682fa7..a594613 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class and b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class differ
diff --git a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java
index d65f621..7ad0dcb 100644
--- a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
+++ b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
@@ -202,20 +202,18 @@ public class BasicMonster extends Entity{
 	//Used to find closestSpot near the player
 	public void findClosestSpot(int[] player)
 	{
-		int newX = 0;
-		int newY = 0;
 		if (x == player[0]&& y!= player[1]){
-			int[] newPosition = MapSpotCalculator.closestSpotHorizontal(map, player, this, new int[] {newX,newY});
+			int[] newPosition = MapSpotCalculator.closestSpotHorizontal(map, player, this);
 			updatePosition(newPosition[0],newPosition[1]);				
 			}
 		else if (y == player[1]&& x != player[0])
 		{
-			int[] newPosition = MapSpotCalculator.closestSpotVertical(map, player, this, new int[] {newX,newY});
+			int[] newPosition = MapSpotCalculator.closestSpotVertical(map, player, this);
 			updatePosition(newPosition[0],newPosition[1]);				
 		}
 		else if (y!= player[1]&& x!= player[0])
 		{
-			int[] newPosition = MapSpotCalculator.closestSpotDiagonal(map, player, this, new int[] {newX,newY});
+			int[] newPosition = MapSpotCalculator.closestSpotDiagonal(map, player, this);
 			updatePosition(newPosition[0],newPosition[1]);
 		}
 	}			

commit 49733421625e4a0029627e010571744cab9dc0b7
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 11:57:17 2017 -0600

    Removed Unused variables

diff --git a/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java b/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java
index 4b06ae4..fb073f3 100644
--- a/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java	
+++ b/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java	
@@ -3,8 +3,6 @@ package mapRelated;
 import monsterRelated.Entity;
 
 public class MapSpotCalculator {
-
-	
 	
 	//Finds closest diagonal spots towards player
 	public static int[] closestSpotDiagonal(BasicMap map, int [] player,Entity entity)
@@ -57,7 +55,6 @@ public class MapSpotCalculator {
 			int x = entity.getPosition()[0];
 			int y = entity.getPosition()[1];
 			
-			int newX = 0;
 			int newY = 0;
 			if (player[1] > y)
 				newY = y + BasicMap.TILESIZE;
@@ -78,7 +75,6 @@ public class MapSpotCalculator {
 		int y = entity.getPosition()[1];
 		
 		int newX = 0;
-		int newY = 0;
 		
 		if (player[0] > x)
 			newX = x + BasicMap.TILESIZE;

commit 0ee6bccb35be8975aa54e2a8bf44cac768e64d24
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 11:55:37 2017 -0600

    Removed Parameter Method Used

diff --git a/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java b/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java
index 9471cfc..4b06ae4 100644
--- a/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java	
+++ b/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java	
@@ -7,13 +7,13 @@ public class MapSpotCalculator {
 	
 	
 	//Finds closest diagonal spots towards player
-	public static int[] closestSpotDiagonal(BasicMap map, int [] player,Entity entity , int[] newPosition)
+	public static int[] closestSpotDiagonal(BasicMap map, int [] player,Entity entity)
 	{
 		int x = entity.getPosition()[0];
 		int y = entity.getPosition()[1];
 		
-		int newX = newPosition[0];
-		int newY = newPosition[1];
+		int newX = 0;
+		int newY = 0;
 		
 		int[] foundPosition = new int[] {-1,-1};
 		
@@ -50,15 +50,15 @@ public class MapSpotCalculator {
 	}
 
 	//Finds closest horizontal spots towards player
-	public static int[] closestSpotHorizontal(BasicMap map, int [] player,Entity entity , int[] newPosition) 
+	public static int[] closestSpotHorizontal(BasicMap map, int [] player,Entity entity) 
 	{
 			int[] foundPosition = new int[] {-1,-1};
 		
 			int x = entity.getPosition()[0];
 			int y = entity.getPosition()[1];
 			
-			int newX = newPosition[0];
-			int newY = newPosition[1];
+			int newX = 0;
+			int newY = 0;
 			if (player[1] > y)
 				newY = y + BasicMap.TILESIZE;
 			else
@@ -71,14 +71,14 @@ public class MapSpotCalculator {
 	}
 	
 	//Finds closest vertical spots towards player
-	public static int[] closestSpotVertical(BasicMap map, int [] player,Entity entity , int[] newPosition) {
+	public static int[] closestSpotVertical(BasicMap map, int [] player,Entity entity) {
 		int[] foundPosition = new int[] {-1,-1};
 	
 		int x = entity.getPosition()[0];
 		int y = entity.getPosition()[1];
 		
-		int newX = newPosition[0];
-		int newY = newPosition[1];
+		int newX = 0;
+		int newY = 0;
 		
 		if (player[0] > x)
 			newX = x + BasicMap.TILESIZE;

commit da4ed66c434c7db5be7193cc271dcd07cfb0dc67
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 11:49:43 2017 -0600

    Finished extracting closestSpotVertical. All tests passed

diff --git a/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class b/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class
index 240f071..2fe47e3 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class and b/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class
index 215d5f1..5682fa7 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class and b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class differ
diff --git a/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java b/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java
index 46d5786..9471cfc 100644
--- a/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java	
+++ b/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java	
@@ -69,4 +69,27 @@ public class MapSpotCalculator {
 			
 			return foundPosition;
 	}
+	
+	//Finds closest vertical spots towards player
+	public static int[] closestSpotVertical(BasicMap map, int [] player,Entity entity , int[] newPosition) {
+		int[] foundPosition = new int[] {-1,-1};
+	
+		int x = entity.getPosition()[0];
+		int y = entity.getPosition()[1];
+		
+		int newX = newPosition[0];
+		int newY = newPosition[1];
+		
+		if (player[0] > x)
+			newX = x + BasicMap.TILESIZE;
+		else
+			newX = x - BasicMap.TILESIZE;
+		
+		if (!entity.isTaken(newX,y)&&!map.hasCollision(newX, y))
+			{
+			foundPosition = new int[]{newX,y};
+			}
+		return foundPosition;
+	}
+
 }
diff --git a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java
index ebc8c7b..d65f621 100644
--- a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
+++ b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
@@ -177,7 +177,7 @@ public class BasicMonster extends Entity{
 			updatePosition(newX1,y);
 			x = newX1;
 			
-			}
+		}
 		//move leftwards
 		else if (direction == 'L' &&!isTaken(newX2,y)){
 				if (map.hasCollision(newX2, y))
@@ -199,7 +199,6 @@ public class BasicMonster extends Entity{
 		counter++;
 	}
 	
-		
 	//Used to find closestSpot near the player
 	public void findClosestSpot(int[] player)
 	{
@@ -209,41 +208,21 @@ public class BasicMonster extends Entity{
 			int[] newPosition = MapSpotCalculator.closestSpotHorizontal(map, player, this, new int[] {newX,newY});
 			updatePosition(newPosition[0],newPosition[1]);				
 			}
-			
 		else if (y == player[1]&& x != player[0])
 		{
-			closestSpotVertical(player,newX, newY);
+			int[] newPosition = MapSpotCalculator.closestSpotVertical(map, player, this, new int[] {newX,newY});
+			updatePosition(newPosition[0],newPosition[1]);				
 		}
 		else if (y!= player[1]&& x!= player[0])
 		{
 			int[] newPosition = MapSpotCalculator.closestSpotDiagonal(map, player, this, new int[] {newX,newY});
 			updatePosition(newPosition[0],newPosition[1]);
 		}
-	}	
-	
-	
-	
+	}			
 
 	
 	
 
-	//Finds closest vertical spots towards player
-	private void closestSpotVertical(int [] player, int newX, int newY){
-		
-		if (player[0] > x)
-			newX = x + BasicMap.TILESIZE;
-		else
-			newX = x - BasicMap.TILESIZE;
-		
-		if (!isTaken(newX,y)&&!map.hasCollision(newX, y))
-			{
-			updatePosition(newX,y);
-			x = newX;
-			}
-	}
-	
-	
-
 }
 
 	

commit 2d869f97e76c2bbbfe3697f325bbd504ebe70826
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 11:40:55 2017 -0600

    Extracted find closestSpotHorizontal. All tests in BasicMonster for findClosestSpotHorizontal passed

diff --git a/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class b/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class
index 07bc574..240f071 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class and b/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class
index 5345f65..215d5f1 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class and b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class differ
diff --git a/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java b/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java
index 03779e4..46d5786 100644
--- a/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java	
+++ b/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java	
@@ -49,6 +49,24 @@ public class MapSpotCalculator {
 		return foundPosition;
 	}
 
-	
-	
+	//Finds closest horizontal spots towards player
+	public static int[] closestSpotHorizontal(BasicMap map, int [] player,Entity entity , int[] newPosition) 
+	{
+			int[] foundPosition = new int[] {-1,-1};
+		
+			int x = entity.getPosition()[0];
+			int y = entity.getPosition()[1];
+			
+			int newX = newPosition[0];
+			int newY = newPosition[1];
+			if (player[1] > y)
+				newY = y + BasicMap.TILESIZE;
+			else
+				newY = y - BasicMap.TILESIZE;
+			
+			if (!entity.isTaken(x,newY)&&!map.hasCollision(x,newY))
+				foundPosition = new int[]{x,newY};
+			
+			return foundPosition;
+	}
 }
diff --git a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java
index 76a3878..ebc8c7b 100644
--- a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
+++ b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
@@ -206,7 +206,8 @@ public class BasicMonster extends Entity{
 		int newX = 0;
 		int newY = 0;
 		if (x == player[0]&& y!= player[1]){
-				closestSpotHorizontal (player, newX, newY);
+			int[] newPosition = MapSpotCalculator.closestSpotHorizontal(map, player, this, new int[] {newX,newY});
+			updatePosition(newPosition[0],newPosition[1]);				
 			}
 			
 		else if (y == player[1]&& x != player[0])
@@ -223,19 +224,6 @@ public class BasicMonster extends Entity{
 	
 	
 
-	//Finds closest horizontal spots towards player
-	private void closestSpotHorizontal(int [] player, int newX, int newY){
-		if (player[1] > y)
-			newY = y + BasicMap.TILESIZE;
-		else
-			newY = y - BasicMap.TILESIZE;
-		
-		if (!isTaken(x,newY)&&!map.hasCollision(x,newY))
-			{		
-			updatePosition(x,newY);
-			y = newY;
-			}
-	}
 	
 	
 

commit 0dca5d402157b425f2b32341e01d45c8f0e38903
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 11:35:44 2017 -0600

    All tests in BasicMonster find diagonal passed

diff --git a/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class b/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class
index 0cbab7a..4dd5075 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class and b/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class b/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class
index 978d06e..61535aa 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class and b/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class b/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class
new file mode 100644
index 0000000..07bc574
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/mapRelated/MapSpotCalculator.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class
index 61332f5..5345f65 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class and b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class differ
diff --git a/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java b/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java
index c968277..03779e4 100644
--- a/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java	
+++ b/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java	
@@ -1,11 +1,13 @@
 package mapRelated;
 
+import monsterRelated.Entity;
+
 public class MapSpotCalculator {
 
 	
 	
 	//Finds closest diagonal spots towards player
-	public int[] closestSpotDiagonal(BasicMap map, int [] player,Entity entity , int[] newPosition)
+	public static int[] closestSpotDiagonal(BasicMap map, int [] player,Entity entity , int[] newPosition)
 	{
 		int x = entity.getPosition()[0];
 		int y = entity.getPosition()[1];
@@ -13,7 +15,7 @@ public class MapSpotCalculator {
 		int newX = newPosition[0];
 		int newY = newPosition[1];
 		
-		int[] foundPosition;
+		int[] foundPosition = new int[] {-1,-1};
 		
 		if (y > player[1])
 			newY = y - BasicMap.TILESIZE;
@@ -42,7 +44,7 @@ public class MapSpotCalculator {
 				{
 			foundPosition =  new int[] {newX, y};
 				x = newX;
-				}		
+				}	
 		
 		return foundPosition;
 	}
diff --git a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java
index abc1978..76a3878 100644
--- a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
+++ b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
@@ -2,6 +2,7 @@ package monsterRelated;
 
 
 import mapRelated.BasicMap;
+import mapRelated.MapSpotCalculator;
 
 import org.newdawn.slick.Animation;
 import org.newdawn.slick.Graphics;
@@ -214,9 +215,9 @@ public class BasicMonster extends Entity{
 		}
 		else if (y!= player[1]&& x!= player[0])
 		{
-			closestSpotDiagonal(player,newX, newY);
-				
-		    }
+			int[] newPosition = MapSpotCalculator.closestSpotDiagonal(map, player, this, new int[] {newX,newY});
+			updatePosition(newPosition[0],newPosition[1]);
+		}
 	}	
 	
 	

commit dff0bb106bbc79d18e2503e10c144319f886c166
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 11:31:35 2017 -0600

    Ran into difficult bug. To optimize time. Refactoring Basic Monster Method Map Calculations first. Started moving findClosestSpotDiagonal

diff --git a/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java b/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java
new file mode 100644
index 0000000..c968277
--- /dev/null
+++ b/Version 1.1/NewestVersion/src/mapRelated/MapSpotCalculator.java	
@@ -0,0 +1,52 @@
+package mapRelated;
+
+public class MapSpotCalculator {
+
+	
+	
+	//Finds closest diagonal spots towards player
+	public int[] closestSpotDiagonal(BasicMap map, int [] player,Entity entity , int[] newPosition)
+	{
+		int x = entity.getPosition()[0];
+		int y = entity.getPosition()[1];
+		
+		int newX = newPosition[0];
+		int newY = newPosition[1];
+		
+		int[] foundPosition;
+		
+		if (y > player[1])
+			newY = y - BasicMap.TILESIZE;
+		else
+			newY = y + BasicMap.TILESIZE;
+		
+		if (x > player [0])
+			newX = x - BasicMap.TILESIZE;
+		else
+			newX = x + BasicMap.TILESIZE;		
+		
+		if (!entity.isTaken(newX, newY) && !map.hasCollision(newX, newY))
+				{
+				foundPosition = new int[] {newX,newY};
+				x = newX;
+				y = newY;
+				}
+		
+		else if (!entity.isTaken(x, newY) && !map.hasCollision(x, newY))
+				{
+			foundPosition =  new int[]{x,newY};
+				y = newY;
+			    }
+		
+		else if (!entity.isTaken(newX, y) && !map.hasCollision(newX, y))
+				{
+			foundPosition =  new int[] {newX, y};
+				x = newX;
+				}		
+		
+		return foundPosition;
+	}
+
+	
+	
+}
diff --git a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java
index 2bc546a..abc1978 100644
--- a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
+++ b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
@@ -219,39 +219,6 @@ public class BasicMonster extends Entity{
 		    }
 	}	
 	
-	//Finds closest diagonal spots towards player
-	private void closestSpotDiagonal(int [] player, int newX, int newY)
-	{
-
-		if (y > player[1])
-			newY = y - BasicMap.TILESIZE;
-		else
-			newY = y + BasicMap.TILESIZE;
-		
-		if (x > player [0])
-			newX = x - BasicMap.TILESIZE;
-		else
-			newX = x + BasicMap.TILESIZE;		
-		
-		if (!isTaken(newX, newY) && !map.hasCollision(newX, newY))
-				{
-				updatePosition(newX,newY);
-				x = newX;
-				y = newY;
-				}
-		
-		else if (!isTaken(x, newY) && !map.hasCollision(x, newY))
-				{
-				updatePosition(x,newY);
-				y = newY;
-			    }
-		
-		else if (!isTaken(newX, y) && !map.hasCollision(newX, y))
-				{
-				updatePosition(newX, y);
-				x = newX;
-				}		
-	}
 	
 	
 

commit 7b0f4424a58742bde312201930a917bd313ea498
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 08:45:04 2017 -0600

    Temporarily Move code to a different project to resolve unmatching junit build paths, went back to orignal project after resolution to test code. Changes is the same as last commit

diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/LoadingGame.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/LoadingGame.class
index f37c324..a441085 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/LoadingGame.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/LoadingGame.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class b/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class
index 0d61b9b..0cbab7a 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class and b/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class b/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class
index b5df8db..978d06e 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class and b/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class
index a1b5b3a..e79595c 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class and b/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/BasicMapTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/BasicMapTest.class
index 40e5504..faca43f 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/testRelated/BasicMapTest.class and b/VERSION W.I.P/version w.i.p/bin/testRelated/BasicMapTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/BasicMonsterTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/BasicMonsterTest.class
index dc9de7b..5ec30c2 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/testRelated/BasicMonsterTest.class and b/VERSION W.I.P/version w.i.p/bin/testRelated/BasicMonsterTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/CombatManagerTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/CombatManagerTest.class
index b7f3822..dfe3421 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/testRelated/CombatManagerTest.class and b/VERSION W.I.P/version w.i.p/bin/testRelated/CombatManagerTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/EntityTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/EntityTest.class
index 7727656..7f81d9a 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/testRelated/EntityTest.class and b/VERSION W.I.P/version w.i.p/bin/testRelated/EntityTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/GameScreenAssetsTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/GameScreenAssetsTest.class
index 32bd34a..7a5d994 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/testRelated/GameScreenAssetsTest.class and b/VERSION W.I.P/version w.i.p/bin/testRelated/GameScreenAssetsTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/LoadingGameTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/LoadingGameTest.class
index 668b318..f96e9ed 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/testRelated/LoadingGameTest.class and b/VERSION W.I.P/version w.i.p/bin/testRelated/LoadingGameTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/MonsterManagerTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/MonsterManagerTest.class
index 3643e58..2241fd4 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/testRelated/MonsterManagerTest.class and b/VERSION W.I.P/version w.i.p/bin/testRelated/MonsterManagerTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class
index d33566c..a63590e 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class and b/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class differ
diff --git a/Version 1.1/NewestVersion/src/inputRelated/LoadingGame.java b/Version 1.1/NewestVersion/src/inputRelated/LoadingGame.java
index 7430510..878b795 100644
--- a/Version 1.1/NewestVersion/src/inputRelated/LoadingGame.java	
+++ b/Version 1.1/NewestVersion/src/inputRelated/LoadingGame.java	
@@ -79,9 +79,11 @@ public class LoadingGame {
 		//Set floor level
 		gameAssets.setFloorLevel(readFloor);
 		//Set current map
-		for (int i = readFloor - 1;i != 0;i--)
-		{
-			changeMap = xTotalLevels.removeLast();
+		if (xTotalLevels.toArray().length>0) {
+			for (int i = readFloor - 1;i != 0;i--)
+			{
+				changeMap = xTotalLevels.removeLast();
+			}			
 		}
 		//Set player related data
 		player.loadStats(readPlayerLevel, readPlayerExp, readPlayerHealth);
diff --git a/Version 1.1/NewestVersion/src/managers/CombatManager.java b/Version 1.1/NewestVersion/src/managers/CombatManager.java
index ea65f52..23724fc 100644
--- a/Version 1.1/NewestVersion/src/managers/CombatManager.java	
+++ b/Version 1.1/NewestVersion/src/managers/CombatManager.java	
@@ -63,7 +63,7 @@ public class CombatManager {
 		{
 		
 		GameScreenAssets.queueTextLog.addFirst("Average Hit: "+attack);
-		SoundManager.playSoundEffect("res/sound/SFX/Sword Swing.wav");
+	//	SoundManager.playSoundEffect("res/sound/SFX/Sword Swing.wav");
 		currentFoe.subtractHealth(attack);
 		currentFoe.setIsAttacked(true);
 			if (currentFoe.getHealthPoints() <= 0)
diff --git a/Version 1.1/NewestVersion/src/managers/MonsterManager.java b/Version 1.1/NewestVersion/src/managers/MonsterManager.java
index d1683c1..b23e495 100644
--- a/Version 1.1/NewestVersion/src/managers/MonsterManager.java	
+++ b/Version 1.1/NewestVersion/src/managers/MonsterManager.java	
@@ -143,14 +143,11 @@ public class MonsterManager {
 	
 	// Loads monster Images 
 	private void loadMonsterTypes() throws SlickException{
-		basicMonsterSheet= new SpriteSheet("res/monster/dummySheet.png",BasicMap.TILESIZE,BasicMap.TILESIZE); 
-		basicMonsterImage = basicMonsterSheet.getSubImage(0, 0);
-		Image [] monsterAnim = {basicMonsterSheet.getSubImage(0, 0), basicMonsterSheet.getSubImage(1, 0)};
-		int [] duration = {250,250};
-		basicMonsterAnimation = new Animation(monsterAnim, duration, false);
-		
-		
-		
+//		basicMonsterSheet= new SpriteSheet("res/monster/dummySheet.png",BasicMap.TILESIZE,BasicMap.TILESIZE); 
+//		basicMonsterImage = basicMonsterSheet.getSubImage(0, 0);
+//		Image [] monsterAnim = {basicMonsterSheet.getSubImage(0, 0), basicMonsterSheet.getSubImage(1, 0)};
+//		int [] duration = {250,250};
+//		basicMonsterAnimation = new Animation(monsterAnim, duration, false);	
 	}
 	
 	//Initializes monsters per level
diff --git a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java
index 674460a..2bc546a 100644
--- a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
+++ b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
@@ -84,7 +84,7 @@ public class BasicMonster extends Entity{
 		monsterSightRange = 2;
 		monsterImage = monsterLook;
 		this.monsterAnimation = monsterAnimation;
-		monsterAnimation.setAutoUpdate(true);
+	//	monsterAnimation.setAutoUpdate(true);
 		counter = 0;
 		direction = 'R';
 		maxHealthPoints = 20;
diff --git a/Version 1.1/NewestVersion/src/playerRelated/Player.java b/Version 1.1/NewestVersion/src/playerRelated/Player.java
index 01e1ed5..ddd8e85 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/Player.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/Player.java	
@@ -415,7 +415,7 @@ public class Player extends Entity{
 		if (levelUp())
 		{
 			GameScreenAssets.queueTextLog.add("Woohoo! Player has leveled Up!");
-			SoundManager.playSoundEffect("res/sound/SFX/Level Up Ding.wav");
+	//		SoundManager.playSoundEffect("res/sound/SFX/Level Up Ding.wav");
 			return "Player has leveled up";
 		}
 		return null;
diff --git a/Version 1.1/NewestVersion/src/testRelated/BasicMapTest.java b/Version 1.1/NewestVersion/src/testRelated/BasicMapTest.java
index a733110..ca775de 100644
--- a/Version 1.1/NewestVersion/src/testRelated/BasicMapTest.java	
+++ b/Version 1.1/NewestVersion/src/testRelated/BasicMapTest.java	
@@ -1,4 +1,4 @@
-package test;
+package testRelated;
 
 import static org.junit.Assert.*;
 import mapRelated.BasicMap;
diff --git a/Version 1.1/NewestVersion/src/testRelated/CombatManagerTest.java b/Version 1.1/NewestVersion/src/testRelated/CombatManagerTest.java
index fcddde8..8a62204 100644
--- a/Version 1.1/NewestVersion/src/testRelated/CombatManagerTest.java	
+++ b/Version 1.1/NewestVersion/src/testRelated/CombatManagerTest.java	
@@ -15,7 +15,6 @@ import playerRelated.Player;
 public class CombatManagerTest {
 
 	
-	
 	//Tests when no monster reference is found for combat
 	@Test
 	public void testMonsterRefNotFound(){
diff --git a/Version 1.1/NewestVersion/src/testRelated/GameScreenAssetsTest.java b/Version 1.1/NewestVersion/src/testRelated/GameScreenAssetsTest.java
index b93cd38..dfac0b1 100644
--- a/Version 1.1/NewestVersion/src/testRelated/GameScreenAssetsTest.java	
+++ b/Version 1.1/NewestVersion/src/testRelated/GameScreenAssetsTest.java	
@@ -1,7 +1,6 @@
 package testRelated;
 
 import static org.junit.Assert.*;
-import static org.junit.jupiter.api.Assertions.assertEquals;
 
 import gameStates.GameScreenAssets;
 
diff --git a/Version 1.1/NewestVersion/src/testRelated/LoadingGameTest.java b/Version 1.1/NewestVersion/src/testRelated/LoadingGameTest.java
index f1a77b7..57333f8 100644
--- a/Version 1.1/NewestVersion/src/testRelated/LoadingGameTest.java	
+++ b/Version 1.1/NewestVersion/src/testRelated/LoadingGameTest.java	
@@ -17,10 +17,10 @@ import managers.MonsterManager;
 import mapRelated.BasicMap;
 import playerRelated.Player;
 
-class LoadingGameTest {
+public class LoadingGameTest {
 
 	@Before
-	void writeSaveFile() throws IOException {
+	public void writeSaveFile() throws IOException {
 		FileWriter fw = new FileWriter("save.txt");
 		PrintWriter pw = new PrintWriter(fw);
 		//First Write Floor number. Newline.
@@ -47,7 +47,7 @@ class LoadingGameTest {
 	
 	
 	@Test
-	void testNotNullLoadedMap() throws SlickException{
+	public void testNotNullLoadedMap() throws SlickException{
 	
 		//Arrange
 		BasicMap mapToTest = new BasicMap();
diff --git a/save.txt b/save.txt
new file mode 100644
index 0000000..14e7945
--- /dev/null
+++ b/save.txt
@@ -0,0 +1,9 @@
+4
+12
+10
+2
+12
+10
+2
+6
+1

commit e67301a6a3f3e880e02105d4439a54601e201441
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 08:38:10 2017 -0600

    Commented out all Resource/Asset dependent errors like sound files and sprite sheets to get test to pass

diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/Game.class b/VERSION W.I.P/version w.i.p/bin/gameStates/Game1.class
similarity index 93%
rename from VERSION W.I.P/version w.i.p/bin/gameStates/Game.class
rename to VERSION W.I.P/version w.i.p/bin/gameStates/Game1.class
index 3ece979..0ddf52c 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/Game.class and b/VERSION W.I.P/version w.i.p/bin/gameStates/Game1.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets1.class b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets1.class
new file mode 100644
index 0000000..64663f7
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets1.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssetsTest.class b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssetsTest.class
deleted file mode 100644
index 29ae901..0000000
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssetsTest.class and /dev/null differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssetsTest1.class b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssetsTest1.class
new file mode 100644
index 0000000..1751744
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssetsTest1.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/managers/CombatManagerTest.class b/VERSION W.I.P/version w.i.p/bin/managers/CombatManagerTest.class
index 5c8e058..930648f 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/managers/CombatManagerTest.class and b/VERSION W.I.P/version w.i.p/bin/managers/CombatManagerTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/managers/MonsterManagerTest.class b/VERSION W.I.P/version w.i.p/bin/managers/MonsterManagerTest.class
index 2cc2eeb..5d0bab2 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/managers/MonsterManagerTest.class and b/VERSION W.I.P/version w.i.p/bin/managers/MonsterManagerTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMapTest.class b/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMapTest.class
index 674317e..c56422b 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMapTest.class and b/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMapTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonsterTest.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonsterTest.class
index e67bec0..f4513cd 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonsterTest.class and b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonsterTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/EntityTest.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/EntityTest.class
index a347eda..cfe0fc3 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/EntityTest.class and b/VERSION W.I.P/version w.i.p/bin/monsterRelated/EntityTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerTest.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerTest.class
index 037032c..20c2511 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerTest.class and b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/test/BasicMapTest.class b/VERSION W.I.P/version w.i.p/bin/test/BasicMapTest.class
deleted file mode 100644
index 57bc76f..0000000
Binary files a/VERSION W.I.P/version w.i.p/bin/test/BasicMapTest.class and /dev/null differ
diff --git a/VERSION W.I.P/version w.i.p/bin/test/BasicMonsterTest.class b/VERSION W.I.P/version w.i.p/bin/test/BasicMonsterTest.class
deleted file mode 100644
index 0f3f722..0000000
Binary files a/VERSION W.I.P/version w.i.p/bin/test/BasicMonsterTest.class and /dev/null differ
diff --git a/VERSION W.I.P/version w.i.p/bin/test/CombatManagerTest.class b/VERSION W.I.P/version w.i.p/bin/test/CombatManagerTest.class
deleted file mode 100644
index f3cc01e..0000000
Binary files a/VERSION W.I.P/version w.i.p/bin/test/CombatManagerTest.class and /dev/null differ
diff --git a/VERSION W.I.P/version w.i.p/bin/test/EntityTest.class b/VERSION W.I.P/version w.i.p/bin/test/EntityTest.class
deleted file mode 100644
index 74c8791..0000000
Binary files a/VERSION W.I.P/version w.i.p/bin/test/EntityTest.class and /dev/null differ
diff --git a/VERSION W.I.P/version w.i.p/bin/test/GameScreenAssetsTest.class b/VERSION W.I.P/version w.i.p/bin/test/GameScreenAssetsTest.class
deleted file mode 100644
index 95b98d4..0000000
Binary files a/VERSION W.I.P/version w.i.p/bin/test/GameScreenAssetsTest.class and /dev/null differ
diff --git a/VERSION W.I.P/version w.i.p/bin/test/LoadingGameTest.class b/VERSION W.I.P/version w.i.p/bin/test/LoadingGameTest.class
deleted file mode 100644
index 5785f7c..0000000
Binary files a/VERSION W.I.P/version w.i.p/bin/test/LoadingGameTest.class and /dev/null differ
diff --git a/VERSION W.I.P/version w.i.p/bin/test/MonsterManagerTest.class b/VERSION W.I.P/version w.i.p/bin/test/MonsterManagerTest.class
deleted file mode 100644
index 272608c..0000000
Binary files a/VERSION W.I.P/version w.i.p/bin/test/MonsterManagerTest.class and /dev/null differ
diff --git a/VERSION W.I.P/version w.i.p/bin/test/PlayerTest.class b/VERSION W.I.P/version w.i.p/bin/test/PlayerTest.class
deleted file mode 100644
index 62604c3..0000000
Binary files a/VERSION W.I.P/version w.i.p/bin/test/PlayerTest.class and /dev/null differ
diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/BasicMapTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/BasicMapTest.class
new file mode 100644
index 0000000..40e5504
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/testRelated/BasicMapTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/BasicMonsterTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/BasicMonsterTest.class
new file mode 100644
index 0000000..dc9de7b
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/testRelated/BasicMonsterTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/CombatManagerTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/CombatManagerTest.class
new file mode 100644
index 0000000..b7f3822
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/testRelated/CombatManagerTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/EntityTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/EntityTest.class
new file mode 100644
index 0000000..7727656
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/testRelated/EntityTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/GameScreenAssetsTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/GameScreenAssetsTest.class
new file mode 100644
index 0000000..32bd34a
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/testRelated/GameScreenAssetsTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/LoadingGameTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/LoadingGameTest.class
new file mode 100644
index 0000000..668b318
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/testRelated/LoadingGameTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/MonsterManagerTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/MonsterManagerTest.class
new file mode 100644
index 0000000..3643e58
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/testRelated/MonsterManagerTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class b/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class
new file mode 100644
index 0000000..d33566c
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/testRelated/PlayerTest.class differ
diff --git a/Version 1.1/NewestVersion/src/testRelated/BasicMonsterTest.java b/Version 1.1/NewestVersion/src/testRelated/BasicMonsterTest.java
index f0d639d..e87701f 100644
--- a/Version 1.1/NewestVersion/src/testRelated/BasicMonsterTest.java	
+++ b/Version 1.1/NewestVersion/src/testRelated/BasicMonsterTest.java	
@@ -1,4 +1,4 @@
-package test;
+package testRelated;
 
 import static org.junit.Assert.*;
 import mapRelated.BasicMap;
diff --git a/Version 1.1/NewestVersion/src/testRelated/CombatManagerTest.java b/Version 1.1/NewestVersion/src/testRelated/CombatManagerTest.java
index e397425..fcddde8 100644
--- a/Version 1.1/NewestVersion/src/testRelated/CombatManagerTest.java	
+++ b/Version 1.1/NewestVersion/src/testRelated/CombatManagerTest.java	
@@ -1,4 +1,4 @@
-package test;
+package testRelated;
 
 import static org.junit.Assert.assertEquals;
 
diff --git a/Version 1.1/NewestVersion/src/testRelated/EntityTest.java b/Version 1.1/NewestVersion/src/testRelated/EntityTest.java
index 5f95f13..0822df1 100644
--- a/Version 1.1/NewestVersion/src/testRelated/EntityTest.java	
+++ b/Version 1.1/NewestVersion/src/testRelated/EntityTest.java	
@@ -1,4 +1,4 @@
-package test;
+package testRelated;
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
diff --git a/Version 1.1/NewestVersion/src/testRelated/GameScreenAssetsTest.java b/Version 1.1/NewestVersion/src/testRelated/GameScreenAssetsTest.java
index 33905ae..b93cd38 100644
--- a/Version 1.1/NewestVersion/src/testRelated/GameScreenAssetsTest.java	
+++ b/Version 1.1/NewestVersion/src/testRelated/GameScreenAssetsTest.java	
@@ -1,4 +1,4 @@
-package test;
+package testRelated;
 
 import static org.junit.Assert.*;
 import static org.junit.jupiter.api.Assertions.assertEquals;
diff --git a/Version 1.1/NewestVersion/src/testRelated/LoadingGameTest.java b/Version 1.1/NewestVersion/src/testRelated/LoadingGameTest.java
new file mode 100644
index 0000000..f1a77b7
--- /dev/null
+++ b/Version 1.1/NewestVersion/src/testRelated/LoadingGameTest.java	
@@ -0,0 +1,68 @@
+package testRelated;
+
+import static org.junit.Assert.assertNotNull;
+
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.LinkedList;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.newdawn.slick.SlickException;
+
+import gameStates.GameScreenAssets;
+import inputRelated.LoadingGame;
+import managers.MonsterManager;
+import mapRelated.BasicMap;
+import playerRelated.Player;
+
+class LoadingGameTest {
+
+	@Before
+	void writeSaveFile() throws IOException {
+		FileWriter fw = new FileWriter("save.txt");
+		PrintWriter pw = new PrintWriter(fw);
+		//First Write Floor number. Newline.
+		pw.println(4);
+		//Player position. new line
+		pw.println(12);
+		pw.println(10);
+		//Player level
+		pw.println(2);
+		//Player experience points. new line
+		pw.println(12);
+		//Player health points. new line.
+		pw.println(10);
+		
+		//Start loop for saving monster info
+	    //Write monster x-coordinate and y-coordinate
+	    pw.println(2);
+	    pw.println(6);
+	    //Write monster health
+	    pw.println(1);
+		pw.close();
+		fw.close();
+	}
+	
+	
+	@Test
+	void testNotNullLoadedMap() throws SlickException{
+	
+		//Arrange
+		BasicMap mapToTest = new BasicMap();
+		GameScreenAssets gameAssets = new GameScreenAssets();
+		LinkedList<BasicMap> totalLevels = new LinkedList<BasicMap>();
+		MonsterManager monsters = new MonsterManager(mapToTest);
+		Player player = new Player(4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, mapToTest);		
+		String[][] entityArray =  new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		//Act 
+		mapToTest = LoadingGame.initLoadingGame(gameAssets, mapToTest, totalLevels, player, monsters, entityArray);
+		
+		
+		//Assert
+		assertNotNull("Failed to load Map", mapToTest);
+	}
+
+}
diff --git a/Version 1.1/NewestVersion/src/testRelated/MonsterManagerTest.java b/Version 1.1/NewestVersion/src/testRelated/MonsterManagerTest.java
index c749c92..f8fb3ef 100644
--- a/Version 1.1/NewestVersion/src/testRelated/MonsterManagerTest.java	
+++ b/Version 1.1/NewestVersion/src/testRelated/MonsterManagerTest.java	
@@ -1,5 +1,4 @@
-package test;
-
+package testRelated;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
diff --git a/Version 1.1/NewestVersion/src/testRelated/PlayerTest.java b/Version 1.1/NewestVersion/src/testRelated/PlayerTest.java
index af95366..345adc7 100644
--- a/Version 1.1/NewestVersion/src/testRelated/PlayerTest.java	
+++ b/Version 1.1/NewestVersion/src/testRelated/PlayerTest.java	
@@ -1,4 +1,4 @@
-package test;
+package testRelated;
 
 import static org.junit.Assert.*;
 
diff --git a/src/gameStates/GameOverScreen.java b/src/gameStates/GameOverScreen.java
new file mode 100644
index 0000000..09d9a11
--- /dev/null
+++ b/src/gameStates/GameOverScreen.java
@@ -0,0 +1,118 @@
+package gameStates;
+
+import inputRelated.EndGameButtons;
+
+import java.awt.Font;
+import java.io.File;
+
+import managers.SoundManager;
+
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.Input;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.TrueTypeFont;
+import org.newdawn.slick.state.BasicGameState;
+import org.newdawn.slick.state.StateBasedGame;
+
+
+///////////////////////////////////////////////////
+//GameOver										 //							
+//Purpose: Controls the game over state. 		 //
+//This occurs when the player character has died //
+//Limit: Current does not restart game	         //
+///////////////////////////////////////////////////
+
+public class GameOverScreen extends BasicGameState{
+	
+	//Game Over Screen Font
+	private TrueTypeFont font;
+	
+	//Game Over State
+	public static int ID = 3;
+	
+	//Game container is used to shut down program
+	private GameContainer gc;
+	
+	private Image skull;
+	private EndGameButtons buttons;
+	
+	//Initialize Game Over State
+	//Runs at the beginning of the program
+	@Override
+	public void init(GameContainer gc, StateBasedGame sbg)
+			throws SlickException {
+	    // load a default java font
+		this.gc = gc;
+	    Font awtFont = new Font("Times New Roman", Font.BOLD, 50);
+	    font = new TrueTypeFont(awtFont, false);
+	    skull = new Image ("res/interface/skull.png");
+	    buttons = new EndGameButtons(gc, sbg, GameOverScreen.ID);
+	}
+	
+	//Method runs every time this state is entered
+	@Override
+	public void enter(GameContainer gc, StateBasedGame sbg){
+		//Delete saved games when player loses
+		try{
+			 
+    		File file = new File("save.txt");
+ 
+    		if(file.delete()){
+    			System.out.println(file.getName() + " is deleted!");
+    		}else{
+    			System.out.println("Delete operation is failed.");
+    		}
+    	}catch(Exception e){
+ 
+    		e.printStackTrace();
+    	}
+		//Load State's music 
+		SoundManager.changeSound("res/sound/A Time To Lose.wav");
+		
+		//Reset loadedGame/Win values
+		GameScreen.setWin(false);
+		GameScreen.setLoadedGame(false);
+		}
+
+	
+	// Displays the game over screen
+	@Override
+	public void render(GameContainer gc, StateBasedGame sbg, Graphics graphics)
+			throws SlickException {
+		//abstract numbers = x, y
+		skull.draw(330, 100);
+		//abstract numbers = x,y
+		font.drawString(360, 60, "GAME OVER!", Color.red);
+		buttons.render(gc, graphics);
+	}
+
+
+	// Updates the state of the game (the player is now dead)
+	// No images should appear
+	@Override
+	public void update(GameContainer gc, StateBasedGame sbg, int delta)
+			throws SlickException {
+		
+	}
+	
+	// Controls key input in the game over screen
+	@Override
+	public void keyReleased (int key,char c){
+	switch (key){
+	case Input.KEY_Q:
+		gc.exit();//Exits game. 	
+		break;
+		}	
+	}
+
+	//Returns ID of state for state manager that controls
+	//Flow of game
+	@Override
+	public int getID() {
+		return ID;
+	}
+
+}
diff --git a/src/gameStates/GameScreen.java b/src/gameStates/GameScreen.java
new file mode 100644
index 0000000..3be00bb
--- /dev/null
+++ b/src/gameStates/GameScreen.java
@@ -0,0 +1,283 @@
+package gameStates;
+
+import inputRelated.LoadingGame;
+import inputRelated.SavingGame;
+
+import java.util.LinkedList;
+
+import managers.CombatManager;
+import managers.MonsterManager;
+import managers.SoundManager;
+import mapRelated.BasicMap;
+import monsterRelated.Entity;
+
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Input;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.openal.SoundStore;
+import org.newdawn.slick.state.BasicGameState;
+import org.newdawn.slick.state.StateBasedGame;
+import org.newdawn.slick.state.transition.FadeInTransition;
+import org.newdawn.slick.state.transition.FadeOutTransition;
+
+import playerRelated.Player;
+
+//////////////////////////////////////////////
+//Game										//
+//Purpose: Controls all elements in the game//
+//Limit: Works only in SLICK2D API		    //
+//////////////////////////////////////////////
+
+public class GameScreen extends BasicGameState {
+
+	//Used for quitting the game
+	private GameContainer gc;
+	private GameScreenAssets gameAssets;
+	private StateBasedGame sbg;
+	
+	//Entity Stuff
+	private Player player;
+	private String[][] entityArray;
+	
+	//Handles Monsters on screen
+	private MonsterManager monsters;
+	private BasicMap currentMap;
+	
+	//Counter for delaying Text-log and monsters
+	private int textLogCounter = 0;
+	private int monsterCounter = 0; //Must combine later
+
+	//Maps Used Inside Game
+	private BasicMap floorOne;
+	private BasicMap floorTwo;
+	private BasicMap floorThree;
+	private BasicMap floorFour;
+	private BasicMap floorFive;
+	private BasicMap floorSix;
+	private BasicMap floorSeven;
+
+	//Sound Volume
+	private float volume = 1.0f;
+	
+	//Collection of maps for all levels
+	private LinkedList<BasicMap> totalLevels = new LinkedList<BasicMap>();
+	
+	
+	//State ID
+	public static final int ID = 1;
+
+	//Win Game Boolean
+	private static boolean winGame = false;
+	
+	//Loaded Saved Game Boolean
+	private static boolean loadedGame = false;	
+	
+	//Set by the LoadingGame class
+	//Also used by GameOver class
+	public static void setLoadedGame(boolean value){loadedGame =value;}
+	public static void setWin(boolean value) {winGame = value;}
+	
+	//Initialize variables that aren't reliant on it being a new game or an old game
+	@Override
+	public void init(GameContainer gc, StateBasedGame stateGame) throws SlickException {
+		this.gc = gc;
+		this.sbg = stateGame;
+
+		//Load ALL  Maps of game
+		floorOne = new BasicMap("res/map/floor1.tmx");
+		floorTwo = new BasicMap("res/map/floor2.tmx");
+		floorThree = new BasicMap("res/map/floor3.tmx");
+		floorFour = new BasicMap("res/map/floor4.tmx");
+		floorFive = new BasicMap("res/map/floor5.tmx");
+		floorSix = new BasicMap("res/map/floor6.tmx");
+		floorSeven = new BasicMap("res/map/floor7.tmx");
+	
+		//Needed to init totalLevels for usage in loading games
+		totalLevels.add(floorSeven);
+		totalLevels.add(floorSix);
+		totalLevels.add(floorFive);
+        totalLevels.add(floorFour);
+		totalLevels.add(floorThree);
+		totalLevels.add(floorTwo);
+		totalLevels.add(floorOne);
+	}
+	
+	//This method is run when we enter the state not at the start of the program like the init method
+	@Override 
+	public void enter(GameContainer gc, StateBasedGame stateGame) throws SlickException{
+		this.gc = gc;
+		//If new game (from a previously lost game) then clear the totalLevels
+		totalLevels.clear();
+		
+		//Add floors to Linked List, last level first.
+		totalLevels.add(floorSeven);
+		totalLevels.add(floorSix);
+		totalLevels.add(floorFive);
+        totalLevels.add(floorFour);
+		totalLevels.add(floorThree);
+		totalLevels.add(floorTwo);
+		totalLevels.add(floorOne);
+		
+		//Get current map from the end.
+		currentMap = totalLevels.removeLast();
+		
+		
+		//Create player's character 
+		player = new Player(gc, stateGame,currentMap, 4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE);
+		
+		//Place player's character onto map
+		initEntityArray();
+		if (!loadedGame)
+			{
+			entityArray[((Entity)player).getPosition()[0]/BasicMap.TILESIZE][((Entity)player).getPosition()[1]/BasicMap.TILESIZE] = player.getName();
+			}
+		//Update Monster Manager with currentMap
+		monsters = new MonsterManager(currentMap);
+		//Spawn Monsters
+		monsters.init(entityArray, currentMap);
+		//Set Combat manager
+		CombatManager.setMonsterList(monsters.getMonsterList());
+		gameAssets = new GameScreenAssets();
+		//Re-writes initialization defaults with read information from saved file
+		if (loadedGame)
+		{
+			initEntityArray();
+			currentMap = LoadingGame.initLoadingGame(gameAssets, currentMap, totalLevels, player, monsters, entityArray);
+		}
+        //Initializes the Menu
+		gameAssets.initMenu(gc, stateGame, ID);
+		SoundManager.changeFloorMusic(gameAssets.getFloorLevel());	
+		//Initializes the player's entity Array
+		//Which is important for detecting monsters
+		player.setEntityArray(monsters.getEntityArray());
+		}
+	
+	
+	
+	
+	
+	
+	// Initializes the entity array, this will hold the information 
+	// about the objects in the game (such as the player)
+	private void initEntityArray (){
+		String [][] newArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		entityArray = newArray;
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				newArray[i][c] = " ";
+			}
+		}
+		this.entityArray = newArray;
+	}
+	
+	
+	// Draws the display of the game
+	@Override
+	public void render(GameContainer gc, StateBasedGame stateGame, Graphics graphics)
+			throws SlickException {
+		
+		//Render Map, Monsters, Player, GameScreen Assets
+		currentMap.render();
+		monsters.render(graphics);
+		player.render(graphics);
+		gameAssets.render(graphics, player);
+	}
+	
+	
+	// Manages the keyboard controls of the game
+	@Override
+	public void keyReleased (int key,char c){
+		switch (key){
+		case Input.KEY_Q:
+			SavingGame.SaveGame(gameAssets, player, monsters);
+			gc.exit();//Exits game. 	
+			break;
+		case Input.KEY_M: 
+		case Input.KEY_ESCAPE:
+			//Slide Out Menu Hot Key Controls
+			if (gameAssets.menu.getMenuOpen() == true)
+				gameAssets.getMenu().popIn();
+			else
+				gameAssets.getMenu().popOut();
+			break;
+		//Decrease volume
+		case Input.KEY_A:
+			volume -= 0.1f;
+			if (volume < 0.0f)
+				volume = 0.0f;
+			SoundStore.get().setSoundVolume(volume);
+			SoundStore.get().setMusicVolume(volume);
+			break;
+		
+		//Increase volume
+		case Input.KEY_S:
+			volume += 0.1f;
+			if (volume > 1.0f)	
+				volume = 1.0f;
+			SoundStore.get().setSoundVolume(volume);
+			SoundStore.get().setMusicVolume(volume);
+		}
+	}
+
+	
+	// Updates the state of the game (player location, combat, monster movement etc..)
+	@Override
+	public void update(GameContainer gc, StateBasedGame stateGame, int delta)
+			throws SlickException {
+		textLogCounter = gameAssets.updateTextLog(textLogCounter);
+
+		if (!player.getAlive())
+		{
+			GameScreenAssets.queueTextLog.add( "Your player be dead");
+			//Change state of game to game over state.
+			stateGame.enterState(GameOverScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));
+		}
+		
+		//Always let the player move.
+		player.update(monsterCounter);
+		
+		
+		//Update monster movement
+		if (monsters.getMonsterList()!= null){
+			monsters.update(player.getPosition(), monsterCounter);
+			monsterCounter++;
+			if (monsterCounter > 400)//Used to delay the monster's movement
+				monsterCounter = 0;
+			}
+		
+		//Load a new floor if the stairs are stepped on.
+		if (player.getOnStairs()&&totalLevels.peekLast()!= null){
+			currentMap = totalLevels.removeLast();
+			player.setMap(currentMap);
+			monsters.clearMonsters();
+			monsters.increaseFloorLevel();
+			monsters.init(entityArray, currentMap);		
+			CombatManager.setMonsterList(monsters.getMonsterList());
+			player.setEntityArray(monsters.getEntityArray());
+			gameAssets.increaseFloorLevel();
+			SoundManager.changeFloorMusic(gameAssets.getFloorLevel());
+			player.setOnStairs(false);
+			}
+		
+		//Note to self this needs testing.	
+		 if (winGame)
+			{
+			sbg.enterState(WinScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.white));
+			}
+		}
+	
+	
+	
+
+	//Returns ID of state for state manager that controls
+	//Flow of game
+	@Override
+	public int getID() {
+		return ID;
+	}
+
+}
diff --git a/src/gameStates/GameScreenAssets.java b/src/gameStates/GameScreenAssets.java
new file mode 100644
index 0000000..b3677f7
--- /dev/null
+++ b/src/gameStates/GameScreenAssets.java
@@ -0,0 +1,137 @@
+package gameStates;
+
+import inputRelated.ButtonAction;
+import inputRelated.SlideOutMenu;// WILL USE!!! 
+
+import java.util.LinkedList;
+
+
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.fills.GradientFill;
+import org.newdawn.slick.geom.Rectangle;
+import org.newdawn.slick.state.StateBasedGame;
+
+import playerRelated.Player;
+
+////////////////////////////////////////////////////
+//GameScreenAssets								  //
+//Purpose: Controls the various elements in the UI//
+//Limit: Textlog has unified source of updates	  //
+////////////////////////////////////////////////////
+
+public class GameScreenAssets {
+
+	//Floor Variables
+	private int floorLevel = 1;
+	
+	//Menu object
+	SlideOutMenu menu;
+	GameContainer gc;
+	//TextLog Variables
+	private String statusBackLog2;
+	private String statusBackLog1;
+	private String statusUpdate;
+	
+	//Linked lists for keeping track of the game's state.
+	public static LinkedList <String> queueTextLog = new LinkedList<String>();
+
+	//Increase Floor Level
+	public void increaseFloorLevel(){ floorLevel++;}
+	
+	//Getters & Setters for floor level
+	public int getFloorLevel(){return floorLevel;}
+	public void setFloorLevel(int newFloorLevel){floorLevel = newFloorLevel;} 
+
+	//Initializes text log
+	//Initializes mini menu
+	public void initMenu(GameContainer gc, StateBasedGame stateGame, int ID) throws SlickException{
+		  this.gc = gc;
+		  queueTextLog.clear();
+		  statusBackLog2 = " ";
+		  statusBackLog1 = " ";
+		  statusUpdate = "Go to Seventh Floor to escape!";
+	      menu = new SlideOutMenu(gc, stateGame, ID, new Image ("res/interface/miniMenu.png"), 1065, 50 );
+	        menu.add(new ButtonAction(){ 
+	    		public void perform(){
+	    		}
+	    		});
+	}
+	
+	//getter for menu
+	public SlideOutMenu getMenu(){return menu;}
+	
+	
+	
+	// Draws the UI elements
+	public void render(Graphics g, Player player){
+		
+		//Render Text Log + Floor Status
+		g.setColor(Color.white);
+		g.drawString("Floor: "+floorLevel, 1000, 20);
+	    g.drawString(statusUpdate, 600, 490);
+	    g.drawString(statusBackLog1, 600, 470);
+	    g.drawString(statusBackLog2, 600, 450);
+
+	    //Draw Player Level
+	    g.setColor(Color.yellow);
+	    g.drawString("Lvl: "+player.getCurrentLevel(),10, 450);
+	    
+	    g.setColor(Color.white);
+	    ///Draw Health Bar
+	    g.drawString("HP", 80, 450);
+	    g.drawString(""+player.getHealthPoints()+"/"+player.getMaxHealthPoints(), 420, 450);
+	    Rectangle healthBar = new Rectangle(110, 450, 300 * player.getHealthPoints() / player.getMaxHealthPoints(), 20);
+        GradientFill fillRed = new GradientFill(110, 0, new Color(255, 0, 0),
+                                             460 + 300, 0, new Color(220,60, 0));
+
+        g.setColor(Color.darkGray);
+        g.fillRect(110, 450, 300, 20);
+        g.fill(healthBar, fillRed); 
+        
+        
+        //Draw Experience Bar
+        g.setColor(Color.white);
+	    g.drawString("EXP", 80, 480);
+	    g.drawString(""+player.getExperiencePoints()+"/"+player.getPointsNextLevel(), 420, 480);
+	    Rectangle expBar = new Rectangle(110, 480, 300*player.getExperiencePoints()/player.getPointsNextLevel(), 20);
+        GradientFill fillGreen = new GradientFill(110, 0, new Color(90, 255, 20),
+                                             480 + 300, 0, new Color(40, 180, 40));
+        g.setColor(Color.darkGray);
+        g.fillRect(110, 480, 300, 20);
+        g.fill(expBar, fillGreen); 
+        
+        //Render menu
+        menu.render(gc, g);
+		
+	}
+	
+	
+	public void clearTextLog(){
+		while (!queueTextLog.isEmpty())
+			queueTextLog.pop();
+	}
+	
+	// Scrolls the text log to display more recent information
+	public int updateTextLog(int textLogCounter){
+		if (textLogCounter < 0)
+			return 0;
+		
+		if (textLogCounter > 200){
+			String temp = queueTextLog.pollLast();
+			if (temp!= null){
+				statusBackLog2 = statusBackLog1;
+				statusBackLog1 = statusUpdate;
+				statusUpdate = ""+temp;
+			}	
+			return 0;
+		}
+		else
+			return ++textLogCounter;
+	}
+	
+	
+}
diff --git a/src/gameStates/MainMenuScreen.java b/src/gameStates/MainMenuScreen.java
new file mode 100644
index 0000000..27d0ab1
--- /dev/null
+++ b/src/gameStates/MainMenuScreen.java
@@ -0,0 +1,76 @@
+package gameStates;
+
+import inputRelated.MainMenuButtons;
+
+import managers.SoundManager;
+
+import org.newdawn.slick.Animation;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.state.BasicGameState;
+import org.newdawn.slick.state.StateBasedGame;
+
+//////////////////////////////////////////////////////////////////////
+//Menu														        //
+//Purpose: Loads the main menu screen when the game is first started//
+//Limit: Current Continue button remains inactive			        //
+//////////////////////////////////////////////////////////////////////
+
+public class MainMenuScreen extends BasicGameState {
+
+	
+	public static final int ID = 0; //Set the state's I.D 
+	
+	//Variables used for UI elements
+	private MainMenuButtons menuButtons;
+	private Animation menuAnimation;
+	
+	
+	// Initializes the menu
+	@Override
+	public void init(GameContainer gc, StateBasedGame stateGame)
+			throws SlickException {
+		
+		//Initializes menu buttons
+		menuButtons = new MainMenuButtons(gc,stateGame);
+	
+		//Initializes Menu's Animation
+		Image [] menuImages = {new Image ("res/interface/mainMenu1.png"),new Image ("res/interface/mainMenu3.png"),
+							   new Image ("res/interface/mainMenu2.png"),new Image ("res/interface/mainMenu3.png")}; 
+		int [] duration = {300,100,300,100};//Duration of miliseconds per image in animation
+		menuAnimation = new Animation (menuImages, duration, false);
+		
+		//Plays games music
+		SoundManager.changeSound("res/sound/Flying In The Face Of Hope.wav");
+	    
+		
+	}
+	
+	
+	// Draws the menu screen
+	@Override
+	public void render(GameContainer gc, StateBasedGame stateGame, Graphics graphics)
+			throws SlickException {
+		gc.setShowFPS(false); //FPS counter is hidden		
+		menuAnimation.draw(300,50);
+	    menuButtons.render(gc,graphics);//Renders the menu buttons
+	}
+
+	// Updates the menu's animation
+	@Override
+	public void update(GameContainer gc, StateBasedGame stateGame, int delta)
+			throws SlickException {
+			menuAnimation.update(delta);
+			
+	}
+	
+	//Returns ID of state for state manager that controls
+    //Flow of game
+	@Override
+	public int getID() {
+		return ID;
+	}
+
+}
diff --git a/src/gameStates/StateManager.java b/src/gameStates/StateManager.java
new file mode 100644
index 0000000..8ff5069
--- /dev/null
+++ b/src/gameStates/StateManager.java
@@ -0,0 +1,29 @@
+package gameStates;
+
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.state.StateBasedGame;
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+//StateManager																					   //
+//Purpose: This class manages the flow of the game through its states							   //
+//Limit: Works only with SLICK2D API    														   //
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+
+public class StateManager extends StateBasedGame {
+
+		public StateManager(String name) {
+		super(name);
+	}
+		
+	// A list of states instantiated to be used by the game
+	@Override
+	public void initStatesList(GameContainer gc) throws SlickException {
+		addState(new MainMenuScreen());
+		addState(new TransitionScreen());
+		addState(new GameScreen());
+		addState(new GameOverScreen());
+		addState(new WinScreen());
+	}
+
+}
diff --git a/src/gameStates/TransitionScreen.java b/src/gameStates/TransitionScreen.java
new file mode 100644
index 0000000..de42284
--- /dev/null
+++ b/src/gameStates/TransitionScreen.java
@@ -0,0 +1,147 @@
+package gameStates;
+
+import managers.SoundManager;
+
+import org.newdawn.slick.Animation;
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.Input;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.state.BasicGameState;
+import org.newdawn.slick.state.StateBasedGame;
+import org.newdawn.slick.state.transition.FadeInTransition;
+import org.newdawn.slick.state.transition.FadeOutTransition;
+
+public class TransitionScreen extends BasicGameState {
+	//State's ID
+	public static final int ID = 4;
+	
+	//Used to enter other states
+	private StateBasedGame sbg;
+	
+	//Different Images and Variables Used For Intro
+	private Image controlImage;
+	private Image controlImage2;
+	private Animation explanationAnimation;
+	private Animation animationIntro;
+	private Image panicImage;
+	private int slide = 0; //Used to keep track of which images/animations to draw to screen
+	
+	
+	//Initializes Transition Screen for Intro
+	@Override
+	public void init(GameContainer gc, StateBasedGame sbg)
+			throws SlickException {
+		this.sbg = sbg;
+		Image [] animationImages = {new Image ("res/player/intro1.png"),
+									new Image ("res/player/intro2.png"),
+									new Image ("res/player/intro3.png"),
+									new Image ("res/player/intro4.png"),
+									new Image ("res/player/intro5.png"),
+									new Image ("res/player/intro6.png"),
+									new Image ("res/player/intro7.png"),
+									new Image ("res/player/intro8.png"),
+									new Image ("res/player/intro9.png"),
+									new Image ("res/player/intro10.png"),
+									new Image ("res/player/intro11.png"),
+									new Image ("res/player/intro12.png"),
+									new Image ("res/player/intro13.png"),
+									new Image ("res/player/intro14.png"),
+									new Image ("res/player/intro15.png"),
+									new Image ("res/player/intro16.png"),
+									new Image ("res/player/intro17.png"),
+									new Image ("res/player/intro18.png"),
+									new Image ("res/player/intro19.png"),
+									new Image ("res/player/intro20.png"),
+									new Image ("res/player/intro21.png"),
+									new Image ("res/player/intro22.png"),
+									new Image ("res/player/intro23.png"),
+									new Image ("res/player/intro24.png"),
+									new Image ("res/player/intro25.png"),
+									new Image ("res/player/intro26.png"),
+									new Image ("res/player/intro27.png"),
+									new Image ("res/player/intro28.png")};
+		int [] introDuration = {300,300,300,300,300,300,300,300,300,300,
+				           300,300,300,300,300,300,300,300,300,300,
+				           300,300,300,300,300,300,300,10000};//Duration of milliseconds per every image
+		animationIntro = new Animation (animationImages, introDuration, false);
+		controlImage = new Image("res/interface/controls.png"); 
+		controlImage2 = new Image("res/interface/controls2.png");
+		panicImage = new Image("res/interface/panic.png");
+		
+		Image [] explanationImages = {new Image ("res/interface/ember1.png"),
+								    new Image ("res/interface/ember2.png"),
+								    new Image ("res/interface/ember1.png"),
+								    new Image ("res/interface/ember2.png"),
+								    new Image ("res/interface/ember1.png"),
+								    new Image ("res/interface/ember2.png"),
+								    new Image ("res/interface/ember3.png"),
+								    new Image ("res/interface/ember4.png")};
+		
+		int [] explanationDuration = {300, 300,300,300,300,300,9980, 1000000};//Duration of milliseconds per every image
+		explanationAnimation = new Animation (explanationImages,explanationDuration, false);
+	}
+	
+	@Override
+	public void enter (GameContainer gc, StateBasedGame sbg)
+	{
+			//Load State's music
+			SoundManager.changeSound("res/sound/Extra Effort.wav");
+		
+	}
+
+	//Draws Transition Screen based on Player Input
+	@Override
+	public void render(GameContainer gc, StateBasedGame sbg, Graphics graphics)
+			throws SlickException {
+		graphics.setColor(Color.black);
+		if (slide < 1)
+			animationIntro.draw(0,0);
+		else if (slide == 1)
+			panicImage.draw(0,0);
+		else if (slide == 2)
+			explanationAnimation.draw(0,0);
+		else if (slide == 3)
+			controlImage.draw(0,0);
+		else if (slide == 4)
+			controlImage2.draw(0,0);		
+		graphics.drawString("PRESS 'W' TO SKIP INTRO", 780, 470);
+	}
+	
+	//Controls Keyboard Input
+	@Override
+	public void keyReleased (int key,char c){
+		switch (key){		
+		case Input.KEY_W:
+			sbg.enterState(GameScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));	
+			break;
+		default:
+			if (slide >=5)
+				sbg.enterState(GameScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));	
+			else
+				slide++;
+		}
+	}
+
+	
+	//Updates Animation on Transition Screen
+	@Override
+	public void update(GameContainer gc, StateBasedGame sbg, int delta)
+			throws SlickException {
+		animationIntro.update(delta);
+		if (slide == 2)
+			explanationAnimation.update(delta);
+		
+	}
+
+	
+	//Returns ID of state for state manager that controls
+	//Flow of game
+	@Override
+	public int getID() {
+		return ID;
+	}
+
+}
diff --git a/src/gameStates/Ver2GameDriver.java b/src/gameStates/Ver2GameDriver.java
new file mode 100644
index 0000000..f537b4b
--- /dev/null
+++ b/src/gameStates/Ver2GameDriver.java
@@ -0,0 +1,31 @@
+package gameStates;
+
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import org.newdawn.slick.AppGameContainer;
+import org.newdawn.slick.SlickException;
+
+//Driver Used to run the game
+//Contains Main Method
+public class Ver2GameDriver {	
+
+	public static void main (String [] args){
+		
+		//All the code below is how we get this game rolling and running.
+		
+		final int screenWidth = 1120; // Set screen width to 35 tiles long (35*32px)
+		final int screenHeight = 512; // Set screen height to 16 tile long (16*32px)
+		
+			try
+			{
+				AppGameContainer appgc;
+				appgc = new AppGameContainer(new StateManager("Endless Embers"),screenWidth,screenHeight,false);
+				appgc.start();
+			}
+			catch (SlickException ex)
+			{
+				Logger.getLogger(StateManager.class.getName()).log(Level.SEVERE, null, ex);
+			}
+	}
+}
diff --git a/src/gameStates/WinScreen.java b/src/gameStates/WinScreen.java
new file mode 100644
index 0000000..bc9e92b
--- /dev/null
+++ b/src/gameStates/WinScreen.java
@@ -0,0 +1,93 @@
+package gameStates;
+
+import inputRelated.EndGameButtons;
+
+import java.io.File;
+
+import managers.SoundManager;
+
+import org.newdawn.slick.Animation;
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.Input;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.state.BasicGameState;
+import org.newdawn.slick.state.StateBasedGame;
+
+public class WinScreen extends BasicGameState{
+
+	public static final int ID = 5;
+	private EndGameButtons buttons;
+	private Animation winAnimation;
+	
+	
+	
+	private GameContainer gc;
+	@Override
+	public void enter (GameContainer gc, StateBasedGame sbg){
+		SoundManager.changeSound("res/sound/Back To Programming.wav");
+		GameScreen.setWin(false);//Reset win boolean for future new games
+		try{
+			 
+    		File file = new File("save.txt");
+ 
+    		if(file.delete()){
+    			System.out.println(file.getName() + " is deleted!");
+    		}else{
+    			System.out.println("Delete operation is failed.");
+    		}
+    	}catch(Exception e){
+ 
+    		e.printStackTrace();
+    	}
+		//Reset loadedGame/Win values
+		GameScreen.setWin(false);
+		GameScreen.setLoadedGame(false);
+	}
+	
+	@Override
+	public void init(GameContainer gc, StateBasedGame sbg)
+			throws SlickException {
+			this.gc = gc;
+		    buttons = new EndGameButtons(gc, sbg, WinScreen.ID);
+		    Image [] winImages = {new Image("res/interface/winAnimation1.png"),
+		    					  new Image("res/interface/winAnimation2.png")};
+		    int [] duration = {400,400};//duration of miliseconds per image
+		    
+		    winAnimation = new Animation (winImages, duration, false);
+		    }
+	
+
+	@Override
+	public void render(GameContainer gc, StateBasedGame sbg, Graphics g)
+			throws SlickException {
+		winAnimation.draw(0, 0);
+		buttons.render(gc, g);
+		g.setColor(Color.white);
+		g.drawString("YOU WON!!!", 480,200);
+	}
+
+	@Override
+	public void update(GameContainer gc, StateBasedGame sbg, int delta)
+			throws SlickException {
+		winAnimation.update(delta);
+	}
+	
+	// Manages the keyboard controls of the game
+		@Override
+		public void keyReleased (int key,char c){
+			switch (key){
+			case Input.KEY_Q:
+				gc.exit();//Exits game. 	
+				break;
+			}
+		}
+
+	@Override
+	public int getID() {
+		return ID;
+	}
+
+}
diff --git a/src/inputRelated/BasicButton.java b/src/inputRelated/BasicButton.java
new file mode 100644
index 0000000..6b787ac
--- /dev/null
+++ b/src/inputRelated/BasicButton.java
@@ -0,0 +1,117 @@
+package inputRelated;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.newdawn.slick.Color;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.gui.GUIContext;
+import org.newdawn.slick.gui.MouseOverArea;
+import org.newdawn.slick.state.StateBasedGame;
+
+//////////////////////////////////////////////////////////////////////////////////////////
+//BASIC BUTTON TEMPLATE				      												//
+//Purpose: Creates Button Template        												//			
+//Limits: Relies on SLICK2D API         C  												//
+//Author: Deque							  												//
+//Source :https://evilzone.org/java/%28java-fames-tut%29-slick2d-buttons-buttons-buttons//
+//////////////////////////////////////////////////////////////////////////////////////////
+
+public class BasicButton extends MouseOverArea {
+
+	 //Variables for Button Functionality
+	 private boolean activated = false;
+	 private boolean unclickable = false;
+	 private boolean lastMouseOver = false;
+
+	 //Variables for Image of Button
+	 private Image inactiveButton;
+	 private Image activeButton;
+	 
+	 //Variables to reference gameScreen where its used
+     private final StateBasedGame sbg;
+     private final int stateID;
+
+     //Used for holding button press actions
+     private final List <ButtonAction> actions = new ArrayList <ButtonAction>();
+ 	
+     //Initializes Button
+     public BasicButton(GUIContext container, int x, int y,
+			StateBasedGame sbg, int stateID, Image inactiveButton, Image activeButton) throws SlickException {
+		 	super(container, activeButton, x, y);
+	        super.setMouseDownColor(Color.white);
+	        super.setMouseOverColor(Color.yellow);
+	        super.setMouseOverImage(activeButton);
+	        this.sbg = sbg;
+	        this.stateID = stateID;
+	 
+	        this.inactiveButton = inactiveButton;
+	        this.activeButton = activeButton;
+	}
+     
+    //Method to add actions to a button to perform
+	public void add(ButtonAction action){
+		actions.add(action);
+	}
+	
+	//Disables button
+	public void setUnClickable(boolean unclickable){
+			this.unclickable = unclickable;
+	}
+	
+	
+	//Method used to tell when the mouse is hovering over the button
+	@Override
+    public void mouseMoved(int oldx, int oldy, int newx, int newy) {
+	        if (sbg.getCurrentStateID() == stateID) {
+	            if (isMouseOver() && !lastMouseOver && !isActivated()) {
+	                lastMouseOver = true;
+	            } else if (!isMouseOver()) {
+	                lastMouseOver = false;
+	            }
+	        }
+	        super.mouseMoved(oldx, oldy, newx, newy);
+	    }
+
+	
+	//Renders button image depending on its activation
+	@Override
+    public void render(GUIContext guic, Graphics graphics) {
+	        if (isActivated()&&!unclickable) {
+	            graphics.drawImage(activeButton, getX(), getY());
+	            activated = false;
+	        }
+	        super.render(guic, graphics);
+		    if (unclickable)
+		    {
+		    	graphics.drawImage(inactiveButton, getX(), getY());
+		    }
+	    }
+	 
+	//Checks if button is activated
+	public boolean isActivated() {return activated;}
+	 
+	//Sets the button activated or not.
+    protected void setActivated(boolean b) {activated = b;}
+	    
+	    
+	//Method that gets button to perform its action when pressed
+	@Override
+	public void mousePressed(int button, int x, int y) {
+	    if (isMouseOver() && sbg.getCurrentStateID() == stateID) {
+	         activated = !activated;
+	         for (ButtonAction action: actions){
+	          	action.perform();
+	            }
+	        }
+	        super.mousePressed(button, x, y);
+	    }
+	
+	//Gets the list of actions for the button
+    public List <ButtonAction>getActions(){return actions;}
+}
+	
+	
+
diff --git a/src/inputRelated/ButtonAction.java b/src/inputRelated/ButtonAction.java
new file mode 100644
index 0000000..0083640
--- /dev/null
+++ b/src/inputRelated/ButtonAction.java
@@ -0,0 +1,9 @@
+package inputRelated;
+
+
+//Source :https://evilzone.org/java/%28java-fames-tut%29-slick2d-buttons-buttons-buttons/
+public interface ButtonAction {
+	public void perform();
+
+
+}
diff --git a/src/inputRelated/EndGameButtons.java b/src/inputRelated/EndGameButtons.java
new file mode 100644
index 0000000..9995a91
--- /dev/null
+++ b/src/inputRelated/EndGameButtons.java
@@ -0,0 +1,72 @@
+package inputRelated;
+
+import gameStates.GameScreen;
+
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.state.StateBasedGame;
+import org.newdawn.slick.state.transition.FadeInTransition;
+import org.newdawn.slick.state.transition.FadeOutTransition;
+
+public class EndGameButtons {
+
+	//Button Variables
+	private BasicButton quitGameButton;
+	private BasicButton newGameButton;
+	
+	
+	//Used to for the actions of the buttons
+	private StateBasedGame sbg;
+	private GameContainer gc;
+	
+	
+	public EndGameButtons (GameContainer container, StateBasedGame stateGame, int stateID) throws SlickException{
+		
+		sbg = stateGame;
+		this.gc = container;
+		
+		
+		//Get the images of the buttons in their inactive/active states
+		Image activeNewGame = new Image("res/interface/newGameActive.png");
+		Image mouseOverNewGame = new Image("res/interface/newGameMouseOver.png");
+		Image activeQuitGame = new Image ("res/interface/exitGameActive.png");
+		Image mouseOverQuitGame = new Image("res/interface/exitGameMouseOver.png");
+		
+		newGameButton = new BasicButton(gc, 330, 350, 
+			    stateGame, stateID, activeNewGame, activeNewGame);
+		quitGameButton = new BasicButton(gc, 540, 350, 
+				stateGame,  stateID, activeQuitGame, activeQuitGame);
+		
+		newGameButton.setMouseOverImage(mouseOverNewGame);
+		 
+		quitGameButton.setMouseDownImage(mouseOverQuitGame);
+		quitGameButton.setMouseOverImage(mouseOverQuitGame);
+		
+		//Creates an anon class for the button's action.
+		newGameButton.add(new ButtonAction(){ 
+			public void perform(){
+			sbg.enterState(GameScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));	
+			}
+			});
+		
+		//Creates an anon class for the button's action.
+		quitGameButton.add(new ButtonAction(){ 
+			public void perform(){
+				//Delete game/Over write old game here
+				((GameContainer)gc).exit();	
+			}
+		});
+		
+		}
+	
+	
+	
+	public void render(GameContainer gc, Graphics g){
+		 newGameButton.render(gc, g);//Draw the buttons on screen.
+		 quitGameButton.render(gc,g);
+	}
+	
+}
diff --git a/src/inputRelated/LoadingGame.java b/src/inputRelated/LoadingGame.java
new file mode 100644
index 0000000..7430510
--- /dev/null
+++ b/src/inputRelated/LoadingGame.java
@@ -0,0 +1,117 @@
+package inputRelated;
+
+import gameStates.GameScreenAssets;
+
+import java.io.BufferedReader;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.LinkedList;
+
+import managers.CombatManager;
+import managers.MonsterManager;
+import mapRelated.BasicMap;
+import monsterRelated.Entity;
+
+import org.newdawn.slick.SlickException;
+
+import playerRelated.Player;
+
+public class LoadingGame {
+	
+	public static BasicMap initLoadingGame(GameScreenAssets gameAssets, BasicMap changeMap, LinkedList<BasicMap> xTotalLevels,
+			   Player player, MonsterManager monsters, String[][] entityArray)
+			   throws SlickException
+	{	
+
+		int readFloor = 0;
+		int readPlayerPositionX = 0;
+		int readPlayerPositionY = 0;
+		int readPlayerLevel = 0;
+		int readPlayerExp = 0;
+		int readPlayerHealth = 0;
+		int[] readMonsterXPositions = new int[50];
+		int[] readMonsterYPositions = new int[50];
+		int[] readMonsterHealths = new int[50];
+
+		/*READ FROM SAVE FILE*/
+		try	
+		{
+			FileReader fr = new FileReader("save.txt");
+			BufferedReader br = new BufferedReader(fr);
+
+			//Reading player saved data
+			LoadPlayerData(br, readFloor, readPlayerPositionX, readPlayerPositionY, readPlayerLevel, readPlayerExp, readPlayerHealth);
+		
+			//Reading monster saved data
+			String lineRead = br.readLine();
+			for (int i = 0; lineRead != null; i++)
+				{
+					if (lineRead != null)
+					{
+					String readStringMonsterXPosition = lineRead;
+					readMonsterXPositions[i] = Integer.valueOf(readStringMonsterXPosition);
+					lineRead = br.readLine();
+					}
+					
+					if (lineRead != null)
+					{
+						String readStringMonsterYPosition = lineRead;
+						readMonsterYPositions[i] = Integer.valueOf(readStringMonsterYPosition);
+						lineRead = br.readLine();
+					}
+					if (lineRead != null)
+					{
+					String readStringMonsterHealth = lineRead;
+					readMonsterHealths[i] = Integer.valueOf(readStringMonsterHealth);
+					lineRead = br.readLine();
+					}
+				
+				}
+
+			br.close();
+			fr.close();
+			}
+		catch (IOException e)
+		{
+			e.printStackTrace();
+		}	
+
+		//Set floor level
+		gameAssets.setFloorLevel(readFloor);
+		//Set current map
+		for (int i = readFloor - 1;i != 0;i--)
+		{
+			changeMap = xTotalLevels.removeLast();
+		}
+		//Set player related data
+		player.loadStats(readPlayerLevel, readPlayerExp, readPlayerHealth);
+		player.setPosition(readPlayerPositionX, readPlayerPositionY);
+		player.setMap(changeMap);
+		entityArray[((Entity)player).getPosition()[0]/32][((Entity)player).getPosition()[1]/32] = player.getName();
+		//Set monster related data
+		monsters.loadMonsterList(readMonsterXPositions, readMonsterYPositions, readMonsterHealths, entityArray, changeMap, readFloor);
+		CombatManager.setMonsterList(monsters.getMonsterList());
+
+		player.setEntityArray(entityArray);		
+		return changeMap;
+	}
+
+	private static void LoadPlayerData(BufferedReader br, int readFloor, int readPlayerPositionX, int readPlayerPositionY, int readPlayerExp, int readPlayerLevel, int readPlayerHealth) throws IOException {
+		//Reading player saved data
+		String readStringFloor = br.readLine();
+		readFloor = Integer.valueOf(readStringFloor);
+		String readStringPlayerPositionX = br.readLine();
+		readPlayerPositionX = Integer.valueOf(readStringPlayerPositionX);
+		String readStringPlayerPositionY = br.readLine();
+		readPlayerPositionY = Integer.valueOf(readStringPlayerPositionY);
+		String readStringPlayerLevel = br.readLine();
+		readPlayerLevel = Integer.valueOf(readStringPlayerLevel);
+		String readStringPlayerExp = br.readLine();
+		readPlayerExp = Integer.valueOf(readStringPlayerExp);
+		String readStringPlayerHealth = br.readLine();
+		readPlayerHealth = Integer.valueOf(readStringPlayerHealth);
+	}
+
+
+}
+
diff --git a/src/inputRelated/MainMenuButtons.java b/src/inputRelated/MainMenuButtons.java
new file mode 100644
index 0000000..91c9760
--- /dev/null
+++ b/src/inputRelated/MainMenuButtons.java
@@ -0,0 +1,94 @@
+package inputRelated;
+
+import java.io.File;
+
+import gameStates.GameScreen;
+import gameStates.MainMenuScreen;
+import gameStates.TransitionScreen;
+
+
+
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.state.StateBasedGame;
+import org.newdawn.slick.state.transition.FadeInTransition;
+import org.newdawn.slick.state.transition.FadeOutTransition;
+
+public class MainMenuButtons {
+	
+	//Button Variables
+	private BasicButton loadGameButton;
+	private BasicButton newGameButton;
+	
+	
+	//Used to for the actions of the buttons
+	private StateBasedGame sbg;
+	private boolean savedGameExists = false;
+	
+	public MainMenuButtons (GameContainer gc, StateBasedGame stateGame) throws SlickException{
+	
+	sbg = stateGame;
+	
+	File f = new File("save.txt");
+	
+	if(f.exists() && f.isFile())
+		{
+		savedGameExists = true;
+		}
+	
+
+	//Get the images of the buttons in their inactive/active states
+	Image activeNewGame = new Image("res/interface/newGameActive.png");
+	Image mouseOverNewGame = new Image("res/interface/newGameMouseOver.png");
+	Image inactiveLoad = new Image ("res/interface/continueInActive.png");
+	Image activeLoad = new Image("res/interface/continueActive.png");
+	
+	
+	newGameButton = new BasicButton(gc, 330, 350, 
+									    stateGame, MainMenuScreen.ID, activeNewGame, activeNewGame);
+	loadGameButton = new BasicButton(gc, 540, 350, 
+										stateGame, MainMenuScreen.ID, inactiveLoad, activeLoad);
+	
+	newGameButton.setMouseDownImage(mouseOverNewGame);
+	newGameButton.setMouseOverImage(mouseOverNewGame);
+	
+	if (!savedGameExists){//Given that a saved game does not exist deactivate this button
+		loadGameButton.setUnClickable(true);	
+		loadGameButton.setMouseOverImage(inactiveLoad);
+		loadGameButton.setMouseOverColor(Color.white);
+		}
+	else
+	{
+		loadGameButton.setUnClickable(false);
+		loadGameButton.setMouseOverImage(new Image("res/interface/continueMouseOver.png"));
+	}	
+	//Creates an anon class for the button's action.
+	newGameButton.add(new ButtonAction(){ 
+		public void perform(){
+		sbg.enterState(TransitionScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));	
+		}
+		});
+	
+	
+	//Creates an anon class for the button's action.
+	loadGameButton.add(new ButtonAction(){ 
+		public void perform(){
+		if (savedGameExists){
+			GameScreen.setLoadedGame(true);
+			sbg.enterState(GameScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));	
+			}
+		}
+		});
+	}	
+	
+	//Draw buttons on main menu screen
+	public void render(GameContainer gc, Graphics graphics){
+		 newGameButton.render(gc, graphics);//Draw the buttons on screen.
+		 loadGameButton.render(gc,graphics);
+	}
+	
+	
+}
diff --git a/src/inputRelated/SavingGame.java b/src/inputRelated/SavingGame.java
new file mode 100644
index 0000000..9425991
--- /dev/null
+++ b/src/inputRelated/SavingGame.java
@@ -0,0 +1,53 @@
+package inputRelated;
+
+import gameStates.GameScreenAssets;
+
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.LinkedList;
+
+import managers.MonsterManager;
+import monsterRelated.BasicMonster;
+import playerRelated.Player;
+
+public class SavingGame {
+		
+	public static void SaveGame(GameScreenAssets gsa, Player player, MonsterManager monsterManage){
+		try
+		{
+			FileWriter fw = new FileWriter("save.txt");
+			PrintWriter pw = new PrintWriter(fw);
+			//First Write Floor number. Newline.
+			pw.println(gsa.getFloorLevel());
+			//Player position. new line
+			pw.println(player.getPosition()[0]);
+			pw.println(player.getPosition()[1]);
+			//Player level
+			pw.println(player.getCurrentLevel());
+			//Player experience points. new line
+			pw.println(player.getExperiencePoints());
+			//Player health points. new line.
+			pw.println(player.getHealthPoints());
+			//Start loop for saving monster info
+			LinkedList<BasicMonster> monsterLinkedList = (LinkedList<BasicMonster>) monsterManage.getMonsterList().clone();
+			while (monsterLinkedList.peekFirst() != null)
+			{
+				BasicMonster currentNode = monsterLinkedList.removeFirst();
+				//Don't have monster type as of now
+				//Write monster x-coordinate and y-coordinate
+				pw.println(currentNode.getPosition()[0]);
+				pw.println(currentNode.getPosition()[1]);
+				//Write monster health
+				pw.println(currentNode.getHealthPoints());
+			}
+			pw.close();
+			fw.close();
+		}
+		catch (IOException e)
+		{
+			e.printStackTrace();
+		}
+	}
+
+}
diff --git a/src/inputRelated/SlideOutMenu.java b/src/inputRelated/SlideOutMenu.java
new file mode 100644
index 0000000..0ab58e9
--- /dev/null
+++ b/src/inputRelated/SlideOutMenu.java
@@ -0,0 +1,109 @@
+package inputRelated;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.gui.GUIContext;
+import org.newdawn.slick.gui.MouseOverArea;
+import org.newdawn.slick.state.StateBasedGame;
+
+////////////////////////////////////////////////////////
+//Slide Out Menu									  //
+//Purpose: Controls Slide Out Menu/Associated Buttons //
+//Limit: Does not smoothly pop out					  //
+//Has not other buttons than exiting the game		  //
+////////////////////////////////////////////////////////
+
+public class SlideOutMenu extends MouseOverArea{
+
+	//Used Changing States/Closing Game
+	private StateBasedGame sbg;
+	private GUIContext gc;
+	
+	//Sets menu's state
+	private boolean activated = false;
+	private boolean menuOpen = false;
+
+	private BasicButton exitGameButton;
+	
+	//Button Variables used for Constructor
+	private final List <ButtonAction> actions = new ArrayList <ButtonAction>();
+	private int stateID;
+	
+	//Slide Out Menu Initialization
+	public SlideOutMenu(GUIContext container,StateBasedGame game, int stateID,  Image image, int x, int y) throws SlickException {
+		super(container, image, x, y);
+		sbg = game;
+		gc = container;
+		this.stateID = stateID;
+	    super.setMouseOverColor(Color.yellow);
+	    //Constants used here are the x, y coordinates of the button.
+	    exitGameButton = new BasicButton(container, 1140, y+315, game, 
+	    		stateID, new Image ("res/interface/saveExit.png"), new Image ("res/interface/saveExit.png"));
+	    
+	    exitGameButton.setMouseOverImage(new Image("res/interface/saveExitMouseOver.png"));
+		exitGameButton.add(new ButtonAction(){
+			public void perform(){
+				((GameContainer)gc).exit();	
+			}	
+		});
+
+	}
+
+	   //Draw Game Menu (Used for mouseOverDownImage and highlighting color)
+	   public void render(GameContainer gc, Graphics graphics) {
+	          super.render(gc, graphics);
+	          exitGameButton.render(gc,graphics);
+	   }
+	
+	
+	   //The menu is essentially one big button so it has to inherit/implement this method
+	   public boolean isActivated() {
+	        return activated;
+	    }
+	   
+	   //Used for the slide out menu
+	   public void add(ButtonAction action){
+		actions.add(action);
+	   }
+	
+	//Method that handles what happens you click on the slide out menu
+	//Depending on whether it's already open or not
+	@Override
+    public void mousePressed(int button, int x, int y) {
+		if (isMouseOver() && sbg.getCurrentStateID() == stateID) {
+            activated = !activated;
+            if (menuOpen == false){
+            	popOut();
+            }
+            else{
+            	popIn();
+            }
+        super.mousePressed(button, x, y);
+       }
+    }
+    
+	//Checks boolean
+	//Used for hot keys in game screen 
+	public boolean getMenuOpen(){return menuOpen;}
+	
+	//Pops the slide menu out
+	public void popOut(){
+		setX(300);
+    	exitGameButton.setX(610);
+    	menuOpen = true;
+	}
+	
+	//Pops the slide menu in
+	public void popIn(){
+		setX(1065);
+    	exitGameButton.setX(1150);
+    	menuOpen = false;
+	}
+	
+}
diff --git a/src/managers/CombatManager.java b/src/managers/CombatManager.java
new file mode 100644
index 0000000..ea65f52
--- /dev/null
+++ b/src/managers/CombatManager.java
@@ -0,0 +1,138 @@
+package managers;
+
+import gameStates.GameScreenAssets;
+
+import java.util.LinkedList;
+import java.util.Random;
+
+import monsterRelated.BasicMonster;
+import playerRelated.Player;
+
+/////////////////////////////////////////////////////////////
+//Combat  Manager                                          //
+//Purpose: Deal with the combat inside the game		       //
+//Limit: Monsters will only attack if players attack       // 
+//Monsters will freeze movement if one monster is being    //
+//attacked.  											   //
+//Notes: Sends messages about the combat to text log	   //
+/////////////////////////////////////////////////////////////
+
+public class CombatManager {
+	
+	public static boolean battleHappening = false;
+	private static LinkedList <BasicMonster> monsterList = new LinkedList<BasicMonster>();
+	
+	
+	public static void setMonsterList(LinkedList <BasicMonster> monsters){monsterList = monsters;}
+		
+	// The monster will attack the player when it has been provoked	
+	public static String attackLoop(Player player, int criticalHitLimit, int missFactor, int monsterX, int monsterY ){
+		battleHappening = true;
+		if (getMonsterRef(monsterX, monsterY) == null)
+		{
+			GameScreenAssets.queueTextLog.addFirst("You are attacking a ghost! Oh no! Run away before it gets you!");
+			battleHappening = false;
+			return "Error! No Monster Found to Fight";
+		}
+		else
+		{
+			BasicMonster currentFoe = getMonsterRef(monsterX,monsterY);
+    		actualCombat(currentFoe, player, criticalHitLimit, missFactor);
+					
+		}
+		return null;
+	}
+	
+	
+	//Attacks Monster Accordingly to attack generate
+	//TO DO: ADD SOUNDS
+	private static void actualCombat(BasicMonster currentFoe, Player player, int criticalHitLimit, int missFactor){
+	
+		int attack = generateAttack(criticalHitLimit);//Generate Attack
+		
+		//Player Misses!
+		if (attack <= missFactor){
+			GameScreenAssets.queueTextLog.addFirst("You missed!");
+			SoundManager.playSoundEffect("res/sound/SFX/Swoosh.wav");
+			monsterAttacks (player,currentFoe);
+			}
+		
+		
+		//Average Hit
+		else if (attack > missFactor && attack <= criticalHitLimit-missFactor)
+		{
+		
+		GameScreenAssets.queueTextLog.addFirst("Average Hit: "+attack);
+		SoundManager.playSoundEffect("res/sound/SFX/Sword Swing.wav");
+		currentFoe.subtractHealth(attack);
+		currentFoe.setIsAttacked(true);
+			if (currentFoe.getHealthPoints() <= 0)
+			{
+				monsterDies(player, currentFoe);
+				return;
+			}
+			monsterAttacks (player,currentFoe);
+		}
+		
+		
+		//Critical Hit
+		else 
+		{
+		currentFoe.subtractHealth(attack);
+		currentFoe.setIsAttacked(true);
+		GameScreenAssets.queueTextLog.addFirst("Critical Hit: "+attack);
+		SoundManager.playSoundEffect("res/sound/SFX/Sword Swing.wav");
+			if (currentFoe.getHealthPoints() <= 0)
+			{
+				monsterDies(player, currentFoe);
+				return;
+			}
+			monsterAttacks (player,currentFoe);
+		}
+	}
+	
+	
+	// An attack roll is generated
+	private static int generateAttack(int criticalHitLimit){
+		Random gen = new Random();
+		int attack = gen.nextInt(criticalHitLimit);
+		return attack;
+	}
+	
+	
+	// Monster Attacks Back with randomly generated Number
+	private static void monsterAttacks(Player player, BasicMonster currentFoe){
+		int attack = generateAttack(currentFoe.damageLimit);
+		player.subtractHealth(attack);	
+		GameScreenAssets.queueTextLog.addFirst("Monster attacks back! Damage Done: "+attack);
+	
+	}
+	
+	
+	// Handles what happens when a monster is killed
+	private static void monsterDies(Player player, BasicMonster currentFoe){
+		GameScreenAssets.queueTextLog.addFirst("You've Killed the monster!");
+		SoundManager.playSoundEffect("res/sound/SFX/MonsterDie.wav");
+		player.addExperiencePoints(currentFoe.getExpPointGain());
+		battleHappening = false;
+		monsterList.remove(currentFoe);
+	
+	}
+	
+	
+	// Retrieves monster reference from the monster list
+	private static BasicMonster getMonsterRef(int x, int y){
+		BasicMonster monsterFound = null;
+		int [] monsterPosition = new int [2];
+		for (int i = 0; i < monsterList.size(); i++)
+			{
+			monsterPosition = monsterList.get(i).getPosition();
+			if (monsterPosition[0] == x && monsterPosition[1] == y)
+				{
+				monsterFound = monsterList.get(i);
+				}
+			}
+		return monsterFound;
+	}
+	
+}
diff --git a/src/managers/MonsterManager.java b/src/managers/MonsterManager.java
new file mode 100644
index 0000000..d1683c1
--- /dev/null
+++ b/src/managers/MonsterManager.java
@@ -0,0 +1,293 @@
+
+package managers;
+
+import java.util.LinkedList;
+import java.util.Random;
+
+import mapRelated.BasicMap;
+import monsterRelated.BasicMonster;
+
+import org.newdawn.slick.Animation;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.SpriteSheet;
+
+/////////////////////////////////////////////////////////////
+//Monster Manager                                          //
+//Purpose: Manage Multiple Monsters in a level		       //
+//Limit: Currently only handles one type of monster.       //
+//Features: Spawns Monsters 2*Level. Save for Level 7 	   //
+/////////////////////////////////////////////////////////////
+
+public class MonsterManager {
+
+	
+	private LinkedList<BasicMonster> monsterList = new LinkedList<BasicMonster>();
+	private int level = 1;
+	private BasicMap currentMap;
+	private String[][] entityArray;
+	private int screenWidth = 1120;
+	private int screenHeight = 512;
+	
+	
+	
+	//Monster Type1
+	private Image basicMonsterImage;
+	private SpriteSheet basicMonsterSheet;
+	private Animation basicMonsterAnimation;//Bobs monsters up and down
+	
+		
+	//For test purposes Only
+	public MonsterManager(){
+		
+	}
+	//For test purposes only
+	
+	//Sets Map for Monster Manager
+	public MonsterManager(BasicMap map){
+		currentMap = map;
+	}
+	
+	//Checks if Valid Entity Array
+	public String checkEntityArray(String [][] entityArray){
+		if (entityArray.length*entityArray[0].length != BasicMap.widthByTiles*BasicMap.heightByTiles)
+			return "Entity Array Not Expected Size";
+		
+		for (String[] row: entityArray){
+			for (String s:row)
+			{
+				if (s == null)
+					return "EntityArray cannot have null objects";
+			}
+		}
+		
+		boolean playerFound = false;
+		for(String[] row:entityArray)
+		{
+			for (String s: row)
+			{
+				if (s.equals("P"))
+					playerFound = true;
+			}
+		}
+		
+		if (!playerFound)
+			return "Player not in EntityArray"; 
+		
+		return null;
+	}
+	
+	
+	//Sets entityArray for later monster spawning
+	public String setEntityArray(String [][]entityArray){
+		if ( checkEntityArray(entityArray) != null)
+		{
+			return "Invalid Entity Array";
+		}
+		this.entityArray = entityArray;
+		return null;
+	}
+	
+	//To do later: Put this into a private object and change this method to a private method.
+	public int[] findValidPlacement(int monsterPathSize, BasicMap map, String [][] array){
+		Random gen = new Random();
+		int newX = gen.nextInt(35)*BasicMap.TILESIZE;
+		int newY = gen.nextInt(16)*BasicMap.TILESIZE;
+		int[]  newPosition = {newX, newY};
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i ++){
+			for (int c = 0; c < BasicMap.heightByTiles; c++){
+				if (checkValidPlacement(newPosition, monsterPathSize, map, array) == null){
+					return newPosition;
+					}
+				newPosition[0] = (newX+i*BasicMap.TILESIZE)%(screenWidth);
+				newPosition[1] = (newY+c*BasicMap.TILESIZE)%(screenHeight);
+				}
+
+			}
+		return null;
+	}
+	
+	//Checks if spawned at a valid spot
+	public String checkValidPlacement(int[]newPosition, int monsterPathSize, BasicMap map, String [][] array){
+		Boolean allClear = true;
+		int checkX = newPosition[0];
+		int checkY = newPosition[1];
+		for (int i = 0;i < monsterPathSize; i++)
+		{
+			if (checkX >= (screenWidth) || checkY >= (screenHeight) || checkX < 0 || checkY < 0)
+				return "Out of Bounds";
+			else if (array[checkX/BasicMap.TILESIZE][checkY/BasicMap.TILESIZE] != " "){
+				allClear = false;
+				return "Entity Overlap";
+				}
+			else if (map.hasCollision(checkX, checkY))
+				{
+				allClear = false;
+				return "Map Overlap";
+				}
+			
+			checkX += BasicMap.TILESIZE;
+		}
+
+		if (allClear){
+			return null;
+		}
+		else{
+			return "Invalid Spot";
+		}
+
+	}
+	
+	
+	// Loads monster Images 
+	private void loadMonsterTypes() throws SlickException{
+		basicMonsterSheet= new SpriteSheet("res/monster/dummySheet.png",BasicMap.TILESIZE,BasicMap.TILESIZE); 
+		basicMonsterImage = basicMonsterSheet.getSubImage(0, 0);
+		Image [] monsterAnim = {basicMonsterSheet.getSubImage(0, 0), basicMonsterSheet.getSubImage(1, 0)};
+		int [] duration = {250,250};
+		basicMonsterAnimation = new Animation(monsterAnim, duration, false);
+		
+		
+		
+	}
+	
+	//Initializes monsters per level
+	public void init(String [][] entityArray, BasicMap currentMap) throws SlickException{
+		if (checkEntityArray(entityArray) !=null)
+			return;
+		//Initialize monster data
+		loadMonsterTypes();
+		this.entityArray = entityArray;
+		BasicMonster monster1 = null;
+		int pathSize = 4;
+		monsterList = new LinkedList<BasicMonster>();
+		//Adjusts path size for more confined maps.
+		if (level >= 3)
+			pathSize = 2;
+		
+		//Number of monsters to spawn
+		int numOfMonsters = level*2;
+		//Special treatment for level 7
+		if (level == 7)
+			numOfMonsters = 7;
+		
+		//Spawns number of monsters according to level
+		for (int i = 0; i < numOfMonsters; i++){
+		    int[] spawnPosition = findValidPlacement (pathSize, currentMap, entityArray);
+			while (spawnPosition == null)
+			    spawnPosition = findValidPlacement (pathSize, currentMap, entityArray);
+			
+			monster1 = new BasicMonster(currentMap, basicMonsterAnimation, basicMonsterImage, spawnPosition[0], spawnPosition[1]);
+			monsterList.add(monster1);
+			monster1.setPath(spawnPosition[0], spawnPosition[0]+(pathSize-1)*BasicMap.TILESIZE);
+			entityArray[monster1.getPosition()[0]/BasicMap.TILESIZE]
+				       [monster1.getPosition()[1]/BasicMap.TILESIZE] = monster1.getName();
+			}
+			
+			setUpMonsterMethods();
+	}
+	
+	public void setUpMonsterMethods (){
+		//Sets up monster methods
+				BasicMonster [] monsters = monsterList.toArray(new BasicMonster [monsterList.size()]);
+				for (BasicMonster m: monsters){
+					m.setEntityArray(entityArray);
+					m.setMonsterMaxHealth(level*10);
+					m.setHealthPoints(level*10);
+					if (level == 1)//Special Level 1 treatment
+						m.damageLimit = 4;
+					else
+						m.damageLimit = 20+level*2;
+					m.setMap(currentMap);
+					}
+			
+	}
+	
+	
+	//Calls render method for every monster inside the list.
+	public void render(Graphics graphics) throws SlickException{
+		
+		BasicMonster [] monsters = monsterList.toArray(new BasicMonster [monsterList.size()]);
+		for (BasicMonster m: monsters){
+			m.render(graphics);
+			}
+		
+	}
+
+	
+	public void loadMonsterList(int[] newMonsterXPositions, int[] newMonsterYPositions, 
+								int[] newMonsterHealths, String[][] newEntityArray, BasicMap newMap, int newLevel)
+	throws SlickException
+	{
+		this.entityArray = newEntityArray;
+		this.level = newLevel;
+		loadMonsterTypes();
+		currentMap = newMap;
+		monsterList = new LinkedList<BasicMonster>();
+		BasicMonster monster;		
+
+		int numOfMonsters = newMonsterXPositions.length;
+		for (int i = 0;i < numOfMonsters;i++)
+		{
+			if (newMonsterXPositions[i] == 0 && newMonsterYPositions[i] == 0)
+				break;
+			monster = new BasicMonster(currentMap, basicMonsterAnimation, basicMonsterImage, newMonsterXPositions[i], newMonsterYPositions[i]);
+			monster.setHealthPoints(newMonsterHealths[i]);
+			monster.setPath(newMonsterXPositions[i], newMonsterXPositions[i]+3*BasicMap.TILESIZE);
+			newEntityArray[monster.getPosition()[0]/BasicMap.TILESIZE]
+			     	   [monster.getPosition()[1]/BasicMap.TILESIZE] = monster.getName();
+			monsterList.add(monster);
+		}
+		
+		setUpMonsterMethods();
+		
+	}
+	
+	
+	
+	//Calls update method for every monster inside list
+	public void update(int[] playerPosition, int counter){
+
+		BasicMonster [] monsters = monsterList.toArray(new BasicMonster [monsterList.size()]);
+		for (BasicMonster m: monsters){
+			m.update(playerPosition, counter);
+			}
+	}
+	
+	
+	//Returns the entityArray with the monsters placed on them
+	public String [][] getEntityArray(){return entityArray;}	
+		
+	//Returns the linked list of monsters
+	public LinkedList<BasicMonster> getMonsterList() {return monsterList;}
+	
+	
+	//Method to change level and change the amount of monsters.
+	public void increaseFloorLevel(){level++;}
+	
+	//Calls the setMap function for all the monsters inside the list
+	public void setMap(BasicMap newMap){
+		BasicMonster [] monsters = monsterList.toArray(new BasicMonster [monsterList.size()]);
+		for (BasicMonster m: monsters){
+			m.setMap(newMap);
+			}
+	}
+	
+	//Clears the monsters for the next Level
+	public String clearMonsters(){
+		for (int i = 0; i < BasicMap.widthByTiles; i++){
+			for (int c = 0; c <BasicMap.heightByTiles; c ++){
+				if (entityArray[i][c] != "P")
+					entityArray[i][c] = " ";
+			}
+		}
+		if (checkEntityArray (entityArray) != null){
+			return "Error! You accidentally cleared the player";//"Technically this checks if you've created an array
+		}														//Of proper size, no nulls AND a player inside it.
+		monsterList.clear();
+		
+		return null;
+	}	
+}
diff --git a/src/managers/SoundManager.java b/src/managers/SoundManager.java
new file mode 100644
index 0000000..9b2863a
--- /dev/null
+++ b/src/managers/SoundManager.java
@@ -0,0 +1,103 @@
+package managers;
+	import java.io.IOException;
+
+import org.newdawn.slick.openal.Audio;
+import org.newdawn.slick.openal.AudioLoader;
+import org.newdawn.slick.openal.SoundStore;
+import org.newdawn.slick.util.ResourceLoader;
+
+
+///////////////////////////////////////////
+//SoundManager							 //
+//Purpose: Manages the sounds in the game//
+//Limit: Limited to Slick2dAPI			 //
+//Will crash if sound file not found     //
+///////////////////////////////////////////
+
+
+public class SoundManager {
+	 
+		/** The wav sound effect */
+		private static Audio wavEffect;
+		
+		//Loads initial Background music
+	    public SoundManager(String filename) {
+	 
+	        try {
+	 
+		    //load Wav sound
+		    wavEffect = AudioLoader.getAudio("WAV", ResourceLoader.getResourceAsStream(filename));
+			wavEffect.playAsMusic(1.0f,1.0f, true);  
+	        } catch (IOException e) {
+		    e.printStackTrace();
+		}
+	    	SoundStore.get().poll(0);
+			
+	    }
+	 
+	    //Updates music and keeps it playing
+		public void update() {
+			wavEffect.playAsMusic(1.0f,1.0f, true);  
+			SoundStore.get().poll(0);
+		}
+		
+		//Updates Music Based On Floor Level
+		public static void changeFloorMusic(int floor){
+			switch (floor)
+			{
+			case 1:
+				changeSound("res/sound/Objective Combat.wav");
+				break;
+			case 2:
+				changeSound("res/sound/Target Mission.wav");
+				break;
+			case 3:
+				changeSound("res/sound/Growing Danger.wav");
+				break;
+			case 4:
+				changeSound("res/sound/Only Human.wav");
+				break;
+			case 5:
+				changeSound("res/sound/Feelings Are On The Rise.wav");
+				break;
+			case 6:
+				changeSound("res/sound/All I Have Is My Devil.wav");
+				break;
+			case 7:
+				changeSound("res/sound/Conflict Ensues.wav");
+				break;
+			
+			default:
+				break;
+			}
+			
+		}
+		
+		//Changes music playing in the background
+		//Given filename & path
+		public static void changeSound (String filename){
+			try{
+			wavEffect = AudioLoader.getAudio("WAV", ResourceLoader.getResourceAsStream(filename));
+			wavEffect.playAsMusic(1.0f,1.0f, true);  
+			}
+			catch (IOException e){
+				e.printStackTrace();
+			}
+		}
+
+		
+		
+		//Plays sound once
+		public static void playSoundEffect(String filename){
+			try{
+				wavEffect = AudioLoader.getAudio("WAV", ResourceLoader.getResourceAsStream(filename));
+				wavEffect.playAsSoundEffect(1.0f,1.0f, false);  	
+			}
+			catch (IOException e){
+				e.printStackTrace();
+			}
+
+		}
+	 
+}
+
diff --git a/src/mapRelated/BasicMap.java b/src/mapRelated/BasicMap.java
new file mode 100644
index 0000000..97214da
--- /dev/null
+++ b/src/mapRelated/BasicMap.java
@@ -0,0 +1,132 @@
+package mapRelated;
+
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.tiled.TiledMap;
+
+//////////////////////////////////////////////////////////////////////////////////
+//BasicMap																		//
+//Purpose: Basic Template for loading Maps from Tiled. 							//
+//Has Methods that manages operations related to maps							//
+//Limit: Limited to Tiled Program Loading										//
+//////////////////////////////////////////////////////////////////////////////////
+
+public class BasicMap
+{
+	private TiledMap map;
+	private char [][] mapArray;
+
+	public static final int widthByTiles = 35;
+	public static final int heightByTiles = 16;
+	public static final int TILESIZE = 32;
+	
+	////////////FOR TESTS ONLY//////////////
+	////////////////////////////////////////
+	public BasicMap(char [][] newArray){
+		
+		mapArray = newArray;
+	}
+	
+	
+	public BasicMap(){
+		mapArray = new char [widthByTiles][heightByTiles];
+	}
+	//////////////////////////////////////
+	//////////////////////////////////////
+	
+	
+	
+	//Loads Map based on .tmx file
+	public BasicMap(String tmxLocation) throws SlickException{
+		map = new TiledMap(tmxLocation);
+		mapArray = new char[widthByTiles][heightByTiles];
+		initMapArray();
+	}
+
+	//Initializes the Map
+	//Reads the load .tmx file
+	private void initMapArray (){
+		String value;
+		for (int c = 0; c < widthByTiles; c++){
+			for (int r = 0; r < heightByTiles; r ++)
+			{
+				int tileID = map.getTileId(c, r, 0);
+				if (r == 0 & c == 0)
+				{
+				System.out.println(tileID);
+				}
+                value = map.getTileProperty(tileID, "blocked", "false");
+                if ("true".equals(value))
+                {
+                    mapArray[c][r] = 'B';
+                }
+                value = map.getTileProperty(tileID, "stairs", "false");
+                if ("true".equals(value))
+                {
+                	mapArray[c][r] = 'S';
+                }
+                
+                value = map.getTileProperty(tileID, "win", "false");
+                if ("true".equals((value)))
+                {
+                	mapArray[c][r] = 'W';
+                }
+			}
+		}
+	}
+
+	
+	//Checks if a given x,y coordinate collides with a block on the map
+	public boolean hasCollision (float x, float y)
+	{
+		if (x < 0 || y < 0 || x >=1120 || y >= 512)
+			return false;
+		
+		int xBlock = (int)x / TILESIZE;
+	    int yBlock = (int)y / TILESIZE;
+	    
+	    //Just a test conditional code.
+	    if (mapArray[xBlock][yBlock] == 'B')
+	    	return true;
+	    
+	    else
+	    	return false;    
+	}
+		
+	//Renders the map on screen
+	public void render()
+	{
+		map.render(0,0);
+	}
+	
+	//Checks if a give x,y coord is a staircase
+	public boolean isStairs (float x, float y)
+	{
+		if (x < 0 || y < 0 || x >=1120 || y >= 512)
+			return false;
+		
+		int xStairs = (int)x / TILESIZE;
+	    int yStairs = (int)y / TILESIZE;
+	    
+	    if (mapArray[xStairs][yStairs] == 'S')
+	    	return true;
+	    else
+	    	return false;
+	}
+	
+
+
+	//Checks if a give x,y coord is a staircase
+	public boolean isWin (float x, float y)
+	{	
+	if (x < 0 || y < 0 || x >=1120 || y >= 512)
+		return false;
+	
+	int xStairs = (int)x / TILESIZE;
+    int yStairs = (int)y / TILESIZE;
+    
+    if (mapArray[xStairs][yStairs] == 'W')
+    	return true;
+    else
+    	return false;
+	}
+}
diff --git a/src/monsterRelated/BasicMonster.java b/src/monsterRelated/BasicMonster.java
new file mode 100644
index 0000000..674460a
--- /dev/null
+++ b/src/monsterRelated/BasicMonster.java
@@ -0,0 +1,295 @@
+package monsterRelated;
+
+
+import mapRelated.BasicMap;
+
+import org.newdawn.slick.Animation;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.SpriteSheet;
+
+
+public class BasicMonster extends Entity{
+
+	//Variables related to Images
+	protected Image monsterImage;
+	protected Animation monsterAnimation;
+	
+	//Variables related to spotting the player
+	protected double monsterSightRange;
+	protected boolean isActiveState = false;
+	
+
+	//Variables related to movement	
+	private int counter;
+	protected char direction;
+	private int pathStart = 7*BasicMap.TILESIZE, pathEnd = 9*BasicMap.TILESIZE;
+	private BasicMap map;
+	
+	//Variables related to combat
+	public int damageLimit = 18;//This can be overridden by its children later. Just watch for it.
+	protected boolean isAttacked = false;
+	
+	
+
+	///////////////////////////////////
+	//////////For TEST ONLY////////////
+	public BasicMonster(BasicMap map, int x, int y, int counter){
+		super(x,y);
+		this.counter = counter;
+		this.map = map;
+		name = "M";
+		monsterSightRange = 2;
+		counter = 0;
+		direction = 'R';
+		maxHealthPoints = 1000;
+		healthPoints = maxHealthPoints;
+		}
+
+	
+	public BasicMonster(BasicMap currentMap, Animation monsterLook,int x, int y) throws SlickException
+	{	
+		super(x,y);
+		map = currentMap;
+		name = "M";
+		monsterSightRange = 2;
+		SpriteSheet basicMonsterSheet= new SpriteSheet("res/monster/dummySheet.png",BasicMap.TILESIZE,BasicMap.TILESIZE); 
+		monsterImage = basicMonsterSheet.getSubImage(0, 0);
+		monsterAnimation = monsterLook;
+		monsterAnimation.setAutoUpdate(true);
+		counter = 0;
+		direction = 'R';
+		maxHealthPoints = 100;
+		healthPoints = maxHealthPoints;
+	}
+	
+	
+
+	//////////////////////////////////// STILL TEST METHODS ABOVE//////////////////////////
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+	
+	
+	
+	
+	
+	
+	//Initializes Monster
+	public BasicMonster(BasicMap currentMap,Animation monsterAnimation, Image monsterLook,int x, int y)
+	{
+		super(x,y);
+		map = currentMap;
+		name = "M";
+		monsterSightRange = 2;
+		monsterImage = monsterLook;
+		this.monsterAnimation = monsterAnimation;
+		monsterAnimation.setAutoUpdate(true);
+		counter = 0;
+		direction = 'R';
+		maxHealthPoints = 20;
+		healthPoints = maxHealthPoints;
+	}
+
+	///////Methods dealing with the state of the monster///////
+	public boolean getMonsterState(){return isActiveState;}
+	
+	
+	public void setMonsterState(boolean foundPlayer){
+		isActiveState = foundPlayer;	
+	}
+	public void setIsAttacked (boolean attacked){isAttacked = attacked;}
+	
+	public void actDead() throws SlickException{
+		monsterImage = new Image ("res/monster/dead.png");
+	}
+	
+	
+	//Methods dealing with monster combat
+	public void setHealthPoints(int points) {healthPoints = points;}
+	public void setMonsterMaxHealth(int monsterMaxHealth) {monsterMaxHealth = maxHealthPoints;}
+	public int getExpPointGain() {return (maxHealthPoints/2)+10;}
+	
+	
+	//Draws Monster to Screen
+	public void render(Graphics graphics) throws SlickException{
+		if (!alive)
+			actDead();
+		monsterAnimation.draw((int)x, (int)y);
+	}
+	
+	//Updates Monster's Position
+	public String update(int [] playerPosition, int counter)
+	{
+		
+		this.counter = counter;
+		oldx = x;
+		oldy = y;
+		//Check for Overlap
+		if (playerPosition[0] < 0 || playerPosition [1] < 0)
+			return "Invalid Player Position! Going Off Map";
+		if (entityArray[playerPosition[0]/BasicMap.TILESIZE][playerPosition[1]/BasicMap.TILESIZE] == " " ||
+			entityArray[playerPosition[0]/BasicMap.TILESIZE][playerPosition[1]/BasicMap.TILESIZE] == "M"){
+			return "Player has disappeared from the map.";}
+
+		
+		isActiveState = search("P");
+		if (isActiveState || (isAttacked&&!isActiveState)){
+			findClosestSpot(playerPosition);
+		}
+		else{
+			wander(playerPosition);
+		}
+		
+		return null;
+	}
+		
+	
+	////////////////////////////////////////////
+	/////////////Movement Methods///////////////
+	////////////////////////////////////////////
+
+	//Sets path that monsters wanders along
+	public void setPath (int start, int end){
+		pathStart = start;
+		pathEnd = end;}
+	
+	//Moves monster according to its path
+	private void wander(int [] playerPosition){
+	if (!alive)
+		return;
+	
+	int newX1 = x+BasicMap.TILESIZE;
+	int newX2 = x-BasicMap.TILESIZE;	
+	if ((newX2>= 0 && newX1<=1048)&&counter >= 400){
+		//Change Direction
+		if (newX1 > pathEnd)
+			direction = 'L';
+
+		//move rightwards	
+		if (direction == 'R'&&!isTaken(newX1,y)){
+			if (map.hasCollision(newX1, y))
+			{
+				direction = 'L';
+				return;
+			}
+			updatePosition(newX1,y);
+			x = newX1;
+			
+			}
+		//move leftwards
+		else if (direction == 'L' &&!isTaken(newX2,y)){
+				if (map.hasCollision(newX2, y))
+				{
+					direction = 'R';
+					return;
+				}
+				updatePosition(newX2,y);
+				x = newX2;
+				//Change Direction
+				if (x  < pathStart){
+					direction = 'R';
+				}
+		}
+			
+		counter = 0;
+	}
+	else
+		counter++;
+	}
+	
+		
+	//Used to find closestSpot near the player
+	public void findClosestSpot(int[] player)
+	{
+		int newX = 0;
+		int newY = 0;
+		if (x == player[0]&& y!= player[1]){
+				closestSpotHorizontal (player, newX, newY);
+			}
+			
+		else if (y == player[1]&& x != player[0])
+		{
+			closestSpotVertical(player,newX, newY);
+		}
+		else if (y!= player[1]&& x!= player[0])
+		{
+			closestSpotDiagonal(player,newX, newY);
+				
+		    }
+	}	
+	
+	//Finds closest diagonal spots towards player
+	private void closestSpotDiagonal(int [] player, int newX, int newY)
+	{
+
+		if (y > player[1])
+			newY = y - BasicMap.TILESIZE;
+		else
+			newY = y + BasicMap.TILESIZE;
+		
+		if (x > player [0])
+			newX = x - BasicMap.TILESIZE;
+		else
+			newX = x + BasicMap.TILESIZE;		
+		
+		if (!isTaken(newX, newY) && !map.hasCollision(newX, newY))
+				{
+				updatePosition(newX,newY);
+				x = newX;
+				y = newY;
+				}
+		
+		else if (!isTaken(x, newY) && !map.hasCollision(x, newY))
+				{
+				updatePosition(x,newY);
+				y = newY;
+			    }
+		
+		else if (!isTaken(newX, y) && !map.hasCollision(newX, y))
+				{
+				updatePosition(newX, y);
+				x = newX;
+				}		
+	}
+	
+	
+
+	//Finds closest horizontal spots towards player
+	private void closestSpotHorizontal(int [] player, int newX, int newY){
+		if (player[1] > y)
+			newY = y + BasicMap.TILESIZE;
+		else
+			newY = y - BasicMap.TILESIZE;
+		
+		if (!isTaken(x,newY)&&!map.hasCollision(x,newY))
+			{		
+			updatePosition(x,newY);
+			y = newY;
+			}
+	}
+	
+	
+
+	//Finds closest vertical spots towards player
+	private void closestSpotVertical(int [] player, int newX, int newY){
+		
+		if (player[0] > x)
+			newX = x + BasicMap.TILESIZE;
+		else
+			newX = x - BasicMap.TILESIZE;
+		
+		if (!isTaken(newX,y)&&!map.hasCollision(newX, y))
+			{
+			updatePosition(newX,y);
+			x = newX;
+			}
+	}
+	
+	
+
+}
+
+	
+	
+
diff --git a/src/monsterRelated/Entity.java b/src/monsterRelated/Entity.java
new file mode 100644
index 0000000..1b47b54
--- /dev/null
+++ b/src/monsterRelated/Entity.java
@@ -0,0 +1,174 @@
+package monsterRelated;
+
+import mapRelated.BasicMap;
+
+public class Entity {
+	
+	//Has both the old position and current position 
+	protected int oldx = 0, oldy = 0;
+	protected int x,y;
+	
+	//Used to check for overlap with other monsters
+	protected String [][] entityArray;
+	
+	//Name is created (note: never let it equal to 1 )
+	protected String name;
+	
+	//Variables related with the health of the character
+	protected int healthPoints = 30;
+	protected int maxHealthPoints = 30;
+	protected boolean alive = true;
+	
+	//Map entity stands upon currently
+	protected BasicMap map;
+	
+	private final int screenWidth = 1120;
+	private final int screenHeight = 512;
+	
+	//Location of entity
+	public Entity (int x,int y){
+		this.x = x;
+		this.y = y;
+	}
+	
+/////////////////////////////////////////////////
+//METHODS USED FOR SEARCHING UPDATING LOCATION IN ENTITY ARRAY
+/////////////////////////////////////////////////
+	
+	//Updates position of entity in entityArray
+	public String updatePosition(int x, int y){
+		if (!alive)
+			return null;
+		
+		if (x < 0 || oldx < 0 || y< 0|| oldy < 0 || x >= screenWidth || y >= screenHeight)	
+			return "Out of Bounds";
+		
+		oldx = this.x;
+		oldy = this.y;
+		entityArray[oldx/BasicMap.TILESIZE][oldy/BasicMap.TILESIZE] = " ";
+		entityArray[x/BasicMap.TILESIZE][y/BasicMap.TILESIZE] = name;
+		this.x = x;
+		this.y = y;
+		
+		return null;
+	}
+	
+	//Checks if the given spot current has an entity (player or monster) in it.
+	public boolean isTaken(int x, int y){
+		if (x < 0 || y < 0 || x >= screenWidth || y >= screenHeight)
+			return false;
+		int xTile = x/BasicMap.TILESIZE;
+		int yTile = y/BasicMap.TILESIZE;
+		boolean isTaken = false;
+		if (entityArray[xTile][yTile] != " ")
+			isTaken = true;
+		return isTaken;
+	}
+	
+	//Searches entityArray and sees if another entity is near it.
+	public boolean search(String name){
+			boolean found = false;
+			//Search looks within the range of 2
+			for (int row = (x/BasicMap.TILESIZE)-2; row <= (x/BasicMap.TILESIZE)+2; row++)
+			{
+				for (int column = (y/BasicMap.TILESIZE)-2; column <= (y/BasicMap.TILESIZE)+2; column++)
+				{
+					//If within bounds of the map.
+					if (row >= 0 && row < BasicMap.heightByTiles && column >= 0 && column < BasicMap.widthByTiles)
+					{
+						if (entityArray[row][column]!= null&&entityArray[row][column].equals(name))
+						{
+							found = true;
+							break;
+						}
+					}
+					
+				}	
+			}	
+			return found;
+	}
+	
+/////////////////////////////////////////
+///////////Combat Methods////////////////
+/////////////////////////////////////////
+	
+	//Subtract entity's health Points
+	public String subtractHealth(int points){
+		if (points < 0)
+			return "Cannot subtract negative health points";
+		
+		if (healthPoints - points <= 0){
+			alive = false;
+			entityArray[x/BasicMap.TILESIZE][y/BasicMap.TILESIZE] = " ";
+			healthPoints = 0;
+		}
+		else
+			healthPoints -= points;
+		return null;
+	}
+	
+	//Add entity's healthPoints
+	public String addHealthPoints(int points){
+		if (points < 0)
+			return "Cannot add negative health points";
+			
+		if (healthPoints+points > maxHealthPoints)
+			healthPoints = maxHealthPoints;
+		else
+			healthPoints += points;
+		
+		return null;
+	}
+	
+	//Gets the health points of the entity
+	public int getHealthPoints(){return healthPoints;}
+	public int getMaxHealthPoints() {return maxHealthPoints;}
+	
+	
+	
+	
+	
+	
+	/////GENERAL GET/SET METHODS///////////////////////////
+	public String setEntityArray(String[][] entityArray){
+		if (entityArray == null)
+			return "Error No EntityArray Found!";
+		
+		if (entityArray.length*entityArray[0].length != 35*16)
+			return "Entity Array Not Expected Size";
+		
+		for (String[] row: entityArray){
+			for (String s:row)
+			{
+				if (s == null)
+					return "EntityArray cannot have null objects";
+			}
+		}
+		this.entityArray = entityArray;
+		
+		return null;}
+	
+	public String[][]getEntityArray(){return entityArray;}
+	
+	//Method helps check if entity is alive
+	public boolean getAlive(){return alive;}
+	
+	//Get name of entity
+	public String getName(){return name;}	
+	
+	//Get location of entity
+	public int[] getPosition(){
+		int[] position = new int[2];
+		position[0] = x;
+		position[1] = y;
+		return position;
+	}
+	
+	//Update Map on which entity stands on
+	public void setMap(BasicMap map){
+		this.map = map;
+	}	
+	
+	public void setName(String name){this.name = name;}
+	
+}
diff --git a/src/playerRelated/Player.java b/src/playerRelated/Player.java
new file mode 100644
index 0000000..01e1ed5
--- /dev/null
+++ b/src/playerRelated/Player.java
@@ -0,0 +1,485 @@
+package playerRelated;
+
+import gameStates.GameScreen;
+import gameStates.GameScreenAssets;
+import managers.CombatManager;
+import managers.SoundManager;
+import mapRelated.BasicMap;
+import monsterRelated.Entity;
+
+import org.newdawn.slick.Animation;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.Input;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.SpriteSheet;
+import org.newdawn.slick.state.StateBasedGame;
+
+public class Player extends Entity{
+	
+	//Variables used for Slick 2 Game Components
+	private final GameContainer gc;
+	
+	//Used for stair case movement 
+	private boolean onStairs;
+	
+	//Variables used for Combat and related aspects
+	private int experiencePoints = 0;
+	private int pointsNextLevel = 10;
+	
+	private int playerLevel = 1;
+	private int criticalHitLimit= 30;
+	private int missFactor = 10;
+	
+	//Basic Sprite Variables
+	private SpriteSheet sheet;
+	private Animation currentSprite, up, down,left,right;
+
+	//Limited Vision Effect
+	private Image shadow;		
+	
+	////FOR TEST PURPOSES ONLY////
+	public Player (int x, int y){
+		super(x,y);
+		gc = null;
+		name = "P";
+	}
+	
+	public Player (int x, int y, BasicMap map){
+		super(x,y);
+		this.map = map;
+		gc = null;
+		name = "P";
+	}
+		
+	public void mockKeyBoard(char c){
+		switch(c) 
+		{
+		case 'u'://Up
+			moveUp();
+			break;
+		case 'd'://Down
+			moveDown();
+			break;
+		case 'l'://Left
+			moveLeft();
+			break;
+		case 'r'://Right
+			moveRight();
+			break;
+		case 'a'://Diagonal Up Left
+			moveDiagonalUpLeft();
+			break;
+		case 'b'://Diagonal Up Right
+			moveDiagonalUpRight();
+			break;
+		case 'c'://Diagonal Down Left
+			moveDiagonalDownLeft();
+			break;
+		case 'f'://Diagonal Down Right
+			moveDiagonalDownRight();
+			break;
+		case 'g':
+			moveNowhere();
+			break;
+		default:
+			break;
+		}
+		
+		
+	}
+	
+	
+	////FOR TEST PURPOSES ONLY////
+	public Player(GameContainer gc, StateBasedGame sbg, BasicMap currentMap,int x, int y) throws SlickException{
+		//Constructor used to 
+		super(x,y);
+		super.maxHealthPoints = 30;
+		super.healthPoints = maxHealthPoints;
+		
+		//Variables for the usage outside functions
+		this.gc = gc;
+		map = currentMap;
+		
+		//Initialize Variables
+		name = "P";
+		sheet = new SpriteSheet("res/player/template2.png", BasicMap.TILESIZE,BasicMap.TILESIZE);
+		shadow = new Image("res/player/largerShadow.png");
+		loadPlayerSprite(sheet);
+		
+	}
+	
+	//Load the animations used for the player's sprite
+	private void loadPlayerSprite(SpriteSheet playerSheet){
+				//Load Sprite Images for Player
+				Image [] upSprite = {sheet.getSubImage(0,3),
+								     sheet.getSubImage(1,3),
+								     sheet.getSubImage(2,3),
+								     sheet.getSubImage(3,3)};
+				Image [] downSprite = {sheet.getSubImage(0,0),
+					     			  sheet.getSubImage(1,0),
+					     			  sheet.getSubImage(2,0),
+					     			  sheet.getSubImage(3,0)};
+				Image [] rightSprite = {sheet.getSubImage(0,2),
+										sheet.getSubImage(1,2),
+										sheet.getSubImage(2,2),
+										sheet.getSubImage(3,2)};
+				
+				Image [] leftSprite = {sheet.getSubImage(0,1),
+					     			   sheet.getSubImage(1,1),
+					     			   sheet.getSubImage(2,1),
+					     			   sheet.getSubImage(3,1)};
+
+				//Set the duration of Animation in Milliseconds	
+				int [] duration = {300,300,300,300};
+				
+				//Initialize Animations
+				up = new Animation(upSprite, duration, false);
+				down = new Animation (downSprite, duration, false);
+				left = new Animation(leftSprite, duration, false);
+				right = new Animation (rightSprite,duration,false);		
+				currentSprite = down;
+				
+				//Allow animations to automatically play through
+				currentSprite.setAutoUpdate(true);
+				up.setAutoUpdate(true);
+				left.setAutoUpdate(true);
+				right.setAutoUpdate(true);
+	}
+	
+	
+	
+	public void render(Graphics graphics){
+	currentSprite.draw((int) x, (int) y);//Draw what the Current sprite should look like.
+	graphics.drawImage(shadow,(int)x-1110, (int)y-850); //Draw Shadow with a particular offset for the spotlight
+	}
+	
+	
+	public void update(long delta){
+		//If the player is not alive change game state.
+		//Do not allow the player to move.
+		if (!alive){
+			return;
+			}
+		//Input used to get keyboard controls
+		Input input = gc.getInput();
+		 
+		//Diagonal Up Left
+		if (input.isKeyPressed(Input.KEY_NUMPAD7)||input.isKeyPressed(Input.KEY_7)){
+			 moveDiagonalUpLeft();
+		 }
+		
+		//Normal Up
+		else if (input.isKeyPressed(Input.KEY_UP)||input.isKeyPressed(Input.KEY_8)
+				||input.isKeyPressed(Input.KEY_NUMPAD8)){
+				moveUp();
+		}
+		
+		//Diagonal Up Right
+		else if (input.isKeyPressed(Input.KEY_NUMPAD9)||input.isKeyPressed(Input.KEY_9)){
+				moveDiagonalUpRight();
+		}
+
+		//Normal Left
+		else if (input.isKeyPressed(Input.KEY_LEFT)||input.isKeyPressed(Input.KEY_U)
+				||input.isKeyPressed(Input.KEY_NUMPAD4)){
+				moveLeft();
+		}
+		
+		//PASS TURN
+		else if (input.isKeyPressed(Input.KEY_NUMPAD5)||input.isKeyPressed(Input.KEY_I))
+			{
+			moveNowhere();
+			}
+		
+		//Normal Right
+		else if (input.isKeyPressed(Input.KEY_RIGHT)||input.isKeyPressed(Input.KEY_O)||
+				input.isKeyPressed(Input.KEY_NUMPAD6)){
+			moveRight();
+			}
+		
+		//Diagonal Down Left
+		else if (input.isKeyPressed(Input.KEY_NUMPAD1)||input.isKeyPressed(Input.KEY_J)){
+				moveDiagonalDownLeft();
+				}
+		
+		//Normal Down
+		else if (input.isKeyPressed(Input.KEY_DOWN)||input.isKeyPressed(Input.KEY_K)||
+				input.isKeyPressed(Input.KEY_NUMPAD2)){
+			moveDown();
+		}
+
+		//Diagonal Down Right
+		else if (input.isKeyPressed(Input.KEY_NUMPAD3)||input.isKeyPressed(Input.KEY_L)){
+			moveDiagonalDownRight();
+		}
+		 
+	}
+
+	
+////////////METHODS DEALING WITH MOVEMENT//////////////////////
+	private void moveDiagonalUpLeft(){
+			 currentSprite = left;
+			int newX = x-BasicMap.TILESIZE;
+			int newY = y-BasicMap.TILESIZE;
+			if (isTaken(newX, newY))
+				attack(newX,newY);
+			else if (!(map.hasCollision(newX, newY)))
+				{
+				updatePosition(newX,newY);
+				x = newX;
+				y = newY;
+				
+				if (map.isStairs(x, y)){
+					onStairs = true;
+					}
+				if (map.isWin(x, y))
+					{
+					GameScreen.setWin(true);
+					}
+				}
+		 }
+	
+	
+	private void moveUp(){
+			currentSprite = up;
+			int newY = y - BasicMap.TILESIZE;
+			if (isTaken(x,newY))
+				attack(x, newY);
+			else if (!(map.hasCollision(x, newY))){
+				updatePosition(x,newY);
+				y = newY;
+				if (map.isStairs(x, y)){
+					onStairs = true;
+					}
+				if (map.isWin(x, y))
+				{
+				GameScreen.setWin(true);
+				}
+			
+			}
+			
+		}
+		
+		
+	private void moveDiagonalUpRight(){
+			currentSprite = right;
+			int newX = x + BasicMap.TILESIZE;
+			int newY = y - BasicMap.TILESIZE;
+			
+			if (isTaken(newX, newY))
+				attack(newX, newY);
+			else if (!(map.hasCollision(newX, newY)))	
+				{
+					updatePosition(newX,newY);
+					y = newY;
+					x = newX;	
+					if (map.isStairs(x, y)){
+						onStairs = true;
+						}
+					if (map.isWin(x, y))
+					{
+					GameScreen.setWin(true);
+					}
+				
+				}
+		}
+
+	private void moveLeft(){	
+			currentSprite = left;
+			int newX = x-BasicMap.TILESIZE;
+			if (isTaken(newX, y))
+				attack(newX,y);
+			else if (!(map.hasCollision(newX, y))){
+				updatePosition(newX,y);
+				x = newX;
+				if (map.isStairs(x, y)){
+					onStairs = true;
+					}
+				if (map.isWin(x, y))
+				{
+				GameScreen.setWin(true);
+				}
+			
+			}
+			
+		}
+		
+	private void moveNowhere()
+			{
+			currentSprite = down;
+			if (map.isStairs(x, y)){
+				onStairs = true;
+				}
+			if (map.isWin(x, y))
+			{
+			GameScreen.setWin(true);
+			}
+		
+			}
+		
+	private void moveRight(){
+			currentSprite = right;
+			int newX = x + BasicMap.TILESIZE;
+			if  (isTaken(newX, y))
+				attack(newX,y);
+			else if (!(map.hasCollision(newX, y))){
+				updatePosition(newX,y);
+				x = newX;
+				if (map.isStairs(x, y)){
+					onStairs = true;
+					}
+				if (map.isWin(x, y))
+				{
+				GameScreen.setWin(true);
+				}
+			
+				}
+			}	
+		
+		
+	private void moveDiagonalDownLeft(){
+				currentSprite = left;
+				int newX = x-BasicMap.TILESIZE;
+				int newY = y +BasicMap.TILESIZE;
+				if (isTaken(newX, newY))
+					attack(newX, newY);
+				else if (!(map.hasCollision(newX,  newY)))
+					{
+					updatePosition(newX,newY);
+					x = newX;
+					y = newY;
+					if (map.isStairs(x, y)){
+						onStairs = true;
+						}
+					if (map.isWin(x, y))
+					{
+					GameScreen.setWin(true);
+					}
+				
+					}
+				}
+				
+	private void moveDown(){
+			currentSprite = down;
+			int newY = y +BasicMap.TILESIZE;
+			if (isTaken(x, newY))
+				attack (x, newY);
+			else if (!(map.hasCollision(x, newY))){
+				updatePosition(x,newY);
+				y = newY;
+				if (map.isStairs(x, y)){
+					onStairs = true;
+					}
+				if (map.isWin(x, y))
+				{
+				GameScreen.setWin(true);
+				}
+			
+				}
+			
+			}
+
+	private void moveDiagonalDownRight(){
+			currentSprite = right;
+			int newX = x+BasicMap.TILESIZE;
+			int newY = y+BasicMap.TILESIZE;
+				if (isTaken(newX, newY)){
+					attack(newX, newY);
+				}
+				else if (!(map.hasCollision(newX,newY)))
+					{
+					updatePosition(newX,newY);
+					x = newX;
+					y = newY;
+					if (map.isStairs(x, y)){
+						onStairs = true;
+						}
+					if (map.isWin(x, y))
+					{
+					GameScreen.setWin(true);
+					}
+				
+					}
+			
+				}
+	
+///////////METHOD DEALING WITH LEVELING UP////////////////////
+	public String addExperiencePoints(int points){
+		if (points <0)
+			return "Can't gain negative EXP";
+		
+		//Add points given
+		experiencePoints += points;
+		if (levelUp())
+		{
+			GameScreenAssets.queueTextLog.add("Woohoo! Player has leveled Up!");
+			SoundManager.playSoundEffect("res/sound/SFX/Level Up Ding.wav");
+			return "Player has leveled up";
+		}
+		return null;
+	}
+	
+	//Method used when the player levels up
+	private boolean levelUp(){
+		
+		if (experiencePoints >= pointsNextLevel){
+			playerLevel++;
+			
+			//Increase Maximum Health & Heal Up Completely
+			maxHealthPoints += 50;
+			healthPoints = maxHealthPoints;
+			criticalHitLimit += 5;
+			if (missFactor > 5)
+				missFactor -= 1;
+
+			//Decrease Experience Points used up
+			//Increase amount needed to next level
+			experiencePoints = experiencePoints-pointsNextLevel;
+			pointsNextLevel *= 2;
+			return true;
+			}
+		return false;
+	}
+
+		
+	public int getCurrentLevel(){return playerLevel;}
+	
+	public int getExperiencePoints(){return experiencePoints;}
+	
+	public int getPointsNextLevel() {return pointsNextLevel;}
+///////////METHODS DEALING WITH COMBAT///////////////////	
+	
+	private void attack(int monsterX, int monsterY){
+	CombatManager.attackLoop(this,criticalHitLimit, missFactor, monsterX, monsterY);	
+	}
+	
+	
+//////////Method dealing with stairs///////////////
+
+	public boolean getOnStairs(){return onStairs;}
+	
+	public void setOnStairs(boolean var){onStairs = var;}
+
+	///Methods dealing loading////
+	public void loadStats(int newLevel, int newExp, int newHealth)
+		{
+		playerLevel = newLevel;
+		experiencePoints = newExp;
+		pointsNextLevel = 10*(2*(newLevel));
+		maxHealthPoints = 30 + 50*(newLevel-1);
+		healthPoints = newHealth;
+		criticalHitLimit = 30+5*(newLevel-1);	
+		missFactor = 10 - 5*(newLevel-1);
+		}
+		
+		
+		public void setPosition(int newX, int newY)
+		{
+			x = newX;
+			y = newY;
+		}
+	
+}
+
diff --git a/src/testRelated/BasicMapTest.java b/src/testRelated/BasicMapTest.java
new file mode 100644
index 0000000..a733110
--- /dev/null
+++ b/src/testRelated/BasicMapTest.java
@@ -0,0 +1,51 @@
+package test;
+
+import static org.junit.Assert.*;
+import mapRelated.BasicMap;
+
+import org.junit.Test;
+
+public class BasicMapTest {
+
+	//Check that map can tell if there's a collision at some given x,y
+	@Test
+	public void testHasCollision() {
+		char [][] test = new char [35][16];
+		test[3][4] = 'B';
+		BasicMap map = new BasicMap(test);
+		assertEquals(true, map.hasCollision(3*32,4*32));		
+		assertEquals(false, map.isStairs(4*32,6*32));
+		
+	}
+	
+	//Check that map can tell if there's stairs at some given x,y
+	@Test
+	public void testIsStairs(){
+		char [][] test = new char [35][16];
+		test[3][4] = 'S';
+		BasicMap map = new BasicMap(test);
+		assertEquals(true, map.isStairs(3*32,4*32));		
+		assertEquals(false, map.isStairs(4*32,6*32));
+	}
+	
+	//Check that the map will reject invalid stairs input
+	@Test
+	public void testInvalidStairsInput(){
+		char [][] test = new char [35][16];
+		test [3][4] = 'S';
+		BasicMap map = new BasicMap(test);
+		assertEquals(false,map.isStairs(-40,-21));
+		
+	}
+	
+	//Check that the map will reject invalid collision input
+	@Test
+	public void testInvalidCollisioninput(){
+		char [][] test = new char [35][16];
+		test[3][4] = 'S';
+		BasicMap map = new BasicMap(test);
+		assertEquals(false, map.hasCollision(-40,-21));
+		
+	}
+	
+}
diff --git a/src/testRelated/BasicMonsterTest.java b/src/testRelated/BasicMonsterTest.java
new file mode 100644
index 0000000..f0d639d
--- /dev/null
+++ b/src/testRelated/BasicMonsterTest.java
@@ -0,0 +1,349 @@
+package test;
+
+import static org.junit.Assert.*;
+import mapRelated.BasicMap;
+import monsterRelated.BasicMonster;
+import monsterRelated.Entity;
+
+import org.junit.Test;
+import org.newdawn.slick.SlickException;
+
+public class BasicMonsterTest {
+	
+	//Tests that the basic monster will move around the map properly
+	@Test
+	public void testGenericMove() throws SlickException{
+		//Arrange Data
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		String [][] test = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i < BasicMap.widthByTiles; i++){
+			for (int c = 0; c < BasicMap.heightByTiles; c++){
+				test [i][c] = " ";
+				testMap[i][c] = ' ';
+				}
+			}
+		BasicMap map = new BasicMap(testMap);
+		test[5][4] = "P";		
+		BasicMonster b = new BasicMonster (map, 7*BasicMap.TILESIZE, 7*BasicMap.TILESIZE, 0);
+		b.setEntityArray(test);
+		
+		//Act
+		int [] testPosition = {5*BasicMap.TILESIZE,4*BasicMap.TILESIZE};//Not in the way player
+		int [] monsterPos = {8*BasicMap.TILESIZE, 7*BasicMap.TILESIZE};//Monster's supposed current position
+			
+		//Assert
+		assertEquals(false, b.isTaken(8*BasicMap.TILESIZE,7*BasicMap.TILESIZE));
+		
+		//Act
+		b.update(testPosition,4000);//Move over by one.
+		
+		//Assert
+		assertArrayEquals(monsterPos, b.getPosition());
+		
+	}
+	
+	//Checks that the player's location has not been overwritten or erased by another class
+	@Test
+	public void testPlayerMissing(){
+		
+		//Arrange Data
+		BasicMap map = new BasicMap();
+		BasicMonster b = new BasicMonster (map, 4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, 0);
+		String [][] test = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i < BasicMap.widthByTiles; i++){
+			for (int c = 0; c < BasicMap.heightByTiles; c++){
+				test [i][c] = " ";
+				}
+			}
+		b.setEntityArray(test);
+		int[] testPosition = {5*BasicMap.TILESIZE, 8*BasicMap.TILESIZE};
+		assertEquals(false, ((Entity)b).isTaken(testPosition[0], testPosition[1]));
+		
+		//Assert and Act
+		assertEquals("Player has disappeared from the map.",b.update(testPosition,4000));//Has an error message.
+	
+	}
+	
+	//Checks that the monster update never overlaps the player
+	@Test
+	public void testMonsterOverlappedPlayer(){
+		//Arrange Data
+				BasicMap map = new BasicMap();
+				BasicMonster b = new BasicMonster (map, 4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, 0);
+				String [][] test = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+				for (int i = 0; i < BasicMap.widthByTiles; i++){
+					for (int c = 0; c < BasicMap.heightByTiles; c++){
+						test [i][c] = " ";
+						}
+					}
+				
+				b.setEntityArray(test);
+				int[] testPosition = {5*BasicMap.TILESIZE, 8*BasicMap.TILESIZE};
+				assertEquals(false, ((Entity)b).isTaken(testPosition[0], testPosition[1]));
+				test[5][8] = "M";
+				//Assert and Act
+				assertEquals("Player has disappeared from the map.",b.update(testPosition,4000));//Has an error message.
+			
+		
+	}
+	
+	
+	
+	//Tests the experience points gained from a kill
+	@Test
+	public void testExpPointGain() throws SlickException{
+		BasicMap map = new BasicMap();
+		
+		BasicMonster m = new BasicMonster (map, 10,10,100);
+		assertEquals(1000, m.getMaxHealthPoints());
+		assertEquals(510, m.getExpPointGain());
+	}
+	
+    //Tests that monsters are erased from the map when they die
+	@Test
+	public void testMonsterDead(){	
+	String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+	char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+	testArray [4][5] = "P";
+	BasicMap map = new BasicMap(testMap);
+	BasicMonster m = new BasicMonster (map, 9*BasicMap.TILESIZE, 5*BasicMap.TILESIZE,100);
+	m.setEntityArray(testArray);
+    m.subtractHealth(1000);
+    
+    assertEquals(false, m.getAlive());
+	int [] playerPosition = {4*BasicMap.TILESIZE,5*BasicMap.TILESIZE};
+    m.update(playerPosition, 400);
+    int [] expectedPosition = {9*BasicMap.TILESIZE, 5*BasicMap.TILESIZE};
+    assertArrayEquals(expectedPosition, m.getPosition());
+	}
+
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////TESTS ABILITY TO FIND THE CLOSEST SPOT NEAR A PLAYER TO "FOLLOW" THEM.//////////////////////////////////
+	
+	@Test
+	public void testFollowPlayerLeft() throws SlickException{
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		testArray[4][5] = "P";
+		int [] playerPosition = {4*BasicMap.TILESIZE,5*BasicMap.TILESIZE};
+		
+		BasicMap map = new BasicMap(testMap);
+		
+		BasicMonster b = new BasicMonster(map, 6*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, 0);
+		b.setEntityArray(testArray);
+		int [] expected = {5*BasicMap.TILESIZE,5*BasicMap.TILESIZE};
+		
+		b.update(playerPosition, 400);
+		assertArrayEquals(expected, b.getPosition());
+	}
+	
+
+	@Test
+	public void testFollowPlayerBelow() throws SlickException{
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		testArray[5][7] = "P";
+		int [] playerPosition = {5*BasicMap.TILESIZE,7*BasicMap.TILESIZE};
+		
+		BasicMap map = new BasicMap(testMap);
+		
+		BasicMonster b = new BasicMonster(map, 5*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, 0);
+		b.setEntityArray(testArray);
+		int [] expected = {5*BasicMap.TILESIZE,6*BasicMap.TILESIZE};
+		assertEquals(true, b.search("P"));
+		b.update(playerPosition, 400);
+		assertArrayEquals(expected, b.getPosition());
+	}
+	
+	@Test
+	public void testFollowPlayerRight() throws SlickException{
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		testArray[7][5] = "P";
+		int [] playerPosition = {7*BasicMap.TILESIZE,5*BasicMap.TILESIZE};
+		
+		BasicMap map = new BasicMap(testMap);
+		
+		BasicMonster b = new BasicMonster(map, 5*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, 0);
+		b.setEntityArray(testArray);
+		int [] expected = {6*BasicMap.TILESIZE,5*BasicMap.TILESIZE};
+		assertEquals(true, b.search("P"));
+		b.update(playerPosition, 400);
+		assertArrayEquals(expected, b.getPosition());
+	}
+	
+	@Test
+	public void testFollowPlayerUp() throws SlickException{
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		testArray[5][7] = "P";
+		int [] playerPosition = {5*BasicMap.TILESIZE,7*BasicMap.TILESIZE};
+		
+		BasicMap map = new BasicMap(testMap);
+		
+		BasicMonster b = new BasicMonster(map, 5*BasicMap.TILESIZE, 9*BasicMap.TILESIZE, 0);
+		b.setEntityArray(testArray);
+		int [] expected = {5*BasicMap.TILESIZE,8*BasicMap.TILESIZE};
+		assertEquals(true, b.search("P"));
+		b.update(playerPosition, 400);
+		assertArrayEquals(expected, b.getPosition());
+	}
+	
+	@Test
+	public void testFollowPlayerDiagonalUpLeft() throws SlickException{
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		testArray[5][5] = "P";
+		int [] playerPosition = {5*BasicMap.TILESIZE,5*BasicMap.TILESIZE};
+		
+		BasicMap map = new BasicMap(testMap);
+		
+		BasicMonster b = new BasicMonster(map, 7*BasicMap.TILESIZE, 7*BasicMap.TILESIZE, 0);
+		b.setEntityArray(testArray);
+		int [] expected = {6*BasicMap.TILESIZE,6*BasicMap.TILESIZE};
+		assertEquals(true, b.search("P"));
+		b.update(playerPosition, 400);
+		assertArrayEquals(expected, b.getPosition());
+	}
+	
+	@Test
+	public void testFollowPlayerDiagonalUpRight() throws SlickException{
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		testArray[7][3] = "P";
+		int [] playerPosition = {7*BasicMap.TILESIZE,3*BasicMap.TILESIZE};
+		
+		BasicMap map = new BasicMap(testMap);
+		
+		BasicMonster b = new BasicMonster(map, 5*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, 0);
+		b.setEntityArray(testArray);
+		int [] expected = {6*BasicMap.TILESIZE,4*BasicMap.TILESIZE};
+		assertEquals(true, b.search("P"));
+		b.update(playerPosition, 400);
+		assertArrayEquals(expected, b.getPosition());
+	}
+	
+	@Test
+	public void testFollowPlayerDiagonalDownLeft() throws SlickException{
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		testArray[5][9] = "P";
+		int [] playerPosition = {5*BasicMap.TILESIZE,9*BasicMap.TILESIZE};
+		
+		BasicMap map = new BasicMap(testMap);
+		
+		BasicMonster b = new BasicMonster(map, 7*BasicMap.TILESIZE, 7*BasicMap.TILESIZE, 0);
+		b.setEntityArray(testArray);
+		int [] expected = {6*BasicMap.TILESIZE,8*BasicMap.TILESIZE};
+		assertEquals(true, b.search("P"));
+		b.update(playerPosition, 400);
+		assertArrayEquals(expected, b.getPosition());
+	}
+	
+	@Test
+	public void testFollowPlayerDiagonalDownRight() throws SlickException{
+		//Arrange Data
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		testArray[7][9] = "P";
+		int [] playerPosition = {7*BasicMap.TILESIZE,9*BasicMap.TILESIZE};
+		
+		BasicMap map = new BasicMap(testMap);
+		
+		BasicMonster b = new BasicMonster(map, 5*BasicMap.TILESIZE, 7*BasicMap.TILESIZE, 0);
+		b.setEntityArray(testArray);
+		int [] expected = {6*BasicMap.TILESIZE,8*BasicMap.TILESIZE};		
+		assertEquals(true, b.search("P"));
+		
+		//Act
+		b.update(playerPosition, 400);
+		//Assert
+		assertArrayEquals(expected, b.getPosition());
+	}
+	
+
+	
+	
+}
diff --git a/src/testRelated/CombatManagerTest.java b/src/testRelated/CombatManagerTest.java
new file mode 100644
index 0000000..e397425
--- /dev/null
+++ b/src/testRelated/CombatManagerTest.java
@@ -0,0 +1,42 @@
+package test;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.LinkedList;
+
+import managers.CombatManager;
+import mapRelated.BasicMap;
+import monsterRelated.BasicMonster;
+
+import org.junit.Test;
+
+import playerRelated.Player;
+
+public class CombatManagerTest {
+
+	
+	
+	//Tests when no monster reference is found for combat
+	@Test
+	public void testMonsterRefNotFound(){
+		//Arrange
+		Player p = new Player(4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE);
+		//Act and Assert
+		assertEquals("Error! No Monster Found to Fight",CombatManager.attackLoop(p, 400, 10, 1, 2));
+	}
+	
+	//Tests that monster references can be found for combat
+	@Test
+	public void testMonsterRefFound(){
+		//Arrange
+		Player p = new Player(4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE);
+		LinkedList<BasicMonster> testMonsterList = new LinkedList<BasicMonster>();
+		BasicMap map = new BasicMap();
+		BasicMonster m = new BasicMonster(map, 3*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, 4000);
+		testMonsterList.add(m);
+		CombatManager.setMonsterList(testMonsterList);
+		
+		//Act and assert
+		assertEquals(null, CombatManager.attackLoop(p, 300,10, 3*BasicMap.TILESIZE, 5*BasicMap.TILESIZE));
+	}
+}
diff --git a/src/testRelated/EntityTest.java b/src/testRelated/EntityTest.java
new file mode 100644
index 0000000..5f95f13
--- /dev/null
+++ b/src/testRelated/EntityTest.java
@@ -0,0 +1,302 @@
+package test;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import mapRelated.BasicMap;
+import monsterRelated.Entity;
+
+import org.junit.Test;
+
+public class EntityTest {
+	
+///////ENTITY ARRAY TESTS///////////
+	
+	//Valid entity array with no nulls for spaces
+	@Test
+	public void testValidEntityArray(){
+			//Arrange
+			Entity e = new Entity(3*32,7*32);
+			String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+			for (int i = 0; i < BasicMap.widthByTiles; i++)
+			{
+				for (int c = 0; c < BasicMap.heightByTiles; c++)
+				{
+					testArray[i][c] = " ";
+				}
+			}
+			
+			//Act and assert
+			assertEquals(null,e.setEntityArray(testArray));	
+	}
+	
+	@Test
+	public void test_Invalid_EntityArray_Size(){
+		Entity e = new Entity(3*32,4*32);
+		String [][] testArray = new String [25][15];
+		assertEquals("Entity Array Not Expected Size",e.setEntityArray(testArray));
+	}
+
+	@Test
+	public void test_Full_Of_Null_EntityArray(){
+		Entity e = new Entity(3*32,4*32);
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		assertEquals("EntityArray cannot have null objects", e.setEntityArray(testArray));
+		
+	}
+	@Test
+	public void test_NullReference_EntityArray(){
+		Entity e = new Entity (3*32, 4*32);
+		assertEquals("Error No EntityArray Found!", e.setEntityArray(null));
+	}
+	
+	
+
+	//TEST SEARCH	
+	@Test
+	public void testSearchOneCreature() {
+		//Arrange
+		Entity c = new Entity(4*32,4*32);
+		String [][] test = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+			{
+				test[i][d] = " ";
+			}
+		}
+		test[3][4] = "M";	
+		
+		//Act and Assert
+		assertEquals(null,c.setEntityArray(test));
+		
+		String[][] test1 = c.getEntityArray();
+		//Test if the we /definitely/ have the same array inside this creature
+		assertArrayEquals(test, test1);
+		//Test to see if there is a Player nearby
+		assertEquals(false, c.search("P"));
+		//Test to see if there is an 'M' or essentially if it can spot itself
+		assertEquals(true, c.search("M"));
+	}
+	
+	//Test update position
+	@Test
+	public void testInvalidPostion(){
+		Entity e = new Entity(5*32,5*32);
+		String [][] test = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+			{
+				test[i][d] = " ";
+			}
+		}
+		e.setEntityArray(test);
+		assertEquals("Out of Bounds", e.updatePosition(-100,-100));
+	}
+	
+	
+	
+	
+	
+	//Tests that a monster wanders around the map
+	@Test
+	public void testWanderCreature(){
+		//Arrange
+		Entity c = new Entity(3*32, 4*32);
+		c.setName("M");
+		String [][] test = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				test[i][d] = " ";
+		}
+		//Act
+		c.setEntityArray(test);
+		c.updatePosition(5*32, 7*32);
+		c.updatePosition(2*32, 4*32);
+		c.updatePosition(5*32, 5*32);
+		
+
+		String [][] test2 = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				test2[i][d] = " ";
+		}
+		test2[5][5] = "M";
+		
+		//Assert
+		assertArrayEquals(test2,c.getEntityArray());
+		
+	}
+	
+	@Test
+	public void testSetPositionOneCreature(){
+		//Test Set-Up
+		Entity c = new Entity(3*32, 4*32);
+		c.setName("M");
+		//We /have/ to create an array with " " in every spot.
+		//Hence the terrible need for loop logic.
+		String [][] test = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				test[i][d] = " ";
+		}
+		//Writes an 'M' in a spot that we later erase.
+		test[3][4] = "M";
+		c.setEntityArray(test);
+		
+		//Updates the position of the creature
+		c.updatePosition(4*32, 4*32);
+		
+		//Create a blank another array to compare to
+		String[][] testEntity = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				testEntity[i][d] = " ";
+		}
+		//Manually store the new position
+		testEntity[4][4] = "M";
+		//Get the entityArray for this creature 
+		String[][] entityArray = c.getEntityArray();
+		//Check if they are the same.
+		assertArrayEquals(testEntity, entityArray);
+	}
+
+	//Tests two moving creatures do not overlap each other when they interact
+	@Test
+	public void testTwoMovingCreatures(){
+		Entity c = new Entity(5*32,2*32);
+		Entity c2 = new Entity(7*32,9*32);
+		
+		String [][] testEntity = new String[BasicMap.widthByTiles][ BasicMap.heightByTiles];
+		
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				testEntity[i][d] = " ";
+		}
+		testEntity[3][5] = "T";
+		testEntity[5][5] = "B";
+		c.setEntityArray(testEntity);
+		c2.setEntityArray(testEntity);
+		
+		c.updatePosition(9*32, 9*32);
+		c2.updatePosition(5*32, 1*32);
+		
+		assertEquals(true, c2.isTaken(9*32, 9*32)); //C2 knows where the update position of c
+		assertArrayEquals(c.getEntityArray(), c2.getEntityArray());//They both have the same array
+		
+	}
+	
+	//Tests that the isTaken method rejects invalid input
+	@Test
+	public void testIsTakenNegativeInput(){
+		Entity e = new Entity (4*32,5*32);
+		assertEquals(false, e.isTaken(-10,-20));	
+	}
+	
+
+	//Checks for an entity at a given x,y
+	@Test
+	public void testIsTakenOneCreature(){
+		//Set-Up Test
+		String[][] testEntity = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				testEntity[i][d] = " ";
+		}
+		testEntity[3][5] = "T";
+		Entity c = new Entity(3*32, 5*32);
+		c.setName("T");
+		c.setEntityArray(testEntity);
+		
+		//The entity array should know there is something in the array.
+		assertEquals(false, c.isTaken(4*32,5*32));
+		assertEquals(true,c.isTaken(3*32,5*32));
+	}
+	
+	//Checks how two entities work around each other with the isTaken method
+	@Test
+	public void testIsTakenTwoCreatures(){
+		String[][] testEntity = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				testEntity[i][d] = " ";
+		}
+		testEntity[3][5] = "T";
+		testEntity[5][5] = "B";
+		Entity c = new Entity(3*32, 5*32);
+		Entity c2 = new Entity(5*32, 5*32);
+		c.setName("T");
+		c.setName("B");
+		c.setEntityArray(testEntity);
+		c2.setEntityArray(testEntity);
+		//The entity array should know there is something in the array.
+		assertEquals(false, c.isTaken(4*32,5*32));
+		assertEquals(true,c.isTaken(5*32,5*32));
+		assertEquals(false, c2.isTaken(2*32, 6*32));
+		assertEquals(true, c.isTaken(3*32,5*32));
+	}
+	
+	
+	
+	
+///////////////////////////////////////////////////////////////////////////////////////////////	
+//Combat METHOD TESTS
+///////////////////////////////////////////////////////////////////////////////////////////////	
+	//Tests that the method rejects negative subtraction
+	@Test
+	public void testSubtractNegativePoints(){
+		Entity e = new Entity (4,5);
+		assertEquals("Cannot subtract negative health points", e.subtractHealth(-10));		
+	}
+	
+	@Test
+	public void testSubtractHealthPoints(){
+		Entity e = new Entity (4,5);
+		assertEquals(null, e.subtractHealth(10));
+	}
+	
+	//Tests entities (players or monsters) die when they reach zero
+	@Test
+	public void testDead(){
+		Entity e = new Entity(4,5);
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+			}
+		}
+		e.setEntityArray(testArray);
+		e.subtractHealth(1000);
+		
+		assertEquals(false, e.getAlive());
+		assertEquals(0, e.getHealthPoints());
+	}
+	
+	
+	@Test
+	public void testAddValidHealthPoints(){
+		Entity e = new Entity(4,5);
+		assertEquals(null, e.addHealthPoints(10));
+		assertEquals(null, e.addHealthPoints(10));
+		assertEquals(30, e.getHealthPoints());
+	}
+	
+	//Rejects invalid additions of health points.
+	@Test
+	public void testAddNegativeHealthPoints(){
+		Entity e = new Entity(4,5);
+		assertEquals("Cannot add negative health points", e.addHealthPoints(-50));	
+		
+	}
+	
+
+}
diff --git a/src/testRelated/GameScreenAssetsTest.java b/src/testRelated/GameScreenAssetsTest.java
new file mode 100644
index 0000000..33905ae
--- /dev/null
+++ b/src/testRelated/GameScreenAssetsTest.java
@@ -0,0 +1,35 @@
+package test;
+
+import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import gameStates.GameScreenAssets;
+
+import org.junit.Test;
+
+public class GameScreenAssetsTest {
+
+
+	//Checks that text log counters works as expected
+	@Test
+	public void testTextLogCounter(){
+		GameScreenAssets game = new GameScreenAssets();
+		assertEquals(1, game.updateTextLog(0));
+	}
+	
+	//Tests that text log counter resets
+	@Test
+	public void testTextLogUpdate(){
+		GameScreenAssets game = new GameScreenAssets();
+		assertEquals(0, game.updateTextLog(201));
+		
+	}
+	
+	//Tests that it rejects invalid counter numbers
+	@Test
+	public void testTextLogInvalidCounter(){
+		GameScreenAssets game = new GameScreenAssets();
+		assertEquals(0, game.updateTextLog(-100));
+		
+	}
+}
diff --git a/Version 1.1/NewestVersion/src/test/LoadingGameTest.java b/src/testRelated/LoadingGameTest.java
similarity index 100%
rename from Version 1.1/NewestVersion/src/test/LoadingGameTest.java
rename to src/testRelated/LoadingGameTest.java
diff --git a/src/testRelated/MonsterManagerTest.java b/src/testRelated/MonsterManagerTest.java
new file mode 100644
index 0000000..c749c92
--- /dev/null
+++ b/src/testRelated/MonsterManagerTest.java
@@ -0,0 +1,376 @@
+package test;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import managers.MonsterManager;
+import mapRelated.BasicMap;
+
+import org.junit.Test;
+import org.newdawn.slick.SlickException;
+
+public class MonsterManagerTest {
+
+	@Test
+	public void testInvalidEntityArray(){
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [25][15];
+		assertEquals("Entity Array Not Expected Size",m.checkEntityArray(testArray));
+	}
+	
+	@Test
+	public void testNullEntityArray(){
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		assertEquals("EntityArray cannot have null objects", m.checkEntityArray(testArray));
+		
+	}
+	
+	
+	@Test
+	public void testValidEntityArray(){
+		//Arrange
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+			}
+		}
+		testArray[4][5] = "P";
+		
+		//Act and assert
+		assertEquals(null,m.checkEntityArray(testArray));	
+	}
+
+	
+	@Test
+	public void testPlayerNotInEntityArray(){
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+			}
+		}
+		assertEquals("Player has disappeared off entityArray","Player not in EntityArray",m.checkEntityArray(testArray));	
+	}
+	
+	
+	@Test
+	public void testCheckValidPlacement(){
+		//Arrange
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+
+		//Double check that its a valid entity Array
+		assertEquals("Invalid Entity Array", m.setEntityArray(testArray));
+		testArray[5][7] = "P";
+		assertEquals(null, m.setEntityArray(testArray));
+		int [] testPosition = {4*BasicMap.TILESIZE,5*BasicMap.TILESIZE};
+		
+		
+		
+		
+		assertEquals(null, m.checkValidPlacement(testPosition, 4, new BasicMap(testMap), testArray));
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = 'B';
+			}
+		}
+		testMap[31][15] = ' ';
+		testMap[32][15] = ' ';
+		testMap[33][15] = ' ';
+		
+		testPosition[0] = 992;
+		testPosition[1] = 480;
+		assertEquals("Map Overlap", m.checkValidPlacement(testPosition, 4, new BasicMap (testMap), testArray));
+		
+	}
+
+	
+	@Test
+	public void testInvalidPositionGenerated(){
+		
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		BasicMap map = new BasicMap (testMap);
+		int [] newPosition = {-100,-100};
+		assertEquals("Out of Bounds", m.checkValidPlacement(newPosition, 4, map, testArray));
+		int [] thirdTestPosition = {1120, 512};
+		assertEquals("Out of Bounds", m.checkValidPlacement(thirdTestPosition, 4, map, testArray));
+	}
+	
+
+	
+	
+	
+	
+	@Test
+	public void testCheckOutOfBoundsPlacements(){
+		//Arrange
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap[i][c] = ' ';
+			}
+		}
+
+		//Double check that its a valid entity Array
+		assertEquals("Invalid Entity Array", m.setEntityArray(testArray));
+		testArray[5][7] = "P";
+		assertEquals(null, m.setEntityArray(testArray));
+		int [] testPosition = {2000,5};
+		
+			
+		assertEquals("Do not place monsters out of game's boundaries","Out of Bounds", m.checkValidPlacement(testPosition, 4, new BasicMap(testMap), testArray));
+	}
+
+	
+	
+	
+	@Test
+	public void testCheckEntityOverlap(){
+		//Arrange
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				 testMap[i][c] = ' ';
+				
+			}
+		}
+
+		//Double check that its a valid entity Array
+		assertEquals("Invalid Entity Array", m.setEntityArray(testArray));
+		testArray[5][7] = "P";
+		assertEquals(null, m.setEntityArray(testArray));
+		int [] testPosition = {5*BasicMap.TILESIZE,7*BasicMap.TILESIZE};
+				
+		assertEquals("Should be preventing placement over the player and other monsters","Entity Overlap", m.checkValidPlacement(testPosition, 4, new BasicMap(testMap), testArray));
+	}
+	
+	
+	@Test
+	public void testCheckMapOverlap(){
+		//Arrange
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap[i][c] = ' ';
+			}
+		}
+
+		//Double check that its a valid entity Array
+		assertEquals("Invalid Entity Array", m.setEntityArray(testArray));
+		testArray[5][7] = "P";
+		assertEquals(null, m.setEntityArray(testArray));
+		int [] testPosition = {9*BasicMap.TILESIZE,9*BasicMap.TILESIZE};
+		
+		
+		testMap[9][9] = 'B';
+		
+		assertEquals("We should be preventing placement that overlaps obstacles","Map Overlap", m.checkValidPlacement(testPosition, 4, new BasicMap(testMap), testArray));
+	}
+//	
+	@Test
+	public void testFindPlacement_NoBlocks (){
+		//Arrange
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap[i][c] = ' ';
+			}
+		}
+		int [] testPosition = m.findValidPlacement(4, new BasicMap(testMap), testArray);
+		
+		assertNotNull(testPosition);
+		
+	}
+
+	
+	@Test
+	public void testFindPlacement_OneSpotLeft_EntityArrayOnly (){
+		//Arrange
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = "M";
+				testMap[i][c] = ' ';
+			}
+		}
+		testArray[30][15] = " ";
+		testArray[31][15] = " ";
+		testArray[32][15] = " ";
+		testArray[33][15] = " ";
+		
+		MonsterManager m = new MonsterManager();
+		m.setEntityArray(testArray);
+		int [] testPosition = m.findValidPlacement(4, new BasicMap(testMap), testArray);
+		int [] expectedPosition = {30*BasicMap.TILESIZE,15*BasicMap.TILESIZE};
+		assertArrayEquals("Check that it can find Valid last spot",expectedPosition, testPosition);
+		
+	}
+	
+	@Test
+	public void testFindPlacement_OneSpotLeft_Edges(){
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = "M";
+				testMap[i][c] = ' ';
+			}
+		}
+		testArray[31][15] = " ";
+		testArray[32][15] = " ";
+		testArray[33][15] = " ";
+		testArray[34][15] = " ";
+		
+		MonsterManager m = new MonsterManager();
+		m.setEntityArray(testArray);
+		int [] testPosition = m.findValidPlacement(4, new BasicMap(testMap), testArray);
+		int [] expectedPosition = {31*BasicMap.TILESIZE,15*BasicMap.TILESIZE};
+		assertArrayEquals("Check that it can find corners",expectedPosition, testPosition);
+		
+		testArray[31][15] = "M";
+		testArray[32][15] = "M";
+		testArray[33][15] = "M";
+		testArray[34][15] = "M";
+	
+		testArray[34][12] = " ";
+		testArray[34][13] = " ";
+		testArray[34][14] = " ";
+		testArray[34][15] = " ";
+		testPosition = m.findValidPlacement(4, new BasicMap(testMap), testArray);
+		assertArrayEquals("Check that it cannot look vertically" ,null, testPosition);
+	}
+	
+	
+	
+	@Test
+	public void testFindPlacement_OneSpotLeft_MapArrayOnly (){
+		//Arrange
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap[i][c] = 'B';
+			}
+		}
+		
+		
+		testMap[30][15] = ' ';
+		testMap[31][15] = ' ';
+		testMap[32][15] = ' ';
+		testMap[33][15] = ' ';
+		
+		MonsterManager m = new MonsterManager();
+		int [] testPosition = m.findValidPlacement(4, new BasicMap(testMap), testArray);
+		int [] expectedPosition = {30*BasicMap.TILESIZE,15*BasicMap.TILESIZE};
+		assertArrayEquals("Check that it can see overlap with map",expectedPosition, testPosition);
+		
+	}
+
+	
+	
+	
+	@Test
+	public void testFindPlacement_NoSpotsLeft (){
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = "P";
+				testMap[i][c] = 'B';
+			}
+		}
+		int [] testPosition = new int [2];
+		testPosition = m.findValidPlacement(4, new BasicMap(testMap), testArray);
+		assertEquals( null, testPosition);
+	}
+	
+	
+	
+	@Test
+	public void testClearMonsters() throws SlickException{
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+			}
+		}
+		testArray[1][4] = "P";
+		assertEquals(null, m.setEntityArray(testArray));
+		assertEquals(null, m.clearMonsters());
+	}
+	
+}
diff --git a/src/testRelated/PlayerTest.java b/src/testRelated/PlayerTest.java
new file mode 100644
index 0000000..af95366
--- /dev/null
+++ b/src/testRelated/PlayerTest.java
@@ -0,0 +1,133 @@
+package test;
+
+import static org.junit.Assert.*;
+
+
+import mapRelated.BasicMap;
+
+import org.junit.Test;
+
+import playerRelated.Player;
+
+public class PlayerTest {
+
+
+	
+	@Test
+	public void testExperiencePoints(){
+		Player player = new Player (10, 10);
+		player.addExperiencePoints(10);
+		assertEquals(0, player.getExperiencePoints());
+		assertEquals(20,player.getPointsNextLevel());
+		player.addExperiencePoints(20);
+		assertEquals(40,player.getPointsNextLevel());
+		player.addExperiencePoints(40);
+		assertEquals(80,player.getPointsNextLevel());
+		player.addExperiencePoints(80);
+		assertEquals(160,player.getPointsNextLevel());
+		player.addExperiencePoints(160);
+		assertEquals(320,player.getPointsNextLevel());	
+		player.addExperiencePoints(320);
+		assertEquals(640,player.getPointsNextLevel());	
+		assertEquals(7, player.getCurrentLevel());
+		
+	}
+
+	@Test
+	public void testNegativeExperiencePoints(){
+		//Arrange
+		Player player = new Player (10,10);		
+		assertEquals("Can't gain negative EXP",player.addExperiencePoints(-100));
+	}
+	@Test
+	public void test_NoLevelUp() {
+		Player player = new Player(10,10);
+		assertEquals(null, player.addExperiencePoints(1));
+	}
+	
+	
+	@Test 
+	public void testPlayerLevelUp(){
+		Player player = new Player (10,10);		
+		assertEquals("Player has leveled up",player.addExperiencePoints(2000));
+	}
+	
+	@Test
+	public void testPlayerMovement(){
+		
+		//Mock keyboard was call upon private method player movement
+		//The private methods would've originally been called depending on input from the keyboard
+		//In it's place characters have been used to individually call each method.
+		//Reflections (Private Objects for Java) proved to carry too many complications than it was worth.
+		
+		String [][] testArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		BasicMap map = new BasicMap(testMap);
+		Player p = new Player(4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, map);
+		p.setEntityArray(testArray);
+		int [] expected = {3*BasicMap.TILESIZE, 5*BasicMap.TILESIZE};
+		p.mockKeyBoard('l');
+		assertArrayEquals(expected, p.getPosition());
+		p.mockKeyBoard('r');
+		expected [0] = 4*BasicMap.TILESIZE;
+		assertArrayEquals(expected, p.getPosition());
+		expected [1] = 6*BasicMap.TILESIZE;
+		p.mockKeyBoard('d');
+		assertArrayEquals(expected, p.getPosition());
+		expected [1] = 5*BasicMap.TILESIZE;
+		p.mockKeyBoard('u');
+		assertArrayEquals(expected, p.getPosition());
+		
+		p.mockKeyBoard('a');
+		expected [0] -= BasicMap.TILESIZE;
+		expected [1] -= BasicMap.TILESIZE;
+		assertArrayEquals(expected, p.getPosition());
+		
+		p.mockKeyBoard('b');
+		expected [0] += BasicMap.TILESIZE;
+		expected [1] -= BasicMap.TILESIZE;
+		assertArrayEquals(expected, p.getPosition());
+		
+		p.mockKeyBoard('c');
+		expected [0] -= BasicMap.TILESIZE;
+		expected [1] += BasicMap.TILESIZE;
+		assertArrayEquals(expected, p.getPosition());
+		
+		
+		p.mockKeyBoard('f');
+		expected [0] += BasicMap.TILESIZE;
+		expected [1] += BasicMap.TILESIZE;
+		
+		assertArrayEquals(expected, p.getPosition());
+		p.mockKeyBoard('y');
+		assertArrayEquals(expected, p.getPosition());
+		p.mockKeyBoard('g');
+		assertArrayEquals(expected, p.getPosition());		
+	}
+	
+	/*
+	@Test
+	public void testPlayerMoveUp() throws SecurityException, NoSuchMethodException, IllegalAccessException,InvocationTargetException{
+		Player p = new Player(4*BasicMap.TILESIZE,5*BasicMap.TILESIZE);
+
+		Method privateUpMethod = Player.class.getDeclaredMethod("moveUp", String.class);
+
+		privateUpMethod.setAccessible(true);
+
+	    privateUpMethod.invoke(p, null);
+
+	}
+	*/	
+		
+		
+}
+

commit 652da0f9d8a8bab10c303a3ef51cda584f42eb60
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 08:14:17 2017 -0600

    Created Test for LoadingGame

diff --git a/.classpath b/.classpath
index 16fdc9c..76bf31b 100644
--- a/.classpath
+++ b/.classpath
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
 	<classpathentry exported="true" kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
-	<classpathentry kind="src" path="Version 1.1/NewestVersion/src"/>
+	<classpathentry excluding="test/" kind="src" path="Version 1.1/NewestVersion/src"/>
 	<classpathentry kind="src" path="VERSION W.I.P/version w.i.p/src"/>
 	<classpathentry kind="lib" path="C:/Users/User/Downloads/slick/lib/ibxm.jar">
 		<attributes>
@@ -28,5 +28,6 @@
 			<attribute name="org.eclipse.jdt.launching.CLASSPATH_ATTR_LIBRARY_PATH_ENTRY" value="C:/Users/User/Downloads/slick"/>
 		</attributes>
 	</classpathentry>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
 	<classpathentry kind="output" path="VERSION W.I.P/version w.i.p/bin"/>
 </classpath>
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/Game$1.class b/VERSION W.I.P/version w.i.p/bin/gameStates/Game$1.class
deleted file mode 100644
index d5d22fc..0000000
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/Game$1.class and /dev/null differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/Game.class b/VERSION W.I.P/version w.i.p/bin/gameStates/Game.class
index ce420e1..3ece979 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/Game.class and b/VERSION W.I.P/version w.i.p/bin/gameStates/Game.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/GameOver.class b/VERSION W.I.P/version w.i.p/bin/gameStates/GameOver.class
index fbe3090..7b235ac 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/GameOver.class and b/VERSION W.I.P/version w.i.p/bin/gameStates/GameOver.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/GameOverScreen.class b/VERSION W.I.P/version w.i.p/bin/gameStates/GameOverScreen.class
new file mode 100644
index 0000000..d836625
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/gameStates/GameOverScreen.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreen.class b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreen.class
new file mode 100644
index 0000000..396c8c7
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreen.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets$1.class b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets$1.class
new file mode 100644
index 0000000..7e1da98
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets$1.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets.class b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets.class
index edb6ab5..d9187f5 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets.class and b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssets.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssetsTest.class b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssetsTest.class
index b95fb28..29ae901 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssetsTest.class and b/VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssetsTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/LoadGame.class b/VERSION W.I.P/version w.i.p/bin/gameStates/LoadGame.class
index f22d9fd..c7fac9d 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/LoadGame.class and b/VERSION W.I.P/version w.i.p/bin/gameStates/LoadGame.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/MainMenuScreen.class b/VERSION W.I.P/version w.i.p/bin/gameStates/MainMenuScreen.class
new file mode 100644
index 0000000..54954f7
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/gameStates/MainMenuScreen.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/Menu.class b/VERSION W.I.P/version w.i.p/bin/gameStates/Menu.class
index e387c71..8bb8df5 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/Menu.class and b/VERSION W.I.P/version w.i.p/bin/gameStates/Menu.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/StateManager.class b/VERSION W.I.P/version w.i.p/bin/gameStates/StateManager.class
index 100dd32..d0f0228 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/StateManager.class and b/VERSION W.I.P/version w.i.p/bin/gameStates/StateManager.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/TransitionScreen.class b/VERSION W.I.P/version w.i.p/bin/gameStates/TransitionScreen.class
index e8aa807..e6f8952 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/TransitionScreen.class and b/VERSION W.I.P/version w.i.p/bin/gameStates/TransitionScreen.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/Ver2GameDriver.class b/VERSION W.I.P/version w.i.p/bin/gameStates/Ver2GameDriver.class
index ce7b76a..1f913be 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/gameStates/Ver2GameDriver.class and b/VERSION W.I.P/version w.i.p/bin/gameStates/Ver2GameDriver.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/gameStates/WinScreen.class b/VERSION W.I.P/version w.i.p/bin/gameStates/WinScreen.class
new file mode 100644
index 0000000..f63f4db
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/gameStates/WinScreen.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/BasicButton.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/BasicButton.class
index 12c95db..b99edd5 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/BasicButton.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/BasicButton.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/BuildButton.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/BuildButton.class
index c58b2b0..33b6cde 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/BuildButton.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/BuildButton.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/ButtonAction.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/ButtonAction.class
index c199b7a..292d295 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/ButtonAction.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/ButtonAction.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/ButtonListener.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/ButtonListener.class
index 8c92e43..b6bb510 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/ButtonListener.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/ButtonListener.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons$1.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons$1.class
new file mode 100644
index 0000000..f745251
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons$1.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons$2.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons$2.class
new file mode 100644
index 0000000..7389e05
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons$2.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons.class
new file mode 100644
index 0000000..7cd5f35
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/inputRelated/EndGameButtons.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/LoadingGame.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/LoadingGame.class
index 2cffdf1..f37c324 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/LoadingGame.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/LoadingGame.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons$1.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons$1.class
index bde19a3..787b0c0 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons$1.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons$1.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons$2.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons$2.class
index e7e0cf2..6a746da 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons$2.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons$2.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons.class
index 08701d7..da41599 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/MainMenuButtons.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/SavingGame.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/SavingGame.class
index bfdf423..79a2e72 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/SavingGame.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/SavingGame.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/SlideOutMenu$1.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/SlideOutMenu$1.class
index 7c79a3e..bbe653f 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/SlideOutMenu$1.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/SlideOutMenu$1.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/inputRelated/SlideOutMenu.class b/VERSION W.I.P/version w.i.p/bin/inputRelated/SlideOutMenu.class
index cd39757..2a41c5c 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/inputRelated/SlideOutMenu.class and b/VERSION W.I.P/version w.i.p/bin/inputRelated/SlideOutMenu.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class b/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class
index ed87b9e..0d61b9b 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class and b/VERSION W.I.P/version w.i.p/bin/managers/CombatManager.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/managers/CombatManagerTest.class b/VERSION W.I.P/version w.i.p/bin/managers/CombatManagerTest.class
index e3df4f4..5c8e058 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/managers/CombatManagerTest.class and b/VERSION W.I.P/version w.i.p/bin/managers/CombatManagerTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/managers/EntityManager.class b/VERSION W.I.P/version w.i.p/bin/managers/EntityManager.class
index c0359d1..f4e053f 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/managers/EntityManager.class and b/VERSION W.I.P/version w.i.p/bin/managers/EntityManager.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class b/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class
index 9629caf..b5df8db 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class and b/VERSION W.I.P/version w.i.p/bin/managers/MonsterManager.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/managers/MonsterManagerTest.class b/VERSION W.I.P/version w.i.p/bin/managers/MonsterManagerTest.class
index 800fbec..2cc2eeb 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/managers/MonsterManagerTest.class and b/VERSION W.I.P/version w.i.p/bin/managers/MonsterManagerTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/managers/SoundManager.class b/VERSION W.I.P/version w.i.p/bin/managers/SoundManager.class
index a6fa1a9..c19d6a0 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/managers/SoundManager.class and b/VERSION W.I.P/version w.i.p/bin/managers/SoundManager.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMap.class b/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMap.class
index 47a5039..275e7f5 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMap.class and b/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMap.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMapTest.class b/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMapTest.class
index 9a72c6f..674317e 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMapTest.class and b/VERSION W.I.P/version w.i.p/bin/mapRelated/BasicMapTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class
index 3d37821..61332f5 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class and b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonster.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonsterTest.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonsterTest.class
index 968305c..e67bec0 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonsterTest.class and b/VERSION W.I.P/version w.i.p/bin/monsterRelated/BasicMonsterTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/Entity.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/Entity.class
index 5f1af12..ec3e43d 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/Entity.class and b/VERSION W.I.P/version w.i.p/bin/monsterRelated/Entity.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/EntityTest.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/EntityTest.class
index 0cdae3d..a347eda 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/EntityTest.class and b/VERSION W.I.P/version w.i.p/bin/monsterRelated/EntityTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/monsterRelated/PrintingTests.class b/VERSION W.I.P/version w.i.p/bin/monsterRelated/PrintingTests.class
index b57b221..bf13131 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/monsterRelated/PrintingTests.class and b/VERSION W.I.P/version w.i.p/bin/monsterRelated/PrintingTests.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class
index 17841b2..a1b5b3a 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class and b/VERSION W.I.P/version w.i.p/bin/playerRelated/Player.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerTest.class b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerTest.class
index 46b509e..037032c 100644
Binary files a/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerTest.class and b/VERSION W.I.P/version w.i.p/bin/playerRelated/PlayerTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/test/BasicMapTest.class b/VERSION W.I.P/version w.i.p/bin/test/BasicMapTest.class
new file mode 100644
index 0000000..57bc76f
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/test/BasicMapTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/test/BasicMonsterTest.class b/VERSION W.I.P/version w.i.p/bin/test/BasicMonsterTest.class
new file mode 100644
index 0000000..0f3f722
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/test/BasicMonsterTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/test/CombatManagerTest.class b/VERSION W.I.P/version w.i.p/bin/test/CombatManagerTest.class
new file mode 100644
index 0000000..f3cc01e
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/test/CombatManagerTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/test/EntityTest.class b/VERSION W.I.P/version w.i.p/bin/test/EntityTest.class
new file mode 100644
index 0000000..74c8791
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/test/EntityTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/test/GameScreenAssetsTest.class b/VERSION W.I.P/version w.i.p/bin/test/GameScreenAssetsTest.class
new file mode 100644
index 0000000..95b98d4
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/test/GameScreenAssetsTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/test/LoadingGameTest.class b/VERSION W.I.P/version w.i.p/bin/test/LoadingGameTest.class
new file mode 100644
index 0000000..5785f7c
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/test/LoadingGameTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/test/MonsterManagerTest.class b/VERSION W.I.P/version w.i.p/bin/test/MonsterManagerTest.class
new file mode 100644
index 0000000..272608c
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/test/MonsterManagerTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/bin/test/PlayerTest.class b/VERSION W.I.P/version w.i.p/bin/test/PlayerTest.class
new file mode 100644
index 0000000..62604c3
Binary files /dev/null and b/VERSION W.I.P/version w.i.p/bin/test/PlayerTest.class differ
diff --git a/VERSION W.I.P/version w.i.p/src/gameStates/Game.java b/VERSION W.I.P/version w.i.p/src/gameStates/Game1.java
similarity index 99%
rename from VERSION W.I.P/version w.i.p/src/gameStates/Game.java
rename to VERSION W.I.P/version w.i.p/src/gameStates/Game1.java
index 87344d4..9aab808 100644
--- a/VERSION W.I.P/version w.i.p/src/gameStates/Game.java	
+++ b/VERSION W.I.P/version w.i.p/src/gameStates/Game1.java	
@@ -23,7 +23,7 @@ import org.newdawn.slick.state.StateBasedGame;
 
 import playerRelated.Player;
 
-public class Game extends BasicGameState {
+public class Game1 extends BasicGameState {
 
 	//Used for quitting the game
 	private GameContainer gc;
diff --git a/VERSION W.I.P/version w.i.p/src/gameStates/GameScreenAssets.java b/VERSION W.I.P/version w.i.p/src/gameStates/GameScreenAssets1.java
similarity index 98%
rename from VERSION W.I.P/version w.i.p/src/gameStates/GameScreenAssets.java
rename to VERSION W.I.P/version w.i.p/src/gameStates/GameScreenAssets1.java
index d0d01b6..ca023c1 100644
--- a/VERSION W.I.P/version w.i.p/src/gameStates/GameScreenAssets.java	
+++ b/VERSION W.I.P/version w.i.p/src/gameStates/GameScreenAssets1.java	
@@ -12,7 +12,7 @@ import org.newdawn.slick.geom.Rectangle;
 
 import playerRelated.Player;
 
-public class GameScreenAssets {
+public class GameScreenAssets1 {
 
 	//Floor Variables
 	private int floorLevel = 1;
diff --git a/VERSION W.I.P/version w.i.p/src/gameStates/GameScreenAssetsTest.java b/VERSION W.I.P/version w.i.p/src/gameStates/GameScreenAssetsTest1.java
similarity index 93%
rename from VERSION W.I.P/version w.i.p/src/gameStates/GameScreenAssetsTest.java
rename to VERSION W.I.P/version w.i.p/src/gameStates/GameScreenAssetsTest1.java
index 950616a..87e1e79 100644
--- a/VERSION W.I.P/version w.i.p/src/gameStates/GameScreenAssetsTest.java	
+++ b/VERSION W.I.P/version w.i.p/src/gameStates/GameScreenAssetsTest1.java	
@@ -4,7 +4,7 @@ import static org.junit.Assert.*;
 
 import org.junit.Test;
 
-public class GameScreenAssetsTest {
+public class GameScreenAssetsTest1 {
 
 	
 	@Test
diff --git a/VERSION W.I.P/version w.i.p/src/gameStates/Ver2GameDriver.java b/VERSION W.I.P/version w.i.p/src/gameStates/Ver2GameDriver1.java
similarity index 100%
rename from VERSION W.I.P/version w.i.p/src/gameStates/Ver2GameDriver.java
rename to VERSION W.I.P/version w.i.p/src/gameStates/Ver2GameDriver1.java
diff --git a/Version 1.1/NewestVersion/src/test/LoadingGameTest.java b/Version 1.1/NewestVersion/src/test/LoadingGameTest.java
new file mode 100644
index 0000000..12a6191
--- /dev/null
+++ b/Version 1.1/NewestVersion/src/test/LoadingGameTest.java	
@@ -0,0 +1,68 @@
+package test;
+
+import static org.junit.Assert.assertNotNull;
+
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.LinkedList;
+
+import org.junit.Before;
+import org.junit.jupiter.api.Test;
+import org.newdawn.slick.SlickException;
+
+import gameStates.GameScreenAssets;
+import inputRelated.LoadingGame;
+import managers.MonsterManager;
+import mapRelated.BasicMap;
+import playerRelated.Player;
+
+class LoadingGameTest {
+
+	@Before
+	void writeSaveFile() throws IOException {
+		FileWriter fw = new FileWriter("save.txt");
+		PrintWriter pw = new PrintWriter(fw);
+		//First Write Floor number. Newline.
+		pw.println(4);
+		//Player position. new line
+		pw.println(12);
+		pw.println(10);
+		//Player level
+		pw.println(2);
+		//Player experience points. new line
+		pw.println(12);
+		//Player health points. new line.
+		pw.println(10);
+		
+		//Start loop for saving monster info
+	    //Write monster x-coordinate and y-coordinate
+	    pw.println(2);
+	    pw.println(6);
+	    //Write monster health
+	    pw.println(1);
+		pw.close();
+		fw.close();
+	}
+	
+	
+	@Test
+	void testNotNullLoadedMap() throws SlickException{
+	
+		//Arrange
+		BasicMap mapToTest = new BasicMap();
+		GameScreenAssets gameAssets = new GameScreenAssets();
+		LinkedList<BasicMap> totalLevels = new LinkedList<BasicMap>();
+		MonsterManager monsters = new MonsterManager(mapToTest);
+		Player player = new Player(4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, mapToTest);		
+		String[][] entityArray =  new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		
+		//Act 
+		mapToTest = LoadingGame.initLoadingGame(gameAssets, mapToTest, totalLevels, player, monsters, entityArray);
+		
+		
+		//Assert
+		assertNotNull("Failed to load Map", mapToTest);
+	}
+
+}
diff --git a/Version 1.1/NewestVersion/src/test/BasicMapTest.java b/Version 1.1/NewestVersion/src/testRelated/BasicMapTest.java
similarity index 100%
rename from Version 1.1/NewestVersion/src/test/BasicMapTest.java
rename to Version 1.1/NewestVersion/src/testRelated/BasicMapTest.java
diff --git a/Version 1.1/NewestVersion/src/test/BasicMonsterTest.java b/Version 1.1/NewestVersion/src/testRelated/BasicMonsterTest.java
similarity index 100%
rename from Version 1.1/NewestVersion/src/test/BasicMonsterTest.java
rename to Version 1.1/NewestVersion/src/testRelated/BasicMonsterTest.java
diff --git a/Version 1.1/NewestVersion/src/test/CombatManagerTest.java b/Version 1.1/NewestVersion/src/testRelated/CombatManagerTest.java
similarity index 100%
rename from Version 1.1/NewestVersion/src/test/CombatManagerTest.java
rename to Version 1.1/NewestVersion/src/testRelated/CombatManagerTest.java
diff --git a/Version 1.1/NewestVersion/src/test/EntityTest.java b/Version 1.1/NewestVersion/src/testRelated/EntityTest.java
similarity index 100%
rename from Version 1.1/NewestVersion/src/test/EntityTest.java
rename to Version 1.1/NewestVersion/src/testRelated/EntityTest.java
diff --git a/Version 1.1/NewestVersion/src/test/GameScreenAssetsTest.java b/Version 1.1/NewestVersion/src/testRelated/GameScreenAssetsTest.java
similarity index 92%
rename from Version 1.1/NewestVersion/src/test/GameScreenAssetsTest.java
rename to Version 1.1/NewestVersion/src/testRelated/GameScreenAssetsTest.java
index cf778b4..33905ae 100644
--- a/Version 1.1/NewestVersion/src/test/GameScreenAssetsTest.java	
+++ b/Version 1.1/NewestVersion/src/testRelated/GameScreenAssetsTest.java	
@@ -1,6 +1,8 @@
 package test;
 
 import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
 import gameStates.GameScreenAssets;
 
 import org.junit.Test;
diff --git a/Version 1.1/NewestVersion/src/test/MonsterManagerTest.java b/Version 1.1/NewestVersion/src/testRelated/MonsterManagerTest.java
similarity index 100%
rename from Version 1.1/NewestVersion/src/test/MonsterManagerTest.java
rename to Version 1.1/NewestVersion/src/testRelated/MonsterManagerTest.java
diff --git a/Version 1.1/NewestVersion/src/test/PlayerTest.java b/Version 1.1/NewestVersion/src/testRelated/PlayerTest.java
similarity index 100%
rename from Version 1.1/NewestVersion/src/test/PlayerTest.java
rename to Version 1.1/NewestVersion/src/testRelated/PlayerTest.java

commit 87e4a8c792a5517a3cb27654ed8c769d38f11a0a
Author: Irene Mayor <ihmayor@ucalgary.ca>
Date:   Thu Oct 12 07:14:14 2017 -0600

    Refactored out load player data

diff --git a/.classpath b/.classpath
new file mode 100644
index 0000000..16fdc9c
--- /dev/null
+++ b/.classpath
@@ -0,0 +1,32 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry exported="true" kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="src" path="Version 1.1/NewestVersion/src"/>
+	<classpathentry kind="src" path="VERSION W.I.P/version w.i.p/src"/>
+	<classpathentry kind="lib" path="C:/Users/User/Downloads/slick/lib/ibxm.jar">
+		<attributes>
+			<attribute name="org.eclipse.jdt.launching.CLASSPATH_ATTR_LIBRARY_PATH_ENTRY" value="C:/Users/User/Downloads/slick"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="lib" path="C:/Users/User/Downloads/slick/lib/lwjgl.jar">
+		<attributes>
+			<attribute name="org.eclipse.jdt.launching.CLASSPATH_ATTR_LIBRARY_PATH_ENTRY" value="C:/Users/User/Downloads/slick"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="lib" path="C:/Users/User/Downloads/slick/lib/lwjgl_util.jar">
+		<attributes>
+			<attribute name="org.eclipse.jdt.launching.CLASSPATH_ATTR_LIBRARY_PATH_ENTRY" value="C:/Users/User/Downloads/slick"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="lib" path="C:/Users/User/Downloads/slick/lib/natives-windows.jar">
+		<attributes>
+			<attribute name="org.eclipse.jdt.launching.CLASSPATH_ATTR_LIBRARY_PATH_ENTRY" value="C:/Users/User/Downloads/slick"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="lib" path="C:/Users/User/Downloads/slick/lib/slick.jar">
+		<attributes>
+			<attribute name="org.eclipse.jdt.launching.CLASSPATH_ATTR_LIBRARY_PATH_ENTRY" value="C:/Users/User/Downloads/slick"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="output" path="VERSION W.I.P/version w.i.p/bin"/>
+</classpath>
diff --git a/.project b/.project
new file mode 100644
index 0000000..63e1b4e
--- /dev/null
+++ b/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SENG-301-Game-Folder</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/.vs/ProjectSettings.json b/.vs/ProjectSettings.json
new file mode 100644
index 0000000..f8b4888
--- /dev/null
+++ b/.vs/ProjectSettings.json
@@ -0,0 +1,3 @@
+{
+  "CurrentProjectSetting": null
+}
\ No newline at end of file
diff --git a/.vs/SENG-301-Game-Folder/v15/.suo b/.vs/SENG-301-Game-Folder/v15/.suo
new file mode 100644
index 0000000..7caf4ba
Binary files /dev/null and b/.vs/SENG-301-Game-Folder/v15/.suo differ
diff --git a/.vs/VSWorkspaceState.json b/.vs/VSWorkspaceState.json
new file mode 100644
index 0000000..6904af9
--- /dev/null
+++ b/.vs/VSWorkspaceState.json
@@ -0,0 +1,12 @@
+{
+  "ExpandedNodes": [
+    "",
+    "\\Version 1.1",
+    "\\Version 1.1\\NewestVersion",
+    "\\Version 1.1\\NewestVersion\\src",
+    "\\Version 1.1\\NewestVersion\\src\\inputRelated",
+    "\\Version 1.1\\NewestVersion\\src\\playerRelated"
+  ],
+  "SelectedNode": "\\Version 1.1\\NewestVersion\\src\\inputRelated\\LoadingGame.java",
+  "PreviewInSolutionExplorer": false
+}
\ No newline at end of file
diff --git a/.vs/slnx.sqlite b/.vs/slnx.sqlite
new file mode 100644
index 0000000..b18abcd
Binary files /dev/null and b/.vs/slnx.sqlite differ
diff --git a/Version 1.1/NewestVersion/src/inputRelated/LoadingGame.java b/Version 1.1/NewestVersion/src/inputRelated/LoadingGame.java
index 8112c08..7430510 100644
--- a/Version 1.1/NewestVersion/src/inputRelated/LoadingGame.java	
+++ b/Version 1.1/NewestVersion/src/inputRelated/LoadingGame.java	
@@ -18,9 +18,6 @@ import playerRelated.Player;
 
 public class LoadingGame {
 	
-	
-	
-	
 	public static BasicMap initLoadingGame(GameScreenAssets gameAssets, BasicMap changeMap, LinkedList<BasicMap> xTotalLevels,
 			   Player player, MonsterManager monsters, String[][] entityArray)
 			   throws SlickException
@@ -43,19 +40,8 @@ public class LoadingGame {
 			BufferedReader br = new BufferedReader(fr);
 
 			//Reading player saved data
-			String readStringFloor = br.readLine();
-			readFloor = Integer.valueOf(readStringFloor);
-			String readStringPlayerPositionX = br.readLine();
-			readPlayerPositionX = Integer.valueOf(readStringPlayerPositionX);
-			String readStringPlayerPositionY = br.readLine();
-			readPlayerPositionY = Integer.valueOf(readStringPlayerPositionY);
-			String readStringPlayerLevel = br.readLine();
-			readPlayerLevel = Integer.valueOf(readStringPlayerLevel);
-			String readStringPlayerExp = br.readLine();
-			readPlayerExp = Integer.valueOf(readStringPlayerExp);
-			String readStringPlayerHealth = br.readLine();
-			readPlayerHealth = Integer.valueOf(readStringPlayerHealth);
-
+			LoadPlayerData(br, readFloor, readPlayerPositionX, readPlayerPositionY, readPlayerLevel, readPlayerExp, readPlayerHealth);
+		
 			//Reading monster saved data
 			String lineRead = br.readLine();
 			for (int i = 0; lineRead != null; i++)
@@ -110,4 +96,22 @@ public class LoadingGame {
 		return changeMap;
 	}
 
+	private static void LoadPlayerData(BufferedReader br, int readFloor, int readPlayerPositionX, int readPlayerPositionY, int readPlayerExp, int readPlayerLevel, int readPlayerHealth) throws IOException {
+		//Reading player saved data
+		String readStringFloor = br.readLine();
+		readFloor = Integer.valueOf(readStringFloor);
+		String readStringPlayerPositionX = br.readLine();
+		readPlayerPositionX = Integer.valueOf(readStringPlayerPositionX);
+		String readStringPlayerPositionY = br.readLine();
+		readPlayerPositionY = Integer.valueOf(readStringPlayerPositionY);
+		String readStringPlayerLevel = br.readLine();
+		readPlayerLevel = Integer.valueOf(readStringPlayerLevel);
+		String readStringPlayerExp = br.readLine();
+		readPlayerExp = Integer.valueOf(readStringPlayerExp);
+		String readStringPlayerHealth = br.readLine();
+		readPlayerHealth = Integer.valueOf(readStringPlayerHealth);
+	}
+
+
 }
+

commit 0165b8e3984ed88403aa24b325387787934d2db2
Author: Colin-Lo <Colin.lo@ucalgary.ca>
Date:   Wed Apr 1 20:22:35 2015 -0600

    Floor 4 map fix
    
    The right wall went missing again, I gotta add it back in so the player
    can't run to the right edge and crash the game.

diff --git a/Version 1.1/NewestVersion/res/map/floor4.tmx b/Version 1.1/NewestVersion/res/map/floor4.tmx
index 8bb18c8..e51895a 100644
--- a/Version 1.1/NewestVersion/res/map/floor4.tmx	
+++ b/Version 1.1/NewestVersion/res/map/floor4.tmx	
@@ -87,7 +87,7 @@
    <property name="blocked" value="false"/>
   </properties>
   <data encoding="base64" compression="gzip">
-   H4sIAAAAAAAAC+2UQQ6CMBREaVy5hovoHeRi3oCFxyDBG0iCa3cegyvoT/hhMkypxZ1x8VJabf90/sBQFMXwA3Slxn57TPj/bBzfYzvxTd1+Yhfm55iWfVg++znH6jsddp7Shhr9/i3A8xif+o13RKx+HWavOlEb5yPss3q+FusX97wX90YtPmK/sAaexX5uzYjaj2teDz1UPcN9KV8Yzylnh71AzdxL1GK5tfFQreclRi1y6+tYk+esZRS+rGk5Bw33iX3A9x113Isl5s211CgtuHYSvvA3JpYrq33JgLWo7KYyndLSZGhRfjxXtKS+g7m+NKRlyzufIrdHtz+SF6t4ECLACAAA
+   H4sIAAAAAAAAC+2UTQ6CMBCF27hyDRfRO8jFvAELj0ECN5AE1u48BlfQSTrhZXht+dkZF19Kq+28vnkwOOeGH6AtOPLbK6D/k3H6jk3gSN0+cPLzc0zL2S+f9ZxreUyHnMe0oUa9fwPYeYy1fuMdEalf+dmrltTG+QT7pJ6uxfple96Te6MWHbFfWAPPsn7uzQjbj2taDz1kPcN9OV8smlObHesFara9RC2SWxkvZTovMSqSW13HmnZutUzEl5SWu+fYPlkf8H1HHaNbIt50xZIxogXXbsQX+42J5UrOf6yEaWHZzWU6p6XeoIX58U5oyX0Ht/pSGy173vkcW3v0/EP5AAGfpOTACAAA
   </data>
  </layer>
 </map>

commit 772c80097a786be99cade37d3a6f574a828db794
Author: Ihmayor <ihmayor@ucalgary.ca>
Date:   Wed Apr 1 19:52:41 2015 -0600

    I COULDN'T JUSTIFY IT IN MY HEAD I'M SORRY!!
    
    I just HAD to HAD TO change graphics g references to just graphics
    because I couldn't ignore that potential dock in marks and couldn't
    justify not changing it. argh....leave the zip to me

diff --git a/Version 1.1/NewestVersion/bin/gameStates/GameOverScreen.class b/Version 1.1/NewestVersion/bin/gameStates/GameOverScreen.class
index 5905a0a..195ebbf 100644
Binary files a/Version 1.1/NewestVersion/bin/gameStates/GameOverScreen.class and b/Version 1.1/NewestVersion/bin/gameStates/GameOverScreen.class differ
diff --git a/Version 1.1/NewestVersion/bin/gameStates/GameScreen.class b/Version 1.1/NewestVersion/bin/gameStates/GameScreen.class
index c6fe944..578261b 100644
Binary files a/Version 1.1/NewestVersion/bin/gameStates/GameScreen.class and b/Version 1.1/NewestVersion/bin/gameStates/GameScreen.class differ
diff --git a/Version 1.1/NewestVersion/bin/gameStates/TransitionScreen.class b/Version 1.1/NewestVersion/bin/gameStates/TransitionScreen.class
index 59792a6..d134b16 100644
Binary files a/Version 1.1/NewestVersion/bin/gameStates/TransitionScreen.class and b/Version 1.1/NewestVersion/bin/gameStates/TransitionScreen.class differ
diff --git a/Version 1.1/NewestVersion/bin/inputRelated/BasicButton.class b/Version 1.1/NewestVersion/bin/inputRelated/BasicButton.class
index 6e4bb52..4320b81 100644
Binary files a/Version 1.1/NewestVersion/bin/inputRelated/BasicButton.class and b/Version 1.1/NewestVersion/bin/inputRelated/BasicButton.class differ
diff --git a/Version 1.1/NewestVersion/bin/inputRelated/MainMenuButtons.class b/Version 1.1/NewestVersion/bin/inputRelated/MainMenuButtons.class
index 765e8d4..7643244 100644
Binary files a/Version 1.1/NewestVersion/bin/inputRelated/MainMenuButtons.class and b/Version 1.1/NewestVersion/bin/inputRelated/MainMenuButtons.class differ
diff --git a/Version 1.1/NewestVersion/bin/inputRelated/SavingGame.class b/Version 1.1/NewestVersion/bin/inputRelated/SavingGame.class
index e48347b..6598379 100644
Binary files a/Version 1.1/NewestVersion/bin/inputRelated/SavingGame.class and b/Version 1.1/NewestVersion/bin/inputRelated/SavingGame.class differ
diff --git a/Version 1.1/NewestVersion/bin/inputRelated/SlideOutMenu.class b/Version 1.1/NewestVersion/bin/inputRelated/SlideOutMenu.class
index 7529ee1..359528c 100644
Binary files a/Version 1.1/NewestVersion/bin/inputRelated/SlideOutMenu.class and b/Version 1.1/NewestVersion/bin/inputRelated/SlideOutMenu.class differ
diff --git a/Version 1.1/NewestVersion/bin/managers/MonsterManager.class b/Version 1.1/NewestVersion/bin/managers/MonsterManager.class
index 3f59573..caf7555 100644
Binary files a/Version 1.1/NewestVersion/bin/managers/MonsterManager.class and b/Version 1.1/NewestVersion/bin/managers/MonsterManager.class differ
diff --git a/Version 1.1/NewestVersion/bin/monsterRelated/BasicMonster.class b/Version 1.1/NewestVersion/bin/monsterRelated/BasicMonster.class
index ef5284a..68b0ea6 100644
Binary files a/Version 1.1/NewestVersion/bin/monsterRelated/BasicMonster.class and b/Version 1.1/NewestVersion/bin/monsterRelated/BasicMonster.class differ
diff --git a/Version 1.1/NewestVersion/bin/playerRelated/Player.class b/Version 1.1/NewestVersion/bin/playerRelated/Player.class
index 4a52d45..db9c513 100644
Binary files a/Version 1.1/NewestVersion/bin/playerRelated/Player.class and b/Version 1.1/NewestVersion/bin/playerRelated/Player.class differ
diff --git a/Version 1.1/NewestVersion/bin/test/BasicMonsterTest.class b/Version 1.1/NewestVersion/bin/test/BasicMonsterTest.class
index 2d23a16..cf63e5a 100644
Binary files a/Version 1.1/NewestVersion/bin/test/BasicMonsterTest.class and b/Version 1.1/NewestVersion/bin/test/BasicMonsterTest.class differ
diff --git a/Version 1.1/NewestVersion/res/interface/Thumbs.db b/Version 1.1/NewestVersion/res/interface/Thumbs.db
index 3a6310b..94bbfb3 100644
Binary files a/Version 1.1/NewestVersion/res/interface/Thumbs.db and b/Version 1.1/NewestVersion/res/interface/Thumbs.db differ
diff --git a/Version 1.1/NewestVersion/res/map/Thumbs.db b/Version 1.1/NewestVersion/res/map/Thumbs.db
index ce0e33b..cfbbe29 100644
Binary files a/Version 1.1/NewestVersion/res/map/Thumbs.db and b/Version 1.1/NewestVersion/res/map/Thumbs.db differ
diff --git a/Version 1.1/NewestVersion/res/map/floor4.tmx b/Version 1.1/NewestVersion/res/map/floor4.tmx
index a7045ef..8bb18c8 100644
--- a/Version 1.1/NewestVersion/res/map/floor4.tmx	
+++ b/Version 1.1/NewestVersion/res/map/floor4.tmx	
@@ -87,7 +87,7 @@
    <property name="blocked" value="false"/>
   </properties>
   <data encoding="base64" compression="gzip">
-   H4sIAAAAAAAAC+2UTQ6CMBCF27hyDRfRO8jFvAELj0ECN5AE1u48BlfQSTrhZXht+dkZF19Kq+28vnkwOOeGH6AtOPLbK6D/k3H6jk3gSN0+cPLzc0zL2S+f9ZxreUyHnMe0oUa9fwPYeYy1fuMdEalf+dmrltTG+QT7pJ6uxfple96Te6MWHbFfWAPPsn7uzQjbj2taDz1kPcN9OV8smlObHesFara9RC2SWxkvZTovMSqSW13HmnZutUzEl5SWu+fYPlkf8H1HHaNbIt50BYdpwbUb8cV+Y2K5ktqPlYzEF5bdXKZzWuoNWpgf74SW3Hdwqy+10bLnnc+xtUfPP5QPuWFCgcAIAAA=
+   H4sIAAAAAAAAC+2UQQ6CMBREaVy5hovoHeRi3oCFxyDBG0iCa3cegyvoT/hhMkypxZ1x8VJabf90/sBQFMXwA3Slxn57TPj/bBzfYzvxTd1+Yhfm55iWfVg++znH6jsddp7Shhr9/i3A8xif+o13RKx+HWavOlEb5yPss3q+FusX97wX90YtPmK/sAaexX5uzYjaj2teDz1UPcN9KV8Yzylnh71AzdxL1GK5tfFQreclRi1y6+tYk+esZRS+rGk5Bw33iX3A9x113Isl5s211CgtuHYSvvA3JpYrq33JgLWo7KYyndLSZGhRfjxXtKS+g7m+NKRlyzufIrdHtz+SF6t4ECLACAAA
   </data>
  </layer>
 </map>
diff --git a/Version 1.1/NewestVersion/src/gameStates/GameOverScreen.java b/Version 1.1/NewestVersion/src/gameStates/GameOverScreen.java
index 192c44f..09d9a11 100644
--- a/Version 1.1/NewestVersion/src/gameStates/GameOverScreen.java	
+++ b/Version 1.1/NewestVersion/src/gameStates/GameOverScreen.java	
@@ -80,11 +80,13 @@ public class GameOverScreen extends BasicGameState{
 	
 	// Displays the game over screen
 	@Override
-	public void render(GameContainer gc, StateBasedGame sbg, Graphics g)
+	public void render(GameContainer gc, StateBasedGame sbg, Graphics graphics)
 			throws SlickException {
+		//abstract numbers = x, y
 		skull.draw(330, 100);
+		//abstract numbers = x,y
 		font.drawString(360, 60, "GAME OVER!", Color.red);
-		buttons.render(gc, g);
+		buttons.render(gc, graphics);
 	}
 
 
diff --git a/Version 1.1/NewestVersion/src/gameStates/GameScreen.java b/Version 1.1/NewestVersion/src/gameStates/GameScreen.java
index 55a4dd7..3be00bb 100644
--- a/Version 1.1/NewestVersion/src/gameStates/GameScreen.java	
+++ b/Version 1.1/NewestVersion/src/gameStates/GameScreen.java	
@@ -177,14 +177,14 @@ public class GameScreen extends BasicGameState {
 	
 	// Draws the display of the game
 	@Override
-	public void render(GameContainer gc, StateBasedGame stateGame, Graphics g)
+	public void render(GameContainer gc, StateBasedGame stateGame, Graphics graphics)
 			throws SlickException {
 		
 		//Render Map, Monsters, Player, GameScreen Assets
 		currentMap.render();
-		monsters.render(g);
-		player.render(g);
-		gameAssets.render(g, player);
+		monsters.render(graphics);
+		player.render(graphics);
+		gameAssets.render(graphics, player);
 	}
 	
 	
diff --git a/Version 1.1/NewestVersion/src/gameStates/MainMenuScreen.java b/Version 1.1/NewestVersion/src/gameStates/MainMenuScreen.java
index c5643cc..27d0ab1 100644
--- a/Version 1.1/NewestVersion/src/gameStates/MainMenuScreen.java	
+++ b/Version 1.1/NewestVersion/src/gameStates/MainMenuScreen.java	
@@ -51,11 +51,11 @@ public class MainMenuScreen extends BasicGameState {
 	
 	// Draws the menu screen
 	@Override
-	public void render(GameContainer gc, StateBasedGame stateGame, Graphics g)
+	public void render(GameContainer gc, StateBasedGame stateGame, Graphics graphics)
 			throws SlickException {
 		gc.setShowFPS(false); //FPS counter is hidden		
 		menuAnimation.draw(300,50);
-	    menuButtons.render(gc,g);//Renders the menu buttons
+	    menuButtons.render(gc,graphics);//Renders the menu buttons
 	}
 
 	// Updates the menu's animation
diff --git a/Version 1.1/NewestVersion/src/gameStates/TransitionScreen.java b/Version 1.1/NewestVersion/src/gameStates/TransitionScreen.java
index 9b85d45..de42284 100644
--- a/Version 1.1/NewestVersion/src/gameStates/TransitionScreen.java	
+++ b/Version 1.1/NewestVersion/src/gameStates/TransitionScreen.java	
@@ -94,9 +94,9 @@ public class TransitionScreen extends BasicGameState {
 
 	//Draws Transition Screen based on Player Input
 	@Override
-	public void render(GameContainer gc, StateBasedGame sbg, Graphics g)
+	public void render(GameContainer gc, StateBasedGame sbg, Graphics graphics)
 			throws SlickException {
-		g.setColor(Color.black);
+		graphics.setColor(Color.black);
 		if (slide < 1)
 			animationIntro.draw(0,0);
 		else if (slide == 1)
@@ -107,7 +107,7 @@ public class TransitionScreen extends BasicGameState {
 			controlImage.draw(0,0);
 		else if (slide == 4)
 			controlImage2.draw(0,0);		
-		g.drawString("PRESS 'W' TO SKIP INTRO", 780, 470);
+		graphics.drawString("PRESS 'W' TO SKIP INTRO", 780, 470);
 	}
 	
 	//Controls Keyboard Input
diff --git a/Version 1.1/NewestVersion/src/inputRelated/BasicButton.java b/Version 1.1/NewestVersion/src/inputRelated/BasicButton.java
index b6bd879..6b787ac 100644
--- a/Version 1.1/NewestVersion/src/inputRelated/BasicButton.java	
+++ b/Version 1.1/NewestVersion/src/inputRelated/BasicButton.java	
@@ -78,15 +78,15 @@ public class BasicButton extends MouseOverArea {
 	
 	//Renders button image depending on its activation
 	@Override
-    public void render(GUIContext guic, Graphics g) {
+    public void render(GUIContext guic, Graphics graphics) {
 	        if (isActivated()&&!unclickable) {
-	            g.drawImage(activeButton, getX(), getY());
+	            graphics.drawImage(activeButton, getX(), getY());
 	            activated = false;
 	        }
-	        super.render(guic, g);
+	        super.render(guic, graphics);
 		    if (unclickable)
 		    {
-		    	g.drawImage(inactiveButton, getX(), getY());
+		    	graphics.drawImage(inactiveButton, getX(), getY());
 		    }
 	    }
 	 
diff --git a/Version 1.1/NewestVersion/src/inputRelated/MainMenuButtons.java b/Version 1.1/NewestVersion/src/inputRelated/MainMenuButtons.java
index a9b5696..91c9760 100644
--- a/Version 1.1/NewestVersion/src/inputRelated/MainMenuButtons.java	
+++ b/Version 1.1/NewestVersion/src/inputRelated/MainMenuButtons.java	
@@ -85,9 +85,9 @@ public class MainMenuButtons {
 	}	
 	
 	//Draw buttons on main menu screen
-	public void render(GameContainer gc, Graphics g){
-		 newGameButton.render(gc, g);//Draw the buttons on screen.
-		 loadGameButton.render(gc,g);
+	public void render(GameContainer gc, Graphics graphics){
+		 newGameButton.render(gc, graphics);//Draw the buttons on screen.
+		 loadGameButton.render(gc,graphics);
 	}
 	
 	
diff --git a/Version 1.1/NewestVersion/src/inputRelated/SavingGame.java b/Version 1.1/NewestVersion/src/inputRelated/SavingGame.java
index cb04552..9425991 100644
--- a/Version 1.1/NewestVersion/src/inputRelated/SavingGame.java	
+++ b/Version 1.1/NewestVersion/src/inputRelated/SavingGame.java	
@@ -13,7 +13,7 @@ import playerRelated.Player;
 
 public class SavingGame {
 		
-	public static void SaveGame(GameScreenAssets gsa, Player p, MonsterManager mm){
+	public static void SaveGame(GameScreenAssets gsa, Player player, MonsterManager monsterManage){
 		try
 		{
 			FileWriter fw = new FileWriter("save.txt");
@@ -21,19 +21,19 @@ public class SavingGame {
 			//First Write Floor number. Newline.
 			pw.println(gsa.getFloorLevel());
 			//Player position. new line
-			pw.println(p.getPosition()[0]);
-			pw.println(p.getPosition()[1]);
+			pw.println(player.getPosition()[0]);
+			pw.println(player.getPosition()[1]);
 			//Player level
-			pw.println(p.getCurrentLevel());
+			pw.println(player.getCurrentLevel());
 			//Player experience points. new line
-			pw.println(p.getExperiencePoints());
+			pw.println(player.getExperiencePoints());
 			//Player health points. new line.
-			pw.println(p.getHealthPoints());
+			pw.println(player.getHealthPoints());
 			//Start loop for saving monster info
-			LinkedList<BasicMonster> mmLL = (LinkedList<BasicMonster>) mm.getMonsterList().clone();
-			while (mmLL.peekFirst() != null)
+			LinkedList<BasicMonster> monsterLinkedList = (LinkedList<BasicMonster>) monsterManage.getMonsterList().clone();
+			while (monsterLinkedList.peekFirst() != null)
 			{
-				BasicMonster currentNode = mmLL.removeFirst();
+				BasicMonster currentNode = monsterLinkedList.removeFirst();
 				//Don't have monster type as of now
 				//Write monster x-coordinate and y-coordinate
 				pw.println(currentNode.getPosition()[0]);
diff --git a/Version 1.1/NewestVersion/src/inputRelated/SlideOutMenu.java b/Version 1.1/NewestVersion/src/inputRelated/SlideOutMenu.java
index 3928eaa..0ab58e9 100644
--- a/Version 1.1/NewestVersion/src/inputRelated/SlideOutMenu.java	
+++ b/Version 1.1/NewestVersion/src/inputRelated/SlideOutMenu.java	
@@ -56,9 +56,9 @@ public class SlideOutMenu extends MouseOverArea{
 	}
 
 	   //Draw Game Menu (Used for mouseOverDownImage and highlighting color)
-	   public void render(GameContainer gc, Graphics g) {
-	          super.render(gc, g);
-	          exitGameButton.render(gc,g);
+	   public void render(GameContainer gc, Graphics graphics) {
+	          super.render(gc, graphics);
+	          exitGameButton.render(gc,graphics);
 	   }
 	
 	
diff --git a/Version 1.1/NewestVersion/src/managers/MonsterManager.java b/Version 1.1/NewestVersion/src/managers/MonsterManager.java
index 8b8f334..d1683c1 100644
--- a/Version 1.1/NewestVersion/src/managers/MonsterManager.java	
+++ b/Version 1.1/NewestVersion/src/managers/MonsterManager.java	
@@ -207,11 +207,11 @@ public class MonsterManager {
 	
 	
 	//Calls render method for every monster inside the list.
-	public void render(Graphics g) throws SlickException{
+	public void render(Graphics graphics) throws SlickException{
 		
 		BasicMonster [] monsters = monsterList.toArray(new BasicMonster [monsterList.size()]);
 		for (BasicMonster m: monsters){
-			m.render(g);
+			m.render(graphics);
 			}
 		
 	}
diff --git a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java
index 01bbbf7..674460a 100644
--- a/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
+++ b/Version 1.1/NewestVersion/src/monsterRelated/BasicMonster.java	
@@ -112,7 +112,7 @@ public class BasicMonster extends Entity{
 	
 	
 	//Draws Monster to Screen
-	public void render(Graphics g) throws SlickException{
+	public void render(Graphics graphics) throws SlickException{
 		if (!alive)
 			actDead();
 		monsterAnimation.draw((int)x, (int)y);
diff --git a/Version 1.1/NewestVersion/src/playerRelated/Player.java b/Version 1.1/NewestVersion/src/playerRelated/Player.java
index b292d4b..01e1ed5 100644
--- a/Version 1.1/NewestVersion/src/playerRelated/Player.java	
+++ b/Version 1.1/NewestVersion/src/playerRelated/Player.java	
@@ -150,9 +150,9 @@ public class Player extends Entity{
 	
 	
 	
-	public void render(Graphics g){
+	public void render(Graphics graphics){
 	currentSprite.draw((int) x, (int) y);//Draw what the Current sprite should look like.
-	g.drawImage(shadow,(int)x-1110, (int)y-850); //Draw Shadow with a particular offset for the spotlight
+	graphics.drawImage(shadow,(int)x-1110, (int)y-850); //Draw Shadow with a particular offset for the spotlight
 	}
 	
 	
diff --git a/Version 1.1/NewestVersion/src/test/BasicMonsterTest.java b/Version 1.1/NewestVersion/src/test/BasicMonsterTest.java
index 5239701..f0d639d 100644
--- a/Version 1.1/NewestVersion/src/test/BasicMonsterTest.java	
+++ b/Version 1.1/NewestVersion/src/test/BasicMonsterTest.java	
@@ -96,7 +96,7 @@ public class BasicMonsterTest {
 		
 		BasicMonster m = new BasicMonster (map, 10,10,100);
 		assertEquals(1000, m.getMaxHealthPoints());
-		assertEquals(520, m.getExpPointGain());
+		assertEquals(510, m.getExpPointGain());
 	}
 	
     //Tests that monsters are erased from the map when they die
@@ -344,4 +344,6 @@ public class BasicMonsterTest {
 	}
 	
 
+	
+	
 }

commit fd553446693cd51a82dcee541a5aad69489e9696
Author: Ihmayor <ihmayor@ucalgary.ca>
Date:   Wed Apr 1 07:03:51 2015 -0600

    Had to change a quick thing
    
    This was preventing the monster Manager's test from passing

diff --git a/Version 1.1/NewestVersion/src/managers/MonsterManager.java b/Version 1.1/NewestVersion/src/managers/MonsterManager.java
index e576628..8b8f334 100644
--- a/Version 1.1/NewestVersion/src/managers/MonsterManager.java	
+++ b/Version 1.1/NewestVersion/src/managers/MonsterManager.java	
@@ -27,7 +27,7 @@ public class MonsterManager {
 	private int level = 1;
 	private BasicMap currentMap;
 	private String[][] entityArray;
-	private int screenWidth = 1024;
+	private int screenWidth = 1120;
 	private int screenHeight = 512;
 	
 	

commit 9cc6f6c04f2fdd8f4e949b4948e16fb2489b560f
Merge: d69e0a1 76eb215
Author: Ihmayor <ihmayor@ucalgary.ca>
Date:   Wed Apr 1 05:18:12 2015 -0600

    Merge pull request #4 from Ihmayor/Irene_W.I.P
    
    Master

commit d69e0a16215a10914acfe90d46300d719e4198af
Merge: a7b4a39 377e734
Author: Ihmayor <ihmayor@ucalgary.ca>
Date:   Wed Apr 1 05:13:21 2015 -0600

    erge remote-tracking branch 'origin/Irene_W.I.P'
    
    Conflicts:
            NewestVersion/.classpath
            NewestVersion/.project
            NewestVersion/.settings/org.eclipse.jdt.core.prefs
            NewestVersion/bin/gameStates/GameScreen.class
            NewestVersion/bin/gameStates/GameScreenAssets$1.class
            NewestVersion/bin/gameStates/GameScreenAssets.class
            NewestVersion/bin/gameStates/MainMenuScreen.class
            NewestVersion/bin/gameStates/StateManager.class
            NewestVersion/bin/gameStates/TransitionScreen.class
            NewestVersion/bin/gameStates/Ver2GameDriver.class
            NewestVersion/bin/inputRelated/BasicButton.class
            NewestVersion/bin/inputRelated/ButtonAction.class
            NewestVersion/bin/inputRelated/ButtonListener.class
            NewestVersion/bin/inputRelated/LoadingGame.class
            NewestVersion/bin/inputRelated/MainMenuButtons$1.class
            NewestVersion/bin/inputRelated/MainMenuButtons$2.class
            NewestVersion/bin/inputRelated/MainMenuButtons.class
            NewestVersion/bin/inputRelated/SavingGame.class
            NewestVersion/bin/inputRelated/SlideOutMenu$1.class
            NewestVersion/bin/inputRelated/SlideOutMenu.class
            NewestVersion/bin/managers/CombatManager.class
            NewestVersion/bin/managers/EntityManager.class
            NewestVersion/bin/mapRelated/BasicMap.class
            NewestVersion/bin/monsterRelated/BasicMonster.class
            NewestVersion/bin/playerRelated/Player.class
            NewestVersion/bin/test/BasicMapTest.class
            NewestVersion/bin/test/BasicMonsterTest.class
            NewestVersion/bin/test/CombatManagerTest.class
            NewestVersion/bin/test/EntityTest.class
            NewestVersion/bin/test/GameScreenAssetsTest.class
            NewestVersion/bin/test/MonsterManagerTest.class
            NewestVersion/bin/test/PlayerTest.class
            NewestVersion/res/interface/Controlinstructions.png
            NewestVersion/res/interface/MorrisRoman-Black.ttf
            NewestVersion/res/interface/MorrisRomanAlternate-Black.ttf
            NewestVersion/res/interface/Sketch Gothic School.ttf
            NewestVersion/res/interface/TITLE1.png
            NewestVersion/res/interface/continueActive.png
            NewestVersion/res/interface/continueInActive.png
            NewestVersion/res/interface/continueMouseOver.png
            NewestVersion/res/interface/controls.png
            NewestVersion/res/interface/design2.png
            NewestVersion/res/interface/design2slide2.png
            NewestVersion/res/interface/design2transition.png
            NewestVersion/res/interface/exitGame.png
            NewestVersion/res/interface/exitGameMouseOver.png
            NewestVersion/res/interface/explanation.png
            NewestVersion/res/interface/menu2.png
            NewestVersion/res/interface/newGame.png
            NewestVersion/res/interface/newGameMouseOver.png
            NewestVersion/res/interface/panicSlide.png
            NewestVersion/res/interface/saveExit.png
            NewestVersion/res/interface/saveExitMouseOver.png
            NewestVersion/res/interface/skull.png
            NewestVersion/res/interface/test1.png
            NewestVersion/res/interface/test2.png
            NewestVersion/res/interface/test3.png
            NewestVersion/res/interface/tilepart2.png
            NewestVersion/res/map/32x32.bmp
            NewestVersion/res/map/Thumbs.db
            NewestVersion/res/map/clifveg2.bmp
            NewestVersion/res/map/floor1.tmx
            NewestVersion/res/map/floor2.tmx
            NewestVersion/res/map/floor3.tmx
            NewestVersion/res/map/floor4.tmx
            NewestVersion/res/map/floor5.tmx
            NewestVersion/res/map/floor6.tmx
            NewestVersion/res/map/floor7.tmx
            NewestVersion/res/map/secondTestMap.tmx
            NewestVersion/res/map/singleTilePassageWay.tmx
            NewestVersion/res/map/testMap..txt
            NewestVersion/res/map/testMap.tmx
            NewestVersion/res/map/tilea2.png
            NewestVersion/res/monster/dead.png
            NewestVersion/res/monster/dummySheet.png
            NewestVersion/res/player/Thumbs.db
            NewestVersion/res/player/intro1.png
            NewestVersion/res/player/intro10.png
            NewestVersion/res/player/intro11.png
            NewestVersion/res/player/intro2.png
            NewestVersion/res/player/intro3.png
            NewestVersion/res/player/intro4.png
            NewestVersion/res/player/intro5.png
            NewestVersion/res/player/intro6.png
            NewestVersion/res/player/intro7.png
            NewestVersion/res/player/intro8.png
            NewestVersion/res/player/intro9.png
            NewestVersion/res/player/template2.png
            NewestVersion/res/sound/A Time To Lose.wav
            NewestVersion/res/sound/Back To Programming.wav
            NewestVersion/res/sound/Bigger And Bigger.wav
            NewestVersion/res/sound/Catacombs.wav
            NewestVersion/res/sound/Feelings Are On The Rise.wav
            NewestVersion/res/sound/Flying In The Face Of Hope.wav
            NewestVersion/res/sound/Play At Your Own Risk.wav
            NewestVersion/res/sound/SFX/Level Up Ding.wav
            NewestVersion/res/sound/SFX/Monster Crunch.wav
            NewestVersion/res/sound/SFX/Monster Snarl.wav
            NewestVersion/res/sound/SFX/Player Grunt.wav
            NewestVersion/res/sound/SFX/Player Oof.wav
            NewestVersion/res/sound/SFX/Potential Monster Die.wav
            NewestVersion/res/sound/SFX/Swoosh.wav
            NewestVersion/res/sound/SFX/Sword Swing.wav
            NewestVersion/res/sound/Tank Battle.wav
            NewestVersion/res/sound/The Hero Of The Darkness.wav
            NewestVersion/src/gameStates/GameOverScreen.java
            NewestVersion/src/gameStates/GameScreen.java
            NewestVersion/src/gameStates/GameScreenAssets.java
            NewestVersion/src/gameStates/MainMenuScreen.java
            NewestVersion/src/gameStates/StateManager.java
            NewestVersion/src/gameStates/TransitionScreen.java
            NewestVersion/src/gameStates/Ver2GameDriver.java
            NewestVersion/src/gameStates/WinScreen.java
            NewestVersion/src/inputRelated/BasicButton.java
            NewestVersion/src/inputRelated/ButtonAction.java
            NewestVersion/src/inputRelated/ButtonListener.java
            NewestVersion/src/inputRelated/EndGameButtons.java
            NewestVersion/src/inputRelated/LoadingGame.java
            NewestVersion/src/inputRelated/MainMenuButtons.java
            NewestVersion/src/inputRelated/SavingGame.java
            NewestVersion/src/inputRelated/SlideOutMenu.java
            NewestVersion/src/managers/CombatManager.java
            NewestVersion/src/managers/EntityManager.java
            NewestVersion/src/managers/MonsterManager.java
            NewestVersion/src/managers/SoundManager.java
            NewestVersion/src/mapRelated/BasicMap.java
            NewestVersion/src/monsterRelated/BasicMonster.java
            NewestVersion/src/monsterRelated/Entity.java
            NewestVersion/src/playerRelated/Player.java
            NewestVersion/src/test/BasicMapTest.java
            NewestVersion/src/test/BasicMonsterTest.java
            NewestVersion/src/test/CombatManagerTest.java
            NewestVersion/src/test/EntityTest.java
            NewestVersion/src/test/GameScreenAssetsTest.java
            NewestVersion/src/test/MonsterManagerTest.java
            NewestVersion/src/test/PlayerTest.java
            Saving Loading Fixed for sure/NewestVersion/.classpath
            Saving Loading Fixed for sure/NewestVersion/.project
            Saving Loading Fixed for sure/NewestVersion/.settings/org.eclipse.jdt.core.prefs
            Saving Loading Fixed for sure/NewestVersion/bin/gameStates/GameScreen.class
            Saving Loading Fixed for sure/NewestVersion/bin/gameStates/GameScreenAssets$1.class
            Saving Loading Fixed for sure/NewestVersion/bin/gameStates/GameScreenAssets.class
            Saving Loading Fixed for sure/NewestVersion/bin/gameStates/MainMenuScreen.class
            Saving Loading Fixed for sure/NewestVersion/bin/gameStates/StateManager.class
            Saving Loading Fixed for sure/NewestVersion/bin/gameStates/TransitionScreen.class
            Saving Loading Fixed for sure/NewestVersion/bin/gameStates/Ver2GameDriver.class
            Saving Loading Fixed for sure/NewestVersion/bin/inputRelated/BasicButton.class
            Saving Loading Fixed for sure/NewestVersion/bin/inputRelated/ButtonAction.class
            Saving Loading Fixed for sure/NewestVersion/bin/inputRelated/ButtonListener.class
            Saving Loading Fixed for sure/NewestVersion/bin/inputRelated/LoadingGame.class
            Saving Loading Fixed for sure/NewestVersion/bin/inputRelated/MainMenuButtons$1.class
            Saving Loading Fixed for sure/NewestVersion/bin/inputRelated/MainMenuButtons$2.class
            Saving Loading Fixed for sure/NewestVersion/bin/inputRelated/MainMenuButtons.class
            Saving Loading Fixed for sure/NewestVersion/bin/inputRelated/SavingGame.class
            Saving Loading Fixed for sure/NewestVersion/bin/inputRelated/SlideOutMenu$1.class
            Saving Loading Fixed for sure/NewestVersion/bin/inputRelated/SlideOutMenu.class
            Saving Loading Fixed for sure/NewestVersion/bin/managers/CombatManager.class
            Saving Loading Fixed for sure/NewestVersion/bin/managers/CombatManagerTest.class
            Saving Loading Fixed for sure/NewestVersion/bin/managers/EntityManager.class
            Saving Loading Fixed for sure/NewestVersion/bin/managers/MonsterManagerTest.class
            Saving Loading Fixed for sure/NewestVersion/bin/mapRelated/BasicMap.class
            Saving Loading Fixed for sure/NewestVersion/bin/mapRelated/BasicMapTest.class
            Saving Loading Fixed for sure/NewestVersion/bin/monsterRelated/BasicMonster.class
            Saving Loading Fixed for sure/NewestVersion/bin/playerRelated/Player.class
            Saving Loading Fixed for sure/NewestVersion/bin/test/BasicMapTest.class
            Saving Loading Fixed for sure/NewestVersion/bin/test/BasicMonsterTest.class
            Saving Loading Fixed for sure/NewestVersion/bin/test/CombatManagerTest.class
            Saving Loading Fixed for sure/NewestVersion/bin/test/EntityTest.class
            Saving Loading Fixed for sure/NewestVersion/bin/test/GameScreenAssetsTest.class
            Saving Loading Fixed for sure/NewestVersion/bin/test/MonsterManagerTest.class
            Saving Loading Fixed for sure/NewestVersion/bin/test/PlayerTest.class
            Saving Loading Fixed for sure/NewestVersion/res/interface/Controlinstructions.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/MorrisRoman-Black.ttf
            Saving Loading Fixed for sure/NewestVersion/res/interface/MorrisRomanAlternate-Black.ttf
            Saving Loading Fixed for sure/NewestVersion/res/interface/Sketch Gothic School.ttf
            Saving Loading Fixed for sure/NewestVersion/res/interface/Sprial1.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/TITLE1.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/continueActive.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/continueInActive.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/continueMouseOver.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/controls.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/design2.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/design2slide2.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/design2transition.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/exitGame.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/exitGameMouseOver.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/explanation.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/menu2.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/newGame.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/newGameMouseOver.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/panicSlide.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/saveExit.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/saveExitMouseOver.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/skull.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/sprial2.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/test.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/test1.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/test2.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/test3.png
            Saving Loading Fixed for sure/NewestVersion/res/interface/tilepart2.png
            Saving Loading Fixed for sure/NewestVersion/res/map/32x32.bmp
            Saving Loading Fixed for sure/NewestVersion/res/map/Thumbs.db
            Saving Loading Fixed for sure/NewestVersion/res/map/clifveg2.bmp
            Saving Loading Fixed for sure/NewestVersion/res/map/floor1.tmx
            Saving Loading Fixed for sure/NewestVersion/res/map/floor2.tmx
            Saving Loading Fixed for sure/NewestVersion/res/map/floor3.tmx
            Saving Loading Fixed for sure/NewestVersion/res/map/floor4.tmx
            Saving Loading Fixed for sure/NewestVersion/res/map/floor5.tmx
            Saving Loading Fixed for sure/NewestVersion/res/map/floor6.tmx
            Saving Loading Fixed for sure/NewestVersion/res/map/floor7.tmx
            Saving Loading Fixed for sure/NewestVersion/res/map/secondTestMap.tmx
            Saving Loading Fixed for sure/NewestVersion/res/map/singleTilePassageWay.tmx
            Saving Loading Fixed for sure/NewestVersion/res/map/testMap..txt
            Saving Loading Fixed for sure/NewestVersion/res/map/testMap.tmx
            Saving Loading Fixed for sure/NewestVersion/res/map/tilea2.png
            Saving Loading Fixed for sure/NewestVersion/res/monster/dead.png
            Saving Loading Fixed for sure/NewestVersion/res/monster/dummySheet.png
            Saving Loading Fixed for sure/NewestVersion/res/player/Thumbs.db
            Saving Loading Fixed for sure/NewestVersion/res/player/intro1.png
            Saving Loading Fixed for sure/NewestVersion/res/player/intro10.png
            Saving Loading Fixed for sure/NewestVersion/res/player/intro11.png
            Saving Loading Fixed for sure/NewestVersion/res/player/intro2.png
            Saving Loading Fixed for sure/NewestVersion/res/player/intro3.png
            Saving Loading Fixed for sure/NewestVersion/res/player/intro4.png
            Saving Loading Fixed for sure/NewestVersion/res/player/intro5.png
            Saving Loading Fixed for sure/NewestVersion/res/player/intro6.png
            Saving Loading Fixed for sure/NewestVersion/res/player/intro7.png
            Saving Loading Fixed for sure/NewestVersion/res/player/intro8.png
            Saving Loading Fixed for sure/NewestVersion/res/player/intro9.png
            Saving Loading Fixed for sure/NewestVersion/res/player/template2.png
            Saving Loading Fixed for sure/NewestVersion/res/sound/A Time To Lose.wav
            Saving Loading Fixed for sure/NewestVersion/res/sound/Back To Programming.wav
            Saving Loading Fixed for sure/NewestVersion/res/sound/Bigger And Bigger.wav
            Saving Loading Fixed for sure/NewestVersion/res/sound/Catacombs.wav
            Saving Loading Fixed for sure/NewestVersion/res/sound/Feelings Are On The Rise.wav
            Saving Loading Fixed for sure/NewestVersion/res/sound/Flying In The Face Of Hope.wav
            Saving Loading Fixed for sure/NewestVersion/res/sound/Play At Your Own Risk.wav
            Saving Loading Fixed for sure/NewestVersion/res/sound/SFX/Level Up Ding.wav
            Saving Loading Fixed for sure/NewestVersion/res/sound/SFX/Monster Crunch.wav
            Saving Loading Fixed for sure/NewestVersion/res/sound/SFX/Monster Snarl.wav
            Saving Loading Fixed for sure/NewestVersion/res/sound/SFX/Player Grunt.wav
            Saving Loading Fixed for sure/NewestVersion/res/sound/SFX/Player Oof.wav
            Saving Loading Fixed for sure/NewestVersion/res/sound/SFX/Potential Monster Die.wav
            Saving Loading Fixed for sure/NewestVersion/res/sound/SFX/Swoosh.wav
            Saving Loading Fixed for sure/NewestVersion/res/sound/SFX/Sword Swing.wav
            Saving Loading Fixed for sure/NewestVersion/res/sound/Tank Battle.wav
            Saving Loading Fixed for sure/NewestVersion/res/sound/The Hero Of The Darkness.wav
            Saving Loading Fixed for sure/NewestVersion/src/gameStates/GameOverScreen.java
            Saving Loading Fixed for sure/NewestVersion/src/gameStates/GameScreen.java
            Saving Loading Fixed for sure/NewestVersion/src/gameStates/GameScreenAssets.java
            Saving Loading Fixed for sure/NewestVersion/src/gameStates/GameScreenAssetsTest.java
            Saving Loading Fixed for sure/NewestVersion/src/gameStates/MainMenuScreen.java
            Saving Loading Fixed for sure/NewestVersion/src/gameStates/Menu.java
            Saving Loading Fixed for sure/NewestVersion/src/gameStates/StateManager.java
            Saving Loading Fixed for sure/NewestVersion/src/gameStates/TransitionScreen.java
            Saving Loading Fixed for sure/NewestVersion/src/gameStates/Ver2GameDriver.java
            Saving Loading Fixed for sure/NewestVersion/src/gameStates/WinScreen.java
            Saving Loading Fixed for sure/NewestVersion/src/inputRelated/BasicButton.java
            Saving Loading Fixed for sure/NewestVersion/src/inputRelated/ButtonAction.java
            Saving Loading Fixed for sure/NewestVersion/src/inputRelated/ButtonListener.java
            Saving Loading Fixed for sure/NewestVersion/src/inputRelated/GameOverButtons.java
            Saving Loading Fixed for sure/NewestVersion/src/inputRelated/LoadingGame.java
            Saving Loading Fixed for sure/NewestVersion/src/inputRelated/MainMenuButtons.java
            Saving Loading Fixed for sure/NewestVersion/src/inputRelated/SavingGame.java
            Saving Loading Fixed for sure/NewestVersion/src/inputRelated/SlideOutMenu.java
            Saving Loading Fixed for sure/NewestVersion/src/managers/CombatManager.java
            Saving Loading Fixed for sure/NewestVersion/src/managers/CombatManagerTest.java
            Saving Loading Fixed for sure/NewestVersion/src/managers/EntityManager.java
            Saving Loading Fixed for sure/NewestVersion/src/managers/MonsterManager.java
            Saving Loading Fixed for sure/NewestVersion/src/managers/MonsterManagerTest.java
            Saving Loading Fixed for sure/NewestVersion/src/managers/SoundManager.java
            Saving Loading Fixed for sure/NewestVersion/src/mapRelated/BasicMap.java
            Saving Loading Fixed for sure/NewestVersion/src/mapRelated/BasicMapTest.java
            Saving Loading Fixed for sure/NewestVersion/src/monsterRelated/BasicMonster.java
            Saving Loading Fixed for sure/NewestVersion/src/monsterRelated/Entity.java
            Saving Loading Fixed for sure/NewestVersion/src/monsterRelated/EntityTest.java
            Saving Loading Fixed for sure/NewestVersion/src/playerRelated/Player.java
            Saving Loading Fixed for sure/NewestVersion/src/test/BasicMapTest.java
            Saving Loading Fixed for sure/NewestVersion/src/test/BasicMonsterTest.java
            Saving Loading Fixed for sure/NewestVersion/src/test/CombatManagerTest.java
            Saving Loading Fixed for sure/NewestVersion/src/test/EntityTest.java
            Saving Loading Fixed for sure/NewestVersion/src/test/GameScreenAssetsTest.java
            Saving Loading Fixed for sure/NewestVersion/src/test/MonsterManagerTest.java
            Saving Loading Fixed for sure/NewestVersion/src/test/PlayerTest.java
            VERSION W.I.P/version w.i.p/.classpath
            VERSION W.I.P/version w.i.p/.project
            VERSION W.I.P/version w.i.p/.settings/org.eclipse.jdt.core.prefs
            VERSION W.I.P/version w.i.p/bin/gameStates/Game$1.class
            VERSION W.I.P/version w.i.p/bin/gameStates/GameOver.class
            VERSION W.I.P/version w.i.p/bin/gameStates/GameScreenAssetsTest.class
            VERSION W.I.P/version w.i.p/bin/gameStates/Menu.class
            VERSION W.I.P/version w.i.p/bin/inputRelated/BuildButton.class
            VERSION W.I.P/version w.i.p/bin/inputRelated/ButtonAction.class
            VERSION W.I.P/version w.i.p/bin/inputRelated/ButtonListener.class
            VERSION W.I.P/version w.i.p/bin/managers/CombatManagerTest.class
            VERSION W.I.P/version w.i.p/bin/managers/EntityManager.class
            VERSION W.I.P/version w.i.p/bin/monsterRelated/PrintingTests.class
            VERSION W.I.P/version w.i.p/res/interface/Controlinstructions.png
            VERSION W.I.P/version w.i.p/res/interface/LoadGame2.png
            VERSION W.I.P/version w.i.p/res/interface/MenuBlankSlate.png
            VERSION W.I.P/version w.i.p/res/interface/MorrisRoman-Black.ttf
            VERSION W.I.P/version w.i.p/res/interface/MorrisRomanAlternate-Black.ttf
            VERSION W.I.P/version w.i.p/res/interface/Sketch Gothic School.ttf
            VERSION W.I.P/version w.i.p/res/interface/Sprial1.png
            VERSION W.I.P/version w.i.p/res/interface/TITLE1.png
            VERSION W.I.P/version w.i.p/res/interface/controls.png
            VERSION W.I.P/version w.i.p/res/interface/design2.png
            VERSION W.I.P/version w.i.p/res/interface/design2slide2.png
            VERSION W.I.P/version w.i.p/res/interface/design2transition.png
            VERSION W.I.P/version w.i.p/res/interface/loadGame.png
            VERSION W.I.P/version w.i.p/res/interface/menu.png
            VERSION W.I.P/version w.i.p/res/interface/menu2.png
            VERSION W.I.P/version w.i.p/res/interface/newGameButton1.png
            VERSION W.I.P/version w.i.p/res/interface/newGameButton2.png
            VERSION W.I.P/version w.i.p/res/interface/returnGame.png
            VERSION W.I.P/version w.i.p/res/interface/returnGameMouseOver.png
            VERSION W.I.P/version w.i.p/res/interface/sprial 3.png
            VERSION W.I.P/version w.i.p/res/interface/sprial2.png
            VERSION W.I.P/version w.i.p/res/interface/test.png
            VERSION W.I.P/version w.i.p/res/interface/test1.png
            VERSION W.I.P/version w.i.p/res/interface/test2.png
            VERSION W.I.P/version w.i.p/res/interface/test3.png
            VERSION W.I.P/version w.i.p/res/interface/tester.png
            VERSION W.I.P/version w.i.p/res/interface/tilepart2.png
            VERSION W.I.P/version w.i.p/res/map/32x32.bmp
            VERSION W.I.P/version w.i.p/res/map/Thumbs.db
            VERSION W.I.P/version w.i.p/res/map/clifveg2.bmp
            VERSION W.I.P/version w.i.p/res/map/floor1.tmx
            VERSION W.I.P/version w.i.p/res/map/floor2.tmx
            VERSION W.I.P/version w.i.p/res/map/floor5.tmx
            VERSION W.I.P/version w.i.p/res/map/floor6.tmx
            VERSION W.I.P/version w.i.p/res/map/secondTestMap.tmx
            VERSION W.I.P/version w.i.p/res/map/singleTilePassageWay.tmx
            VERSION W.I.P/version w.i.p/res/map/testMap..txt
            VERSION W.I.P/version w.i.p/res/map/testMap.tmx
            VERSION W.I.P/version w.i.p/res/map/tilea2.png
            VERSION W.I.P/version w.i.p/res/monster/Rodent0.png
            VERSION W.I.P/version w.i.p/res/monster/Thumbs.db
            VERSION W.I.P/version w.i.p/res/monster/Undead1.png
            VERSION W.I.P/version w.i.p/res/monster/dead.png
            VERSION W.I.P/version w.i.p/res/monster/dummySheet.png
            VERSION W.I.P/version w.i.p/res/player/Thumbs.db
            VERSION W.I.P/version w.i.p/res/player/evenLargerShadow.png
            VERSION W.I.P/version w.i.p/res/player/intro1.png
            VERSION W.I.P/version w.i.p/res/player/intro10.png
            VERSION W.I.P/version w.i.p/res/player/intro11.png
            VERSION W.I.P/version w.i.p/res/player/intro2.png
            VERSION W.I.P/version w.i.p/res/player/intro3.png
            VERSION W.I.P/version w.i.p/res/player/intro4.png
            VERSION W.I.P/version w.i.p/res/player/intro5.png
            VERSION W.I.P/version w.i.p/res/player/intro6.png
            VERSION W.I.P/version w.i.p/res/player/intro7.png
            VERSION W.I.P/version w.i.p/res/player/intro8.png
            VERSION W.I.P/version w.i.p/res/player/intro9.png
            VERSION W.I.P/version w.i.p/res/player/largerShadow.png
            VERSION W.I.P/version w.i.p/res/player/template2.png
            VERSION W.I.P/version w.i.p/res/sound/A Time To Lose.wav
            VERSION W.I.P/version w.i.p/res/sound/Bigger And Bigger.wav
            VERSION W.I.P/version w.i.p/res/sound/Catacombs.wav
            VERSION W.I.P/version w.i.p/res/sound/Feelings Are On The Rise.wav
            VERSION W.I.P/version w.i.p/res/sound/Flying In The Face Of Hope.wav
            VERSION W.I.P/version w.i.p/res/sound/Play At Your Own Risk.wav
            VERSION W.I.P/version w.i.p/res/sound/SFX/Sword Swing.wav
            VERSION W.I.P/version w.i.p/res/sound/Tank Battle.wav
            VERSION W.I.P/version w.i.p/res/sound/The Hero Of The Darkness.wav
            VERSION W.I.P/version w.i.p/src/gameStates/GameOver.java
            VERSION W.I.P/version w.i.p/src/gameStates/GameScreenAssetsTest.java
            VERSION W.I.P/version w.i.p/src/gameStates/Menu.java
            VERSION W.I.P/version w.i.p/src/inputRelated/BuildButton.java
            VERSION W.I.P/version w.i.p/src/inputRelated/ButtonListener.java
            VERSION W.I.P/version w.i.p/src/managers/CombatManagerTest.java
            VERSION W.I.P/version w.i.p/src/monsterRelated/PrintingTests.java
            Version 1.0(Current)/NewestVersion/bin/gameStates/GameScreen.class
            Version 1.0(Current)/NewestVersion/bin/gameStates/GameScreenAssets$1.class
            Version 1.0(Current)/NewestVersion/bin/gameStates/GameScreenAssets.class
            Version 1.0(Current)/NewestVersion/bin/gameStates/MainMenuScreen.class
            Version 1.0(Current)/NewestVersion/bin/gameStates/StateManager.class
            Version 1.0(Current)/NewestVersion/bin/gameStates/TransitionScreen.class
            Version 1.0(Current)/NewestVersion/bin/gameStates/Ver2GameDriver.class
            Version 1.0(Current)/NewestVersion/bin/inputRelated/BasicButton.class
            Version 1.0(Current)/NewestVersion/bin/inputRelated/LoadingGame.class
            Version 1.0(Current)/NewestVersion/bin/inputRelated/MainMenuButtons$1.class
            Version 1.0(Current)/NewestVersion/bin/inputRelated/MainMenuButtons$2.class
            Version 1.0(Current)/NewestVersion/bin/inputRelated/MainMenuButtons.class
            Version 1.0(Current)/NewestVersion/bin/inputRelated/SavingGame.class
            Version 1.0(Current)/NewestVersion/bin/inputRelated/SlideOutMenu$1.class
            Version 1.0(Current)/NewestVersion/bin/inputRelated/SlideOutMenu.class
            Version 1.0(Current)/NewestVersion/bin/managers/CombatManager.class
            Version 1.0(Current)/NewestVersion/bin/managers/MonsterManager.class
            Version 1.0(Current)/NewestVersion/bin/managers/SoundManager.class
            Version 1.0(Current)/NewestVersion/bin/mapRelated/BasicMap.class
            Version 1.0(Current)/NewestVersion/bin/monsterRelated/BasicMonster.class
            Version 1.0(Current)/NewestVersion/bin/monsterRelated/Entity.class
            Version 1.0(Current)/NewestVersion/bin/playerRelated/Player.class
            Version 1.0(Current)/NewestVersion/bin/test/BasicMapTest.class
            Version 1.0(Current)/NewestVersion/bin/test/BasicMonsterTest.class
            Version 1.0(Current)/NewestVersion/bin/test/CombatManagerTest.class
            Version 1.0(Current)/NewestVersion/bin/test/EntityTest.class
            Version 1.0(Current)/NewestVersion/bin/test/GameScreenAssetsTest.class
            Version 1.0(Current)/NewestVersion/bin/test/MonsterManagerTest.class
            Version 1.0(Current)/NewestVersion/bin/test/PlayerTest.class
            Version 1.0(Current)/NewestVersion/res/interface/Thumbs.db
            Version 1.0(Current)/NewestVersion/res/interface/continueActive.png
            Version 1.0(Current)/NewestVersion/res/interface/continueInActive.png
            Version 1.0(Current)/NewestVersion/res/interface/continueMouseOver.png
            Version 1.0(Current)/NewestVersion/res/interface/exitGame.png
            Version 1.0(Current)/NewestVersion/res/interface/exitGameMouseOver.png
            Version 1.0(Current)/NewestVersion/res/interface/explanation.png
            Version 1.0(Current)/NewestVersion/res/interface/newGame.png
            Version 1.0(Current)/NewestVersion/res/interface/newGameMouseOver.png
            Version 1.0(Current)/NewestVersion/res/interface/panicSlide.png
            Version 1.0(Current)/NewestVersion/res/interface/saveExit.png
            Version 1.0(Current)/NewestVersion/res/interface/saveExitMouseOver.png
            Version 1.0(Current)/NewestVersion/res/interface/skull.png
            Version 1.0(Current)/NewestVersion/res/map/floor3.tmx
            Version 1.0(Current)/NewestVersion/res/map/floor4.tmx
            Version 1.0(Current)/NewestVersion/res/map/floor7.tmx
            Version 1.0(Current)/NewestVersion/res/sound/Back To Programming.wav
            Version 1.0(Current)/NewestVersion/res/sound/SFX/Level Up Ding.wav
            Version 1.0(Current)/NewestVersion/res/sound/SFX/Monster Crunch.wav
            Version 1.0(Current)/NewestVersion/res/sound/SFX/Monster Snarl.wav
            Version 1.0(Current)/NewestVersion/res/sound/SFX/Player Grunt.wav
            Version 1.0(Current)/NewestVersion/res/sound/SFX/Player Oof.wav
            Version 1.0(Current)/NewestVersion/res/sound/SFX/Potential Monster Die.wav
            Version 1.0(Current)/NewestVersion/res/sound/SFX/Swoosh.wav
            Version 1.0(Current)/NewestVersion/src/gameStates/GameOverScreen.java
            Version 1.0(Current)/NewestVersion/src/gameStates/GameScreen.java
            Version 1.0(Current)/NewestVersion/src/gameStates/GameScreenAssets.java
            Version 1.0(Current)/NewestVersion/src/gameStates/MainMenuScreen.java
            Version 1.0(Current)/NewestVersion/src/gameStates/StateManager.java
            Version 1.0(Current)/NewestVersion/src/gameStates/TransitionScreen.java
            Version 1.0(Current)/NewestVersion/src/gameStates/Ver2GameDriver.java
            Version 1.0(Current)/NewestVersion/src/gameStates/WinScreen.java
            Version 1.0(Current)/NewestVersion/src/inputRelated/BasicButton.java
            Version 1.0(Current)/NewestVersion/src/inputRelated/ButtonAction.java
            Version 1.0(Current)/NewestVersion/src/inputRelated/LoadingGame.java
            Version 1.0(Current)/NewestVersion/src/inputRelated/MainMenuButtons.java
            Version 1.0(Current)/NewestVersion/src/inputRelated/SavingGame.java
            Version 1.0(Current)/NewestVersion/src/inputRelated/SlideOutMenu.java
            Version 1.0(Current)/NewestVersion/src/managers/CombatManager.java
            Version 1.0(Current)/NewestVersion/src/managers/EntityManager.java
            Version 1.0(Current)/NewestVersion/src/managers/MonsterManager.java
            Version 1.0(Current)/NewestVersion/src/managers/SoundManager.java
            Version 1.0(Current)/NewestVersion/src/mapRelated/BasicMap.java
            Version 1.0(Current)/NewestVersion/src/monsterRelated/BasicMonster.java
            Version 1.0(Current)/NewestVersion/src/monsterRelated/Entity.java
            Version 1.0(Current)/NewestVersion/src/playerRelated/Player.java
            Version 1.0(Current)/NewestVersion/src/test/BasicMapTest.java
            Version 1.0(Current)/NewestVersion/src/test/BasicMonsterTest.java
            Version 1.0(Current)/NewestVersion/src/test/CombatManagerTest.java
            Version 1.0(Current)/NewestVersion/src/test/EntityTest.java
            Version 1.0(Current)/NewestVersion/src/test/GameScreenAssetsTest.java
            Version 1.0(Current)/NewestVersion/src/test/MonsterManagerTest.java
            Version 1.0(Current)/NewestVersion/src/test/PlayerTest.java
            Version 1.0/NewestVersion/bin/gameStates/Game.class
            Version 1.0/NewestVersion/bin/gameStates/LoadGame.class
            Version 1.0/NewestVersion/bin/inputRelated/AnimatedButton.class
            Version 1.0/NewestVersion/bin/inputRelated/GameOverButtons$1.class
            Version 1.0/NewestVersion/bin/inputRelated/GameOverButtons$2.class
            Version 1.0/NewestVersion/bin/inputRelated/GameOverButtons.class
            Version 1.0/NewestVersion/bin/inputRelated/PopUpButtons$1.class
            Version 1.0/NewestVersion/bin/inputRelated/PopUpButtons$2.class
            Version 1.0/NewestVersion/bin/inputRelated/PopUpButtons$3.class
            Version 1.0/NewestVersion/bin/inputRelated/PopUpButtons.class
            Version 1.0/NewestVersion/bin/inputRelated/PopUpWindow.class
            Version 1.0/NewestVersion/bin/managers/MonsterManagerTest.class
            Version 1.0/NewestVersion/bin/mapRelated/BasicMapTest.class
            Version 1.0/NewestVersion/bin/monsterRelated/BasicMonsterTest.class
            Version 1.0/NewestVersion/bin/monsterRelated/EntityTest.class
            Version 1.0/NewestVersion/bin/playerRelated/PlayerTest.class
            Version 1.0/NewestVersion/src/gameStates/Game.java
            Version 1.0/NewestVersion/src/gameStates/LoadGame.java
            Version 1.0/NewestVersion/src/inputRelated/AnimatedButton.java
            Version 1.0/NewestVersion/src/inputRelated/GameOverButtons.java
            Version 1.0/NewestVersion/src/inputRelated/PopUpButtons.java
            Version 1.0/NewestVersion/src/inputRelated/PopUpWindow.java
            Version 1.0/NewestVersion/src/managers/MonsterManagerTest.java
            Version 1.0/NewestVersion/src/mapRelated/BasicMapTest.java
            Version 1.0/NewestVersion/src/monsterRelated/BasicMonsterTest.java
            Version 1.0/NewestVersion/src/monsterRelated/EntityTest.java
            Version 1.0/NewestVersion/src/playerRelated/PlayerTest.java
            Version 1.1/NewestVersion/bin/test/BasicMapTest.class
            Version 1.1/NewestVersion/bin/test/CombatManagerTest.class
            Version 1.1/NewestVersion/bin/test/MonsterManagerTest.class
            Version 1.1/NewestVersion/res/monster/dead.png
            Version 1.1/NewestVersion/res/player/intro27.png
            Version 1.1/NewestVersion/res/player/template2.png
            Version 1.1/NewestVersion/src/gameStates/MainMenuScreen.java
            Version 1.1/NewestVersion/src/test/BasicMapTest.java
            Version 1.1/NewestVersion/src/test/CombatManagerTest.java
            Version 1.1/NewestVersion/src/test/EntityTest.java
            Version 1.1/NewestVersion/src/test/GameScreenAssetsTest.java
            Version 1.1/NewestVersion/src/test/MonsterManagerTest.java

commit 76eb21554c2bf185192acb65221c7542d33bd9d2
Author: Colin-Lo <Colin.lo@ucalgary.ca>
Date:   Wed Apr 1 00:27:27 2015 -0600

    fixed floor 4
    
    Sorry that I did this in your branch. I really needed that last minute
    fix in. It was possible to crash by going all the way to the right.

diff --git a/Version 1.1/NewestVersion/res/map/floor4.tmx b/Version 1.1/NewestVersion/res/map/floor4.tmx
index 8bb18c8..a7045ef 100644
--- a/Version 1.1/NewestVersion/res/map/floor4.tmx	
+++ b/Version 1.1/NewestVersion/res/map/floor4.tmx	
@@ -87,7 +87,7 @@
    <property name="blocked" value="false"/>
   </properties>
   <data encoding="base64" compression="gzip">
-   H4sIAAAAAAAAC+2UQQ6CMBREaVy5hovoHeRi3oCFxyDBG0iCa3cegyvoT/hhMkypxZ1x8VJabf90/sBQFMXwA3Slxn57TPj/bBzfYzvxTd1+Yhfm55iWfVg++znH6jsddp7Shhr9/i3A8xif+o13RKx+HWavOlEb5yPss3q+FusX97wX90YtPmK/sAaexX5uzYjaj2teDz1UPcN9KV8Yzylnh71AzdxL1GK5tfFQreclRi1y6+tYk+esZRS+rGk5Bw33iX3A9x113Isl5s211CgtuHYSvvA3JpYrq33JgLWo7KYyndLSZGhRfjxXtKS+g7m+NKRlyzufIrdHtz+SF6t4ECLACAAA
+   H4sIAAAAAAAAC+2UTQ6CMBCF27hyDRfRO8jFvAELj0ECN5AE1u48BlfQSTrhZXht+dkZF19Kq+28vnkwOOeGH6AtOPLbK6D/k3H6jk3gSN0+cPLzc0zL2S+f9ZxreUyHnMe0oUa9fwPYeYy1fuMdEalf+dmrltTG+QT7pJ6uxfple96Te6MWHbFfWAPPsn7uzQjbj2taDz1kPcN9OV8smlObHesFara9RC2SWxkvZTovMSqSW13HmnZutUzEl5SWu+fYPlkf8H1HHaNbIt50BYdpwbUb8cV+Y2K5ktqPlYzEF5bdXKZzWuoNWpgf74SW3Hdwqy+10bLnnc+xtUfPP5QPuWFCgcAIAAA=
   </data>
  </layer>
 </map>

commit a7b4a398eaa7b885453035a9cf778ad1427bbe81
Author: Ihmayor <ihmayor@ucalgary.ca>
Date:   Tue Mar 31 22:12:48 2015 -0600

    Revert "THIS now works"
    aaaaaaaaaaaaaaaaaaa
    
    This reverts commit 74da7ab5cd868cde90339dccfbabe813835b8db8.

diff --git a/Version 1.0(Current)/NewestVersion/.classpath b/Version 1.0(Current)/NewestVersion/.classpath
new file mode 100644
index 0000000..2bc554e
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/.classpath	
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.7"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.USER_LIBRARY/Slick2D"/>
+	<classpathentry kind="lib" path="res"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/Version 1.0(Current)/NewestVersion/.project b/Version 1.0(Current)/NewestVersion/.project
new file mode 100644
index 0000000..6f00240
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/.project	
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>NewestVersion</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/Version 1.0(Current)/NewestVersion/.settings/org.eclipse.jdt.core.prefs b/Version 1.0(Current)/NewestVersion/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..7341ab1
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/.settings/org.eclipse.jdt.core.prefs	
@@ -0,0 +1,11 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.7
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.7
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.7
diff --git a/Version 1.0(Current)/NewestVersion/bin/gameStates/GameOverScreen.class b/Version 1.0(Current)/NewestVersion/bin/gameStates/GameOverScreen.class
new file mode 100644
index 0000000..7148544
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/gameStates/GameOverScreen.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/gameStates/GameScreen.class b/Version 1.0(Current)/NewestVersion/bin/gameStates/GameScreen.class
new file mode 100644
index 0000000..f913e0d
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/gameStates/GameScreen.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/gameStates/GameScreenAssets$1.class b/Version 1.0(Current)/NewestVersion/bin/gameStates/GameScreenAssets$1.class
new file mode 100644
index 0000000..33d388b
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/gameStates/GameScreenAssets$1.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/gameStates/GameScreenAssets.class b/Version 1.0(Current)/NewestVersion/bin/gameStates/GameScreenAssets.class
new file mode 100644
index 0000000..38dd5df
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/gameStates/GameScreenAssets.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/gameStates/MainMenuScreen.class b/Version 1.0(Current)/NewestVersion/bin/gameStates/MainMenuScreen.class
new file mode 100644
index 0000000..fa988b2
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/gameStates/MainMenuScreen.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/gameStates/StateManager.class b/Version 1.0(Current)/NewestVersion/bin/gameStates/StateManager.class
new file mode 100644
index 0000000..4e49262
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/gameStates/StateManager.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/gameStates/TransitionScreen.class b/Version 1.0(Current)/NewestVersion/bin/gameStates/TransitionScreen.class
new file mode 100644
index 0000000..260ba1b
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/gameStates/TransitionScreen.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/gameStates/Ver2GameDriver.class b/Version 1.0(Current)/NewestVersion/bin/gameStates/Ver2GameDriver.class
new file mode 100644
index 0000000..83413bc
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/gameStates/Ver2GameDriver.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/gameStates/WinScreen.class b/Version 1.0(Current)/NewestVersion/bin/gameStates/WinScreen.class
new file mode 100644
index 0000000..ddc09d0
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/gameStates/WinScreen.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/inputRelated/BasicButton.class b/Version 1.0(Current)/NewestVersion/bin/inputRelated/BasicButton.class
new file mode 100644
index 0000000..6e4bb52
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/inputRelated/BasicButton.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/inputRelated/ButtonAction.class b/Version 1.0(Current)/NewestVersion/bin/inputRelated/ButtonAction.class
new file mode 100644
index 0000000..c199b7a
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/inputRelated/ButtonAction.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/inputRelated/ButtonListener.class b/Version 1.0(Current)/NewestVersion/bin/inputRelated/ButtonListener.class
new file mode 100644
index 0000000..8c92e43
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/inputRelated/ButtonListener.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/inputRelated/EndGameButtons$1.class b/Version 1.0(Current)/NewestVersion/bin/inputRelated/EndGameButtons$1.class
new file mode 100644
index 0000000..5771abd
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/inputRelated/EndGameButtons$1.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/inputRelated/EndGameButtons$2.class b/Version 1.0(Current)/NewestVersion/bin/inputRelated/EndGameButtons$2.class
new file mode 100644
index 0000000..3ee8a29
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/inputRelated/EndGameButtons$2.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/inputRelated/EndGameButtons.class b/Version 1.0(Current)/NewestVersion/bin/inputRelated/EndGameButtons.class
new file mode 100644
index 0000000..8a12277
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/inputRelated/EndGameButtons.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/inputRelated/LoadingGame.class b/Version 1.0(Current)/NewestVersion/bin/inputRelated/LoadingGame.class
new file mode 100644
index 0000000..cdbb856
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/inputRelated/LoadingGame.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/inputRelated/MainMenuButtons$1.class b/Version 1.0(Current)/NewestVersion/bin/inputRelated/MainMenuButtons$1.class
new file mode 100644
index 0000000..fce8d66
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/inputRelated/MainMenuButtons$1.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/inputRelated/MainMenuButtons$2.class b/Version 1.0(Current)/NewestVersion/bin/inputRelated/MainMenuButtons$2.class
new file mode 100644
index 0000000..35b06de
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/inputRelated/MainMenuButtons$2.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/inputRelated/MainMenuButtons.class b/Version 1.0(Current)/NewestVersion/bin/inputRelated/MainMenuButtons.class
new file mode 100644
index 0000000..53c8cc8
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/inputRelated/MainMenuButtons.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/inputRelated/SavingGame.class b/Version 1.0(Current)/NewestVersion/bin/inputRelated/SavingGame.class
new file mode 100644
index 0000000..e48347b
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/inputRelated/SavingGame.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/inputRelated/SlideOutMenu$1.class b/Version 1.0(Current)/NewestVersion/bin/inputRelated/SlideOutMenu$1.class
new file mode 100644
index 0000000..f8ba5dd
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/inputRelated/SlideOutMenu$1.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/inputRelated/SlideOutMenu.class b/Version 1.0(Current)/NewestVersion/bin/inputRelated/SlideOutMenu.class
new file mode 100644
index 0000000..1ae05d4
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/inputRelated/SlideOutMenu.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/managers/CombatManager.class b/Version 1.0(Current)/NewestVersion/bin/managers/CombatManager.class
new file mode 100644
index 0000000..c2b67db
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/managers/CombatManager.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/managers/EntityManager.class b/Version 1.0(Current)/NewestVersion/bin/managers/EntityManager.class
new file mode 100644
index 0000000..c0359d1
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/managers/EntityManager.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/managers/MonsterManager.class b/Version 1.0(Current)/NewestVersion/bin/managers/MonsterManager.class
new file mode 100644
index 0000000..f357be0
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/managers/MonsterManager.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/managers/SoundManager.class b/Version 1.0(Current)/NewestVersion/bin/managers/SoundManager.class
new file mode 100644
index 0000000..d320295
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/managers/SoundManager.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/mapRelated/BasicMap.class b/Version 1.0(Current)/NewestVersion/bin/mapRelated/BasicMap.class
new file mode 100644
index 0000000..3158a7e
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/mapRelated/BasicMap.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/monsterRelated/BasicMonster.class b/Version 1.0(Current)/NewestVersion/bin/monsterRelated/BasicMonster.class
new file mode 100644
index 0000000..4c70f24
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/monsterRelated/BasicMonster.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/monsterRelated/Entity.class b/Version 1.0(Current)/NewestVersion/bin/monsterRelated/Entity.class
new file mode 100644
index 0000000..75654b9
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/monsterRelated/Entity.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/playerRelated/Player.class b/Version 1.0(Current)/NewestVersion/bin/playerRelated/Player.class
new file mode 100644
index 0000000..78ac7ab
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/playerRelated/Player.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/test/BasicMapTest.class b/Version 1.0(Current)/NewestVersion/bin/test/BasicMapTest.class
new file mode 100644
index 0000000..60229d5
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/test/BasicMapTest.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/test/BasicMonsterTest.class b/Version 1.0(Current)/NewestVersion/bin/test/BasicMonsterTest.class
new file mode 100644
index 0000000..d57b4dc
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/test/BasicMonsterTest.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/test/CombatManagerTest.class b/Version 1.0(Current)/NewestVersion/bin/test/CombatManagerTest.class
new file mode 100644
index 0000000..f3cadf6
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/test/CombatManagerTest.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/test/EntityTest.class b/Version 1.0(Current)/NewestVersion/bin/test/EntityTest.class
new file mode 100644
index 0000000..f13e933
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/test/EntityTest.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/test/GameScreenAssetsTest.class b/Version 1.0(Current)/NewestVersion/bin/test/GameScreenAssetsTest.class
new file mode 100644
index 0000000..02140f7
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/test/GameScreenAssetsTest.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/test/MonsterManagerTest.class b/Version 1.0(Current)/NewestVersion/bin/test/MonsterManagerTest.class
new file mode 100644
index 0000000..5cd0d3e
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/test/MonsterManagerTest.class differ
diff --git a/Version 1.0(Current)/NewestVersion/bin/test/PlayerTest.class b/Version 1.0(Current)/NewestVersion/bin/test/PlayerTest.class
new file mode 100644
index 0000000..10bb954
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/bin/test/PlayerTest.class differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/Controlinstructions.png b/Version 1.0(Current)/NewestVersion/res/interface/Controlinstructions.png
new file mode 100644
index 0000000..cc51189
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/Controlinstructions.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/MorrisRoman-Black.ttf b/Version 1.0(Current)/NewestVersion/res/interface/MorrisRoman-Black.ttf
new file mode 100644
index 0000000..791f725
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/MorrisRoman-Black.ttf differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/MorrisRomanAlternate-Black.ttf b/Version 1.0(Current)/NewestVersion/res/interface/MorrisRomanAlternate-Black.ttf
new file mode 100644
index 0000000..c93fbbf
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/MorrisRomanAlternate-Black.ttf differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/Sketch Gothic School.ttf b/Version 1.0(Current)/NewestVersion/res/interface/Sketch Gothic School.ttf
new file mode 100644
index 0000000..ab77776
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/Sketch Gothic School.ttf differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/TITLE1.png b/Version 1.0(Current)/NewestVersion/res/interface/TITLE1.png
new file mode 100644
index 0000000..17b8732
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/TITLE1.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/Thumbs.db b/Version 1.0(Current)/NewestVersion/res/interface/Thumbs.db
new file mode 100644
index 0000000..a2a897d
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/Thumbs.db differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/continueActive.png b/Version 1.0(Current)/NewestVersion/res/interface/continueActive.png
new file mode 100644
index 0000000..3a165d7
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/continueActive.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/continueInActive.png b/Version 1.0(Current)/NewestVersion/res/interface/continueInActive.png
new file mode 100644
index 0000000..d368d99
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/continueInActive.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/continueMouseOver.png b/Version 1.0(Current)/NewestVersion/res/interface/continueMouseOver.png
new file mode 100644
index 0000000..5766450
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/continueMouseOver.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/controls.png b/Version 1.0(Current)/NewestVersion/res/interface/controls.png
new file mode 100644
index 0000000..9caf2bb
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/controls.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/design2.png b/Version 1.0(Current)/NewestVersion/res/interface/design2.png
new file mode 100644
index 0000000..f34af79
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/design2.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/design2slide2.png b/Version 1.0(Current)/NewestVersion/res/interface/design2slide2.png
new file mode 100644
index 0000000..4ed2ea6
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/design2slide2.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/design2transition.png b/Version 1.0(Current)/NewestVersion/res/interface/design2transition.png
new file mode 100644
index 0000000..0c611c5
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/design2transition.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/exitGame.png b/Version 1.0(Current)/NewestVersion/res/interface/exitGame.png
new file mode 100644
index 0000000..d8f7b94
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/exitGame.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/exitGameMouseOver.png b/Version 1.0(Current)/NewestVersion/res/interface/exitGameMouseOver.png
new file mode 100644
index 0000000..5a2aab4
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/exitGameMouseOver.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/explanation.png b/Version 1.0(Current)/NewestVersion/res/interface/explanation.png
new file mode 100644
index 0000000..9ab026c
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/explanation.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/menu2.png b/Version 1.0(Current)/NewestVersion/res/interface/menu2.png
new file mode 100644
index 0000000..755b80f
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/menu2.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/newGame.png b/Version 1.0(Current)/NewestVersion/res/interface/newGame.png
new file mode 100644
index 0000000..1ffd201
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/newGame.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/newGameMouseOver.png b/Version 1.0(Current)/NewestVersion/res/interface/newGameMouseOver.png
new file mode 100644
index 0000000..323ec7e
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/newGameMouseOver.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/panicSlide.png b/Version 1.0(Current)/NewestVersion/res/interface/panicSlide.png
new file mode 100644
index 0000000..e43a1bd
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/panicSlide.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/saveExit.png b/Version 1.0(Current)/NewestVersion/res/interface/saveExit.png
new file mode 100644
index 0000000..f1c7142
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/saveExit.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/saveExitMouseOver.png b/Version 1.0(Current)/NewestVersion/res/interface/saveExitMouseOver.png
new file mode 100644
index 0000000..7305f79
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/saveExitMouseOver.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/skull.png b/Version 1.0(Current)/NewestVersion/res/interface/skull.png
new file mode 100644
index 0000000..ee30520
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/skull.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/test1.png b/Version 1.0(Current)/NewestVersion/res/interface/test1.png
new file mode 100644
index 0000000..3e56760
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/test1.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/test2.png b/Version 1.0(Current)/NewestVersion/res/interface/test2.png
new file mode 100644
index 0000000..1caf91c
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/test2.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/test3.png b/Version 1.0(Current)/NewestVersion/res/interface/test3.png
new file mode 100644
index 0000000..0da22af
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/test3.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/interface/tilepart2.png b/Version 1.0(Current)/NewestVersion/res/interface/tilepart2.png
new file mode 100644
index 0000000..229ef59
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/interface/tilepart2.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/map/32x32.bmp b/Version 1.0(Current)/NewestVersion/res/map/32x32.bmp
new file mode 100644
index 0000000..baf1eec
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/map/32x32.bmp differ
diff --git a/Version 1.0(Current)/NewestVersion/res/map/Thumbs.db b/Version 1.0(Current)/NewestVersion/res/map/Thumbs.db
new file mode 100644
index 0000000..e143d70
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/map/Thumbs.db differ
diff --git a/Version 1.0(Current)/NewestVersion/res/map/clifveg2.bmp b/Version 1.0(Current)/NewestVersion/res/map/clifveg2.bmp
new file mode 100644
index 0000000..0002313
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/map/clifveg2.bmp differ
diff --git a/Version 1.0(Current)/NewestVersion/res/map/floor1.tmx b/Version 1.0(Current)/NewestVersion/res/map/floor1.tmx
new file mode 100644
index 0000000..55f24d1
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/res/map/floor1.tmx	
@@ -0,0 +1,50 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="35" height="16" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="clifveg2" tilewidth="32" tileheight="32">
+  <image source="clifveg2.bmp" trans="5555ff" width="640" height="480"/>
+ </tileset>
+ <tileset firstgid="301" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="tilea2.png" width="512" height="384"/>
+ </tileset>
+ <tileset firstgid="493" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="0">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="24">
+   <properties>
+    <property name="stairs" value="tru"/>
+   </properties>
+  </tile>
+ </tileset>
+ <layer name="Tile Layer 1" width="35" height="16">
+  <properties>
+   <property name="blocked" value="false"/>
+  </properties>
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC+2TSwqAMBBDR73ECJ7Se7voDVyoUMN8S8WFLh5oDTadpGUgKh9kpgN8Ro2mf8JLTVQjrWfxvGW8LCcsrGUy6eGFYW8O+rDy9+bmaer90cvlWftHNjuG7+toa5nu8+vdYStHaU4XLV4ivUHf0V719KJlrL1b/cn20Tqzl2mdD2oZiN6X7F2qu9vSE+2Mk3FP3mL7EdkBu24TysAIAAA=
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.0(Current)/NewestVersion/res/map/floor2.tmx b/Version 1.0(Current)/NewestVersion/res/map/floor2.tmx
new file mode 100644
index 0000000..fe81ffd
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/res/map/floor2.tmx	
@@ -0,0 +1,55 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="35" height="16" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="clifveg2" tilewidth="32" tileheight="32">
+  <image source="clifveg2.bmp" trans="5555ff" width="640" height="480"/>
+ </tileset>
+ <tileset firstgid="301" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="tilea2.png" width="512" height="384"/>
+ </tileset>
+ <tileset firstgid="493" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="0">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="6">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="194">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <layer name="Tile Layer 1" width="35" height="16">
+  <properties>
+   <property name="blocked" value="false"/>
+  </properties>
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC/vEyMDwaRDh9Uz4MaXmNzAhMDXdgmxuIRMqHx3T0y2EwqIIj/vo7RYYu4iEeKZHHKGrRQ8zctNuIRYxfOGES46YMC5iwq4e3X/0cAshNdjksIUVOW4hJh5xuQVfOiHXLcx43IcvjmjhFnxi6PK0dAshdaSUVaToI8VceuO3oxgrBgAWIVKowAgAAA==
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.0(Current)/NewestVersion/res/map/floor3.tmx b/Version 1.0(Current)/NewestVersion/res/map/floor3.tmx
new file mode 100644
index 0000000..3cda2e0
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/res/map/floor3.tmx	
@@ -0,0 +1,58 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="35" height="16" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="tilea2.png" width="512" height="384"/>
+ </tileset>
+ <tileset firstgid="193" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="0">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="24">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="3354">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <tileset firstgid="4737" name="clifveg2" tilewidth="32" tileheight="32">
+  <image source="clifveg2.bmp" width="640" height="480"/>
+ </tileset>
+ <tileset firstgid="5037" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+ </tileset>
+ <layer name="Tile Layer 1" width="35" height="16">
+  <properties>
+   <property name="blocked" value="false"/>
+  </properties>
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC+2UsQ3AIAwEvUDmyfyZIgXLRCmQEHrbD/4iRYovABsO86YdZu1jOm19vivaM4vJ8ubcPvbmVQxsPuJBsRUGhoepU1TXqle8d8n4FIp4dmIrvvW8wNw/O2+nZuP5kUdnb2TrOxwRA/Ip66/K/xLViu37MU7V44qcW9Rj6H7IV5W/ZpXV41G9wavLfiE9XPlC58AIAAA=
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.0(Current)/NewestVersion/res/map/floor4.tmx b/Version 1.0(Current)/NewestVersion/res/map/floor4.tmx
new file mode 100644
index 0000000..8bb18c8
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/res/map/floor4.tmx	
@@ -0,0 +1,93 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="35" height="16" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="tilea2.png" width="512" height="384"/>
+ </tileset>
+ <tileset firstgid="193" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="0">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="6">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="24">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="194">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="3354">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4229">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4232">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <tileset firstgid="4737" name="clifveg2" tilewidth="32" tileheight="32">
+  <image source="clifveg2.bmp" width="640" height="480"/>
+ </tileset>
+ <tileset firstgid="5037" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="6">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <layer name="Tile Layer 1" width="35" height="16">
+  <properties>
+   <property name="blocked" value="false"/>
+  </properties>
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC+2UQQ6CMBREaVy5hovoHeRi3oCFxyDBG0iCa3cegyvoT/hhMkypxZ1x8VJabf90/sBQFMXwA3Slxn57TPj/bBzfYzvxTd1+Yhfm55iWfVg++znH6jsddp7Shhr9/i3A8xif+o13RKx+HWavOlEb5yPss3q+FusX97wX90YtPmK/sAaexX5uzYjaj2teDz1UPcN9KV8Yzylnh71AzdxL1GK5tfFQreclRi1y6+tYk+esZRS+rGk5Bw33iX3A9x113Isl5s211CgtuHYSvvA3JpYrq33JgLWo7KYyndLSZGhRfjxXtKS+g7m+NKRlyzufIrdHtz+SF6t4ECLACAAA
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.0(Current)/NewestVersion/res/map/floor5.tmx b/Version 1.0(Current)/NewestVersion/res/map/floor5.tmx
new file mode 100644
index 0000000..44d46ac
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/res/map/floor5.tmx	
@@ -0,0 +1,133 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="35" height="16" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="tilea2.png" width="512" height="384"/>
+ </tileset>
+ <tileset firstgid="193" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="0">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="6">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="19">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="21">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="24">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="154">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="194">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="3354">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4227">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4229">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4232">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <tileset firstgid="4737" name="clifveg2" tilewidth="32" tileheight="32">
+  <image source="clifveg2.bmp" width="640" height="480"/>
+ </tileset>
+ <tileset firstgid="5037" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="151">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="152">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="153">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="154">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="156">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="194">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <layer name="Tile Layer 1" width="35" height="16">
+  <properties>
+   <property name="blocked" value="false"/>
+  </properties>
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC+2VQRKCMAxFwwmUkb0bb+AVdPAOHoIjeRbrOL2WVsw0fJIWC7py8QfSMuT1JwRPRP6prpkmT8vr/pYXLPtdFMa8tgTfqY7S9jl3CwyHppfGJ1n43cdqmEfm1db4eY1F8wVZZIwsFpfFwrHmT8iBsVU3rFHIjVyW+Fm8l72LOWRfoE9riirxxeLWzpzzZUVRlhfIYvWTxnKuhixa76b6BXNN/abm+pLrXdmX1jzY0ngu8J4ju19S8yVVo+DVhfp50dbja2pGuYLZadXotoln0jjazLx0Qp8yWXqxFPryDZZf/+fm6PqXqgctJT+TwAgAAA==
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.0(Current)/NewestVersion/res/map/floor6.tmx b/Version 1.0(Current)/NewestVersion/res/map/floor6.tmx
new file mode 100644
index 0000000..63c876c
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/res/map/floor6.tmx	
@@ -0,0 +1,148 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="35" height="16" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="tilea2.png" width="512" height="384"/>
+ </tileset>
+ <tileset firstgid="193" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="0">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="6">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="19">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="21">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="24">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="154">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="194">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="207">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="3354">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4227">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4229">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4232">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4492">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4493">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <tileset firstgid="4737" name="clifveg2" tilewidth="32" tileheight="32">
+  <image source="clifveg2.bmp" width="640" height="480"/>
+ </tileset>
+ <tileset firstgid="5037" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="151">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="152">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="153">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="154">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="156">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="194">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <layer name="Tile Layer 1" width="35" height="16">
+  <properties>
+   <property name="blocked" value="false"/>
+  </properties>
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC+2VwQ2AIAxF6wgylRfYzKv7eHIE11FCiIS0yC/15uGHxkD7it/qHZE31kZJlvnqvDkuJXFY8Ug1e1jKPuozrWdoHo6lztfKL+3v6Ul6Xxwjt1qxoP327NP4HPEdx6E5O8Kh8QviW+Se31gOSqpjhAX53lo8sXa442VO0rCgXNLs8AVHcA+Lxt9c7xzXKdSItTNL1DqNzWJkZnI1sk9Kv3wly/9O1E6/OF3Xgm9swAgAAA==
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.0(Current)/NewestVersion/res/map/floor7.tmx b/Version 1.0(Current)/NewestVersion/res/map/floor7.tmx
new file mode 100644
index 0000000..76c0b31
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/res/map/floor7.tmx	
@@ -0,0 +1,188 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="35" height="16" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="tilea2.png" width="512" height="384"/>
+ </tileset>
+ <tileset firstgid="193" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="0">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="6">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="19">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="21">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="24">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="150">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="154">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="194">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="207">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="854">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="925">
+   <properties>
+    <property name="win" value="true"/>
+   </properties>
+  </tile>
+  <tile id="1251">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="3354">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4227">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4229">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4232">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4492">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4493">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <tileset firstgid="4737" name="clifveg2" tilewidth="32" tileheight="32">
+  <image source="clifveg2.bmp" width="640" height="480"/>
+ </tileset>
+ <tileset firstgid="5037" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="6">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="148">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="149">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="151">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="152">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="153">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="154">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="156">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="194">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="925">
+   <properties>
+    <property name="win" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <layer name="Tile Layer 1" width="35" height="16">
+  <properties>
+   <property name="blocked" value="false"/>
+  </properties>
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC/MVYmDwHQJ4GgMCk6N/CStpGJ87cPGPMRCHQeZ7CBKHcbkFW1ggix0jkoa5JZwRYScuNrJbYPbgig/k+IL5e50wbgyzo4tIjO4WfOkC3S0gMULuINYtXuKYcURsOmVnpG24kOImkDtA7kG2m5rpBZsbcLnnGFI8+eHJW+TmI2R3INPYwgg5vWATp6R8wVeWYBPD5VZ0t1ADE8rXxxhQ3UFLtxDCx+gYLsS6hVhxYvFBhlGMDQMAMVG8hcAIAAA=
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.0(Current)/NewestVersion/res/map/secondTestMap.tmx b/Version 1.0(Current)/NewestVersion/res/map/secondTestMap.tmx
new file mode 100644
index 0000000..8681c38
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/res/map/secondTestMap.tmx	
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="35" height="16" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="clifveg2" tilewidth="32" tileheight="32">
+  <image source="clifveg2.bmp" trans="5555ff" width="640" height="480"/>
+ </tileset>
+ <tileset firstgid="301" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="tilea2.png" width="512" height="384"/>
+ </tileset>
+ <tileset firstgid="493" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <layer name="Tile Layer 1" width="35" height="16">
+  <properties>
+   <property name="blocked" value="false"/>
+  </properties>
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC8WUUQoAIQhE21sYdP/77Q32S4hBa6vRPgYqMl+jWEsp1dH7cOXl2dFtlkb0iMGikkMmFosYZ9m9IoY3qxyZLHpv1OtRLOLk7mNYvgiscd9AMw4my2p8FAsK/cDaRc7aEYtVoygG6139/2weR3nxd25k1WbHw5ssp298cFJwwcAIAAA=
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.0(Current)/NewestVersion/res/map/singleTilePassageWay.tmx b/Version 1.0(Current)/NewestVersion/res/map/singleTilePassageWay.tmx
new file mode 100644
index 0000000..0d774b0
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/res/map/singleTilePassageWay.tmx	
@@ -0,0 +1,50 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="35" height="16" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="clifveg2" tilewidth="32" tileheight="32">
+  <image source="../../../../Pictures/SENG 301/Resource Folder/clifveg2.bmp" trans="5555ff" width="640" height="480"/>
+ </tileset>
+ <tileset firstgid="301" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="../../../../Pictures/SENG 301/tilea2.png" width="512" height="384"/>
+ </tileset>
+ <tileset firstgid="493" name="32x32" tilewidth="32" tileheight="32">
+  <image source="../../../../Pictures/SENG 301/Resource Folder/32x32.bmp" width="2048" height="2272"/>
+  <tile id="0">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="24">
+   <properties>
+    <property name="stairs" value="tru"/>
+   </properties>
+  </tile>
+ </tileset>
+ <layer name="Tile Layer 1" width="35" height="16">
+  <properties>
+   <property name="blocked" value="false"/>
+  </properties>
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC+2UUQ5AQAxEi0tU4v638+EGImxSY2fb4o+PSViz25ft1NKJLB/UKLvwGT3oZ943WFo12De2NyOPrcWL69Mhletapid3WLCnCrU1yBHpP+P0PLY+shTmTK9b/FrZ2/KqnO/PSp1aGTbvrHI3Rdl5q+WSeaLz5v0r7rKwHrN3zI9WxPijLCwDyGFnC7NiFZ2X7CzZPHk5idbYNPTxrGdy+UTzr6pW2YhYzcAIAAA=
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.0(Current)/NewestVersion/res/map/testMap..txt b/Version 1.0(Current)/NewestVersion/res/map/testMap..txt
new file mode 100644
index 0000000..627e217
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/res/map/testMap..txt	
@@ -0,0 +1,218 @@
+[header]
+width=100
+height=100
+tilewidth=32
+tileheight=32
+orientation=orthogonal
+
+[tilesets]
+tileset=tilea2.png,32,32,0,0
+
+[layer]
+type=Tile Layer 1
+data=
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,183,183,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,183,183,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
+
+[layer]
+type=Ojects
+data=
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,105,105,105,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,105,105,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,105,0,0,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,105,105,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+
diff --git a/Version 1.0(Current)/NewestVersion/res/map/testMap.tmx b/Version 1.0(Current)/NewestVersion/res/map/testMap.tmx
new file mode 100644
index 0000000..aa072a2
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/res/map/testMap.tmx	
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="20" height="20" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="tilea2.png" width="512" height="384"/>
+  <tile id="2">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <layer name="Tile Layer 1" width="20" height="20">
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC2NmYGBgpiIWoiLGZh4u+4hxAy7z8LEHi3nY/Euuebj0EBN+pMQ7MfLkiFPbPFLCb7CYR2y4E5s/iUlPxGJcaZUS8wiFCynlDyHzSC3TCOnHVU5RuwylR5mMjgHDQcVQQAYAAA==
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.0(Current)/NewestVersion/res/map/tilea2.png b/Version 1.0(Current)/NewestVersion/res/map/tilea2.png
new file mode 100644
index 0000000..1348d5a
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/map/tilea2.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/monster/Rodent0.png b/Version 1.0(Current)/NewestVersion/res/monster/Rodent0.png
new file mode 100644
index 0000000..a50192b
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/monster/Rodent0.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/monster/Thumbs.db b/Version 1.0(Current)/NewestVersion/res/monster/Thumbs.db
new file mode 100644
index 0000000..088a3f9
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/monster/Thumbs.db differ
diff --git a/Version 1.0(Current)/NewestVersion/res/monster/Undead1.png b/Version 1.0(Current)/NewestVersion/res/monster/Undead1.png
new file mode 100644
index 0000000..689d9d3
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/monster/Undead1.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/monster/dead.png b/Version 1.0(Current)/NewestVersion/res/monster/dead.png
new file mode 100644
index 0000000..84309e0
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/monster/dead.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/monster/dummySheet.png b/Version 1.0(Current)/NewestVersion/res/monster/dummySheet.png
new file mode 100644
index 0000000..c4225b3
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/monster/dummySheet.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/player/Thumbs.db b/Version 1.0(Current)/NewestVersion/res/player/Thumbs.db
new file mode 100644
index 0000000..5e03aca
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/player/Thumbs.db differ
diff --git a/Version 1.0(Current)/NewestVersion/res/player/intro1.png b/Version 1.0(Current)/NewestVersion/res/player/intro1.png
new file mode 100644
index 0000000..f6eccba
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/player/intro1.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/player/intro10.png b/Version 1.0(Current)/NewestVersion/res/player/intro10.png
new file mode 100644
index 0000000..adafa81
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/player/intro10.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/player/intro11.png b/Version 1.0(Current)/NewestVersion/res/player/intro11.png
new file mode 100644
index 0000000..dee9071
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/player/intro11.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/player/intro2.png b/Version 1.0(Current)/NewestVersion/res/player/intro2.png
new file mode 100644
index 0000000..bc2ce71
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/player/intro2.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/player/intro3.png b/Version 1.0(Current)/NewestVersion/res/player/intro3.png
new file mode 100644
index 0000000..d3c859a
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/player/intro3.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/player/intro4.png b/Version 1.0(Current)/NewestVersion/res/player/intro4.png
new file mode 100644
index 0000000..fa399f9
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/player/intro4.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/player/intro5.png b/Version 1.0(Current)/NewestVersion/res/player/intro5.png
new file mode 100644
index 0000000..6cf8a79
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/player/intro5.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/player/intro6.png b/Version 1.0(Current)/NewestVersion/res/player/intro6.png
new file mode 100644
index 0000000..adafa81
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/player/intro6.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/player/intro7.png b/Version 1.0(Current)/NewestVersion/res/player/intro7.png
new file mode 100644
index 0000000..f81cec4
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/player/intro7.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/player/intro8.png b/Version 1.0(Current)/NewestVersion/res/player/intro8.png
new file mode 100644
index 0000000..adafa81
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/player/intro8.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/player/intro9.png b/Version 1.0(Current)/NewestVersion/res/player/intro9.png
new file mode 100644
index 0000000..84b18a8
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/player/intro9.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/player/template2.png b/Version 1.0(Current)/NewestVersion/res/player/template2.png
new file mode 100644
index 0000000..fb57bc9
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/player/template2.png differ
diff --git a/Version 1.0(Current)/NewestVersion/res/sound/A Time To Lose.wav b/Version 1.0(Current)/NewestVersion/res/sound/A Time To Lose.wav
new file mode 100644
index 0000000..24a3d44
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/sound/A Time To Lose.wav differ
diff --git a/Version 1.0(Current)/NewestVersion/res/sound/Back To Programming.wav b/Version 1.0(Current)/NewestVersion/res/sound/Back To Programming.wav
new file mode 100644
index 0000000..22b7298
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/sound/Back To Programming.wav differ
diff --git a/Version 1.0(Current)/NewestVersion/res/sound/Bigger And Bigger.wav b/Version 1.0(Current)/NewestVersion/res/sound/Bigger And Bigger.wav
new file mode 100644
index 0000000..15f2cd8
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/sound/Bigger And Bigger.wav differ
diff --git a/Version 1.0(Current)/NewestVersion/res/sound/Catacombs.wav b/Version 1.0(Current)/NewestVersion/res/sound/Catacombs.wav
new file mode 100644
index 0000000..2cf3953
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/sound/Catacombs.wav differ
diff --git a/Version 1.0(Current)/NewestVersion/res/sound/Feelings Are On The Rise.wav b/Version 1.0(Current)/NewestVersion/res/sound/Feelings Are On The Rise.wav
new file mode 100644
index 0000000..db523e6
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/sound/Feelings Are On The Rise.wav differ
diff --git a/Version 1.0(Current)/NewestVersion/res/sound/Flying In The Face Of Hope.wav b/Version 1.0(Current)/NewestVersion/res/sound/Flying In The Face Of Hope.wav
new file mode 100644
index 0000000..641ffdd
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/sound/Flying In The Face Of Hope.wav differ
diff --git a/Version 1.0(Current)/NewestVersion/res/sound/Play At Your Own Risk.wav b/Version 1.0(Current)/NewestVersion/res/sound/Play At Your Own Risk.wav
new file mode 100644
index 0000000..3797137
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/sound/Play At Your Own Risk.wav differ
diff --git a/Version 1.0(Current)/NewestVersion/res/sound/SFX/Level Up Ding.wav b/Version 1.0(Current)/NewestVersion/res/sound/SFX/Level Up Ding.wav
new file mode 100644
index 0000000..763ef14
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/sound/SFX/Level Up Ding.wav differ
diff --git a/Version 1.0(Current)/NewestVersion/res/sound/SFX/Monster Crunch.wav b/Version 1.0(Current)/NewestVersion/res/sound/SFX/Monster Crunch.wav
new file mode 100644
index 0000000..0e6a7b7
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/sound/SFX/Monster Crunch.wav differ
diff --git a/Version 1.0(Current)/NewestVersion/res/sound/SFX/Monster Snarl.wav b/Version 1.0(Current)/NewestVersion/res/sound/SFX/Monster Snarl.wav
new file mode 100644
index 0000000..e5ca8e7
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/sound/SFX/Monster Snarl.wav differ
diff --git a/Version 1.0(Current)/NewestVersion/res/sound/SFX/Player Grunt.wav b/Version 1.0(Current)/NewestVersion/res/sound/SFX/Player Grunt.wav
new file mode 100644
index 0000000..92a2efa
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/sound/SFX/Player Grunt.wav differ
diff --git a/Version 1.0(Current)/NewestVersion/res/sound/SFX/Player Oof.wav b/Version 1.0(Current)/NewestVersion/res/sound/SFX/Player Oof.wav
new file mode 100644
index 0000000..d2855f1
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/sound/SFX/Player Oof.wav differ
diff --git a/Version 1.0(Current)/NewestVersion/res/sound/SFX/Potential Monster Die.wav b/Version 1.0(Current)/NewestVersion/res/sound/SFX/Potential Monster Die.wav
new file mode 100644
index 0000000..1b76881
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/sound/SFX/Potential Monster Die.wav differ
diff --git a/Version 1.0(Current)/NewestVersion/res/sound/SFX/Swoosh.wav b/Version 1.0(Current)/NewestVersion/res/sound/SFX/Swoosh.wav
new file mode 100644
index 0000000..e09b1e8
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/sound/SFX/Swoosh.wav differ
diff --git a/Version 1.0(Current)/NewestVersion/res/sound/SFX/Sword Swing.wav b/Version 1.0(Current)/NewestVersion/res/sound/SFX/Sword Swing.wav
new file mode 100644
index 0000000..88fc625
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/sound/SFX/Sword Swing.wav differ
diff --git a/Version 1.0(Current)/NewestVersion/res/sound/Tank Battle.wav b/Version 1.0(Current)/NewestVersion/res/sound/Tank Battle.wav
new file mode 100644
index 0000000..6cc4c51
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/sound/Tank Battle.wav differ
diff --git a/Version 1.0(Current)/NewestVersion/res/sound/The Hero Of The Darkness.wav b/Version 1.0(Current)/NewestVersion/res/sound/The Hero Of The Darkness.wav
new file mode 100644
index 0000000..8a30489
Binary files /dev/null and b/Version 1.0(Current)/NewestVersion/res/sound/The Hero Of The Darkness.wav differ
diff --git a/Version 1.0(Current)/NewestVersion/src/gameStates/GameOverScreen.java b/Version 1.0(Current)/NewestVersion/src/gameStates/GameOverScreen.java
new file mode 100644
index 0000000..c873f83
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/gameStates/GameOverScreen.java	
@@ -0,0 +1,111 @@
+package gameStates;
+
+import inputRelated.EndGameButtons;
+
+import java.awt.Font;
+import java.io.File;
+
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.Input;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.TrueTypeFont;
+import org.newdawn.slick.state.BasicGameState;
+import org.newdawn.slick.state.StateBasedGame;
+
+
+///////////////////////////////////////////////////
+//GameOver										 //							
+//Purpose: Controls the game over state. 		 //
+//This occurs when the player character has died //
+//Limit: Current does not restart game	         //
+///////////////////////////////////////////////////
+
+public class GameOverScreen extends BasicGameState{
+	
+	//Game Over Screen Font
+	private TrueTypeFont font;
+	
+	//Game Over State
+	public static int ID = 3;
+	
+	//Game container is used to shut down program
+	private GameContainer gc;
+	
+	private Image skull;
+	private EndGameButtons buttons;
+	
+	//Initialize Game Over State
+	//Runs at the beginning of the program
+	@Override
+	public void init(GameContainer gc, StateBasedGame sbg)
+			throws SlickException {
+	    // load a default java font
+		this.gc = gc;
+	    Font awtFont = new Font("Times New Roman", Font.BOLD, 50);
+	    font = new TrueTypeFont(awtFont, false);
+	    skull = new Image ("res/interface/skull.png");
+	    buttons = new EndGameButtons(gc, sbg, GameOverScreen.ID);
+	}
+	
+	//Method runs every time this state is entered
+	@Override
+	public void enter(GameContainer gc, StateBasedGame sbg){
+		//Delete saved games when player loses
+		try{
+			 
+    		File file = new File("save.txt");
+ 
+    		if(file.delete()){
+    			System.out.println(file.getName() + " is deleted!");
+    		}else{
+    			System.out.println("Delete operation is failed.");
+    		}
+    	}catch(Exception e){
+ 
+    		e.printStackTrace();
+    	}
+		//Reset loadedGame/Win values
+		GameScreen.setWin(false);
+		GameScreen.setLoadedGame(false);
+		}
+
+	
+	// Displays the game over screen
+	@Override
+	public void render(GameContainer gc, StateBasedGame sbg, Graphics g)
+			throws SlickException {
+		skull.draw(330, 100);
+		font.drawString(360, 60, "GAME OVER!", Color.red);
+		buttons.render(gc, g);
+	}
+
+
+	// Updates the state of the game (the player is now dead)
+	// No images should appear
+	@Override
+	public void update(GameContainer gc, StateBasedGame sbg, int delta)
+			throws SlickException {
+		
+	}
+	
+	// Controls key input in the game over screen
+	@Override
+	public void keyReleased (int key,char c){
+	switch (key){
+	case Input.KEY_Q:
+		gc.exit();//Exits game. 	
+		break;
+		}	
+	}
+
+	//Returns ID of state for state manager that controls
+	//Flow of game
+	@Override
+	public int getID() {
+		return ID;
+	}
+
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/gameStates/GameScreen.java b/Version 1.0(Current)/NewestVersion/src/gameStates/GameScreen.java
new file mode 100644
index 0000000..40e6f10
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/gameStates/GameScreen.java	
@@ -0,0 +1,290 @@
+package gameStates;
+
+import inputRelated.LoadingGame;
+import inputRelated.SavingGame;
+
+import java.util.LinkedList;
+
+import managers.CombatManager;
+import managers.MonsterManager;
+import managers.SoundManager;
+import mapRelated.BasicMap;
+import monsterRelated.Entity;
+
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Input;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.openal.SoundStore;
+import org.newdawn.slick.state.BasicGameState;
+import org.newdawn.slick.state.StateBasedGame;
+import org.newdawn.slick.state.transition.FadeInTransition;
+import org.newdawn.slick.state.transition.FadeOutTransition;
+
+import playerRelated.Player;
+
+//////////////////////////////////////////////
+//Game										//
+//Purpose: Controls all elements in the game//
+//Limit: Works only in SLICK2D API		    //
+//////////////////////////////////////////////
+
+public class GameScreen extends BasicGameState {
+
+	//Used for quitting the game
+	private GameContainer gc;
+	private GameScreenAssets gameAssets;
+	private StateBasedGame sbg;
+	
+	//Entity Stuff
+	private Player player;
+	private String[][] entityArray;
+	
+	//Handles Monsters on screen
+	private MonsterManager monsters;
+	private BasicMap currentMap;
+	
+	//Counter for delaying Text-log and monsters
+	private int textLogCounter = 0;
+	private int monsterCounter = 0; //Must combine later
+
+	//Maps Used Inside Game
+	private BasicMap floorOne;
+	private BasicMap floorTwo;
+	private BasicMap floorThree;
+	private BasicMap floorFour;
+	private BasicMap floorFive;
+	private BasicMap floorSix;
+	private BasicMap floorSeven;
+
+	//Sound Volume
+	private float volume = 1.0f;
+	
+	//Collection of maps for all levels
+	private LinkedList<BasicMap> totalLevels = new LinkedList<BasicMap>();
+	
+	
+	//State ID
+	public static final int ID = 1;
+
+	//Win Game Boolean
+	private static boolean winGame = false;
+	
+	//Loaded Saved Game Boolean
+	private static boolean loadedGame = false;	
+	
+	//Set by the LoadingGame class
+	//Also used by GameOver class
+	public static void setLoadedGame(boolean value){loadedGame =value;}
+	public static void setWin(boolean value) {winGame = value;}
+	
+	//Initialize variables that aren't reliant on it being a new game or an old game
+	@Override
+	public void init(GameContainer gc, StateBasedGame stateGame) throws SlickException {
+		this.gc = gc;
+		this.sbg = stateGame;
+
+		//Load ALL  Maps of game
+		floorOne = new BasicMap("res/map/floor1.tmx");
+		floorTwo = new BasicMap("res/map/floor2.tmx");
+		floorThree = new BasicMap("res/map/floor3.tmx");
+		floorFour = new BasicMap("res/map/floor4.tmx");
+		floorFive = new BasicMap("res/map/floor5.tmx");
+		floorSix = new BasicMap("res/map/floor6.tmx");
+		floorSeven = new BasicMap("res/map/floor7.tmx");
+	
+		//Needed to init totalLevels for usage in loading games
+		totalLevels.add(floorSeven);
+		totalLevels.add(floorSix);
+		totalLevels.add(floorFive);
+        totalLevels.add(floorFour);
+		totalLevels.add(floorThree);
+		totalLevels.add(floorTwo);
+		totalLevels.add(floorOne);
+	}
+	
+	//This method is run when we enter the state not at the start of the program like the init method
+	@Override 
+	public void enter(GameContainer gc, StateBasedGame stateGame) throws SlickException{
+		this.gc = gc;
+		//If new game (from a previously lost game) then clear the totalLevels
+		totalLevels.clear();
+		
+		//Add floors to Linked List, last level first.
+		totalLevels.add(floorSeven);
+		totalLevels.add(floorSix);
+		totalLevels.add(floorFive);
+        totalLevels.add(floorFour);
+		totalLevels.add(floorThree);
+		totalLevels.add(floorTwo);
+		totalLevels.add(floorOne);
+		
+		//Get current map from the end.
+		currentMap = totalLevels.removeLast();
+		
+		
+		//Create player's character 
+		player = new Player(gc, stateGame,currentMap, 4*32, 5*32);
+		
+		//Place player's character onto map
+		initEntityArray();
+		if (!loadedGame)
+			{
+			entityArray[((Entity)player).getPosition()[0]/32][((Entity)player).getPosition()[1]/32] = player.getName();
+			}
+		//Update Monster Manager with currentMap
+		monsters = new MonsterManager(currentMap);
+		//Spawn Monsters
+		monsters.init(entityArray, currentMap);
+		//Set Combat manager
+		CombatManager.setMonsterList(monsters.getMonsterList());
+		gameAssets = new GameScreenAssets();
+		//Re-writes initialization defaults with read information from saved file
+		if (loadedGame)
+		{
+			initEntityArray();
+			currentMap = LoadingGame.initLoadingGame(gameAssets, currentMap, totalLevels, player, monsters, entityArray);
+			if (gameAssets.getFloorLevel() == 1){
+				SoundManager.changeSound("res/sound/Catacombs.wav");
+				}
+			else{
+				SoundManager.changeSound("res/sound/Tank Battle.wav");
+				}
+		}
+        //Initializes the Menu
+		gameAssets.initMenu(gc, stateGame, ID);
+		
+		//Initializes the player's entity Array
+		//Which is important for detecting monsters
+		player.setEntityArray(monsters.getEntityArray());
+		}
+	
+	
+	
+	
+	
+	
+	// Initializes the entity array, this will hold the information 
+	// about the objects in the game (such as the player)
+	private void initEntityArray (){
+		String [][] newArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		entityArray = newArray;
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				entityArray[i][c] = " ";
+			}
+		}
+	}
+	
+	
+	// Draws the display of the game
+	@Override
+	public void render(GameContainer gc, StateBasedGame stateGame, Graphics g)
+			throws SlickException {
+		
+		//Render Map, Monsters, Player, GameScreen Assets
+		currentMap.render();
+		monsters.render(g);
+		player.render(g);
+		gameAssets.render(g, player);
+	}
+	
+	
+	// Manages the keyboard controls of the game
+	@Override
+	public void keyReleased (int key,char c){
+		switch (key){
+		case Input.KEY_Q:
+			SavingGame.SaveGame(gameAssets, player, monsters);
+			gc.exit();//Exits game. 	
+			break;
+		case Input.KEY_M: 
+		case Input.KEY_ESCAPE:
+			//Slide Out Menu Hot Key Controls
+			if (gameAssets.menu.getMenuOpen() == true)
+				gameAssets.getMenu().popIn();
+			else
+				gameAssets.getMenu().popOut();
+			break;
+		//Decrease volume
+		case Input.KEY_A:
+			volume -= 0.1f;
+			if (volume < 0.0f)
+				volume = 0.0f;
+			SoundStore.get().setSoundVolume(volume);
+			SoundStore.get().setMusicVolume(volume);
+			break;
+		
+		//Increase volume
+		case Input.KEY_S:
+			volume += 0.1f;
+			if (volume > 1.0f)	
+				volume = 1.0f;
+			SoundStore.get().setSoundVolume(volume);
+			SoundStore.get().setMusicVolume(volume);
+		}
+	}
+
+	
+	// Updates the state of the game (player location, combat, monster movement etc..)
+	@Override
+	public void update(GameContainer gc, StateBasedGame stateGame, int delta)
+			throws SlickException {
+		textLogCounter = gameAssets.updateTextLog(textLogCounter);
+
+		if (!player.getAlive())
+		{
+			GameScreenAssets.queueTextLog.add( "Your player be dead");
+			//Change Sound to Game Over State's sound
+			SoundManager.changeSound("res/sound/A Time To Lose.wav");
+			//Change state of game to game over state.
+			stateGame.enterState(GameOverScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));
+		}
+		
+		//Always let the player move.
+		player.update(monsterCounter);
+		
+		
+		//Update monster movement
+		if (monsters.getMonsterList()!= null){
+			monsters.update(player.getPosition(), monsterCounter);
+			monsterCounter++;
+			if (monsterCounter > 400)//Used to delay the monster's movement
+				monsterCounter = 0;
+			}
+		
+		//Load a new floor if the stairs are stepped on.
+		if (player.getOnStairs()&&totalLevels.peekLast()!= null){
+			currentMap = totalLevels.removeLast();
+			player.setMap(currentMap);
+			monsters.clearMonsters();
+			monsters.increaseFloorLevel();
+			monsters.init(entityArray, currentMap);		
+			CombatManager.setMonsterList(monsters.getMonsterList());
+			player.setEntityArray(monsters.getEntityArray());
+			gameAssets.increaseFloorLevel();
+			SoundManager.changeSound("res/sound/Tank Battle.wav");
+			player.setOnStairs(false);
+			}
+		
+		//Note to self this needs testing.	
+		 if (winGame)
+			{
+			sbg.enterState(WinScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));
+			}
+		}
+	
+	
+	
+
+	//Returns ID of state for state manager that controls
+	//Flow of game
+	@Override
+	public int getID() {
+		return ID;
+	}
+
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/gameStates/GameScreenAssets.java b/Version 1.0(Current)/NewestVersion/src/gameStates/GameScreenAssets.java
new file mode 100644
index 0000000..0dd5e0f
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/gameStates/GameScreenAssets.java	
@@ -0,0 +1,137 @@
+package gameStates;
+
+import inputRelated.ButtonAction;
+import inputRelated.SlideOutMenu;// WILL USE!!! 
+
+import java.util.LinkedList;
+
+import managers.SoundManager;
+
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.fills.GradientFill;
+import org.newdawn.slick.geom.Rectangle;
+import org.newdawn.slick.state.StateBasedGame;
+
+import playerRelated.Player;
+
+////////////////////////////////////////////////////
+//GameScreenAssets								  //
+//Purpose: Controls the various elements in the UI//
+//Limit: Textlog has unified source of updates	  //
+////////////////////////////////////////////////////
+
+public class GameScreenAssets {
+
+	//Floor Variables
+	private int floorLevel = 1;
+	
+	//Menu object
+	SlideOutMenu menu;
+	GameContainer gc;
+	//TextLog Variables
+	private String statusBackLog2;
+	private String statusBackLog1;
+	private String statusUpdate;
+	
+	//Linked lists for keeping track of the game's state.
+	public static LinkedList <String> queueTextLog = new LinkedList<String>();
+	
+	public void increaseFloorLevel(){ floorLevel++;}
+	
+	public int getFloorLevel(){return floorLevel;}
+	public void setFloorLevel(int newFloorLevel){floorLevel = newFloorLevel;} 
+
+
+	public void initMenu(GameContainer gc, StateBasedGame stateGame, int ID) throws SlickException{
+		  this.gc = gc;
+		  queueTextLog.clear();
+		  statusBackLog2 = " ";
+		  statusBackLog1 = " ";
+		  statusUpdate = "Game is Now In Session";
+	      menu = new SlideOutMenu(gc, stateGame, ID, new Image ("res/interface/menu2.png"), 1065, 50 );
+	        menu.add(new ButtonAction(){ 
+	    		public void perform(){
+	    		//SoundManager.changeSound("res/sound/Play At Your Own Risk.wav");//I warned you. Not even sorry.	
+	    		SoundManager.playSoundEffect("res/sound/SFX/Sword Swing.wav");
+	    		}
+	    		});
+	}
+	
+	
+	public SlideOutMenu getMenu(){return menu;}
+	
+	
+	
+	// Draws the UI elements
+	public void render(Graphics g, Player player){
+		
+		//Render Text Log + Floor Status
+		g.setColor(Color.white);
+		g.drawString("Floor: "+floorLevel, 1000, 20);
+	    g.drawString(statusUpdate, 600, 490);
+	    g.drawString(statusBackLog1, 600, 470);
+	    g.drawString(statusBackLog2, 600, 450);
+
+	    //Draw Player Level
+	    g.setColor(Color.yellow);
+	    g.drawString("Lvl: "+player.getCurrentLevel(),10, 450);
+	    
+	    g.setColor(Color.white);
+	    ///Draw Health Bar
+	    g.drawString("HP", 80, 450);
+	    g.drawString(""+player.getHealthPoints()+"/"+player.getMaxHealthPoints(), 420, 450);
+	    Rectangle healthBar = new Rectangle(110, 450, 300 * player.getHealthPoints() / player.getMaxHealthPoints(), 20);
+        GradientFill fillRed = new GradientFill(110, 0, new Color(255, 0, 0),
+                                             460 + 300, 0, new Color(220,60, 0));
+
+        g.setColor(Color.darkGray);
+        g.fillRect(110, 450, 300, 20);
+        g.fill(healthBar, fillRed); 
+        
+        
+        //Draw Experience Bar
+        g.setColor(Color.white);
+	    g.drawString("EXP", 80, 480);
+	    g.drawString(""+player.getExperiencePoints()+"/"+player.getPointsNextLevel(), 420, 480);
+	    Rectangle expBar = new Rectangle(110, 480, 300*player.getExperiencePoints()/player.getPointsNextLevel(), 20);
+        GradientFill fillGreen = new GradientFill(110, 0, new Color(90, 255, 20),
+                                             480 + 300, 0, new Color(40, 180, 40));
+        g.setColor(Color.darkGray);
+        g.fillRect(110, 480, 300, 20);
+        g.fill(expBar, fillGreen); 
+        
+        //Render menu
+        menu.render(gc, g);
+		
+	}
+	
+	
+	public void clearTextLog(){
+		while (!queueTextLog.isEmpty())
+			queueTextLog.pop();
+	}
+	
+	// Scrolls the text log to display more recent information
+	public int updateTextLog(int textLogCounter){
+		if (textLogCounter < 0)
+			return 0;
+		
+		if (textLogCounter > 200){
+			String temp = queueTextLog.pollLast();
+			if (temp!= null){
+				statusBackLog2 = statusBackLog1;
+				statusBackLog1 = statusUpdate;
+				statusUpdate = ""+temp;
+			}	
+			return 0;
+		}
+		else
+			return ++textLogCounter;
+	}
+	
+	
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/gameStates/MainMenuScreen.java b/Version 1.0(Current)/NewestVersion/src/gameStates/MainMenuScreen.java
new file mode 100644
index 0000000..c21c0a6
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/gameStates/MainMenuScreen.java	
@@ -0,0 +1,75 @@
+package gameStates;
+
+import inputRelated.MainMenuButtons;
+
+import managers.SoundManager;
+
+import org.newdawn.slick.Animation;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.state.BasicGameState;
+import org.newdawn.slick.state.StateBasedGame;
+
+//////////////////////////////////////////////////////////////////////
+//Menu														        //
+//Purpose: Loads the main menu screen when the game is first started//
+//Limit: Current Continue button remains inactive			        //
+//////////////////////////////////////////////////////////////////////
+
+public class MainMenuScreen extends BasicGameState {
+
+	
+	public static final int ID = 0; //Set the state's I.D 
+	
+	//Variables used for UI elements
+	private MainMenuButtons menuButtons;
+	private Animation menuAnimation;
+	
+	
+	// Initializes the menu
+	@Override
+	public void init(GameContainer gc, StateBasedGame stateGame)
+			throws SlickException {
+		
+		//Initializes menu buttons
+		menuButtons = new MainMenuButtons(gc,stateGame);
+	
+		//Initializes Menu's Animation
+		Image [] menuImages = {new Image ("res/interface/design2.png"), new Image ("res/interface/design2slide2.png")}; 
+		int [] duration = {300,300};
+		menuAnimation = new Animation (menuImages, duration, false);
+		
+		//Plays games music
+		SoundManager.changeSound("res/sound/Flying In The Face Of Hope.wav");
+	    
+		
+	}
+	
+	
+	// Draws the menu screen
+	@Override
+	public void render(GameContainer gc, StateBasedGame stateGame, Graphics g)
+			throws SlickException {
+		gc.setShowFPS(false); //FPS counter is hidden		
+		menuAnimation.draw(300,50);
+	    menuButtons.render(gc,g);//Renders the menu buttons
+	}
+
+	// Updates the menu's animation
+	@Override
+	public void update(GameContainer gc, StateBasedGame stateGame, int delta)
+			throws SlickException {
+			menuAnimation.update(delta);
+			
+	}
+	
+	//Returns ID of state for state manager that controls
+    //Flow of game
+	@Override
+	public int getID() {
+		return ID;
+	}
+
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/gameStates/StateManager.java b/Version 1.0(Current)/NewestVersion/src/gameStates/StateManager.java
new file mode 100644
index 0000000..8ff5069
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/gameStates/StateManager.java	
@@ -0,0 +1,29 @@
+package gameStates;
+
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.state.StateBasedGame;
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+//StateManager																					   //
+//Purpose: This class manages the flow of the game through its states							   //
+//Limit: Works only with SLICK2D API    														   //
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+
+public class StateManager extends StateBasedGame {
+
+		public StateManager(String name) {
+		super(name);
+	}
+		
+	// A list of states instantiated to be used by the game
+	@Override
+	public void initStatesList(GameContainer gc) throws SlickException {
+		addState(new MainMenuScreen());
+		addState(new TransitionScreen());
+		addState(new GameScreen());
+		addState(new GameOverScreen());
+		addState(new WinScreen());
+	}
+
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/gameStates/TransitionScreen.java b/Version 1.0(Current)/NewestVersion/src/gameStates/TransitionScreen.java
new file mode 100644
index 0000000..ee59029
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/gameStates/TransitionScreen.java	
@@ -0,0 +1,102 @@
+package gameStates;
+
+import org.newdawn.slick.Animation;
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.Input;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.state.BasicGameState;
+import org.newdawn.slick.state.StateBasedGame;
+import org.newdawn.slick.state.transition.FadeInTransition;
+import org.newdawn.slick.state.transition.FadeOutTransition;
+
+public class TransitionScreen extends BasicGameState {
+	//State's ID
+	public static final int ID = 4;
+	
+	//Used to enter other states
+	private StateBasedGame sbg;
+	
+	//Different Images and Variables Used For Intro
+	private Image controlImage;
+	private Image explanationImage;
+	private Animation animationIntro;
+	private Image panicImage;
+	private int slide = 0;
+	
+	
+	//Initializes Transition Screen for Intro
+	@Override
+	public void init(GameContainer gc, StateBasedGame sbg)
+			throws SlickException {
+		this.sbg = sbg;
+		Image [] animationImages = {new Image ("res/player/intro1.png"),
+									new Image ("res/player/intro2.png"),
+									new Image ("res/player/intro3.png"),
+									new Image ("res/player/intro4.png"),
+									new Image ("res/player/intro5.png"),
+									new Image ("res/player/intro6.png"),
+									new Image ("res/player/intro7.png"),
+									new Image ("res/player/intro8.png"),
+									new Image ("res/player/intro9.png"),
+									new Image ("res/player/intro10.png"),
+									new Image ("res/player/intro11.png")};
+		int [] duration = {100,100,100,100,100,100,100,100,100,100,100000};
+		animationIntro = new Animation (animationImages, duration, false);
+		controlImage = new Image("res/interface/controls.png"); 
+		panicImage = new Image("res/interface/panicSlide.png");
+		explanationImage = new Image("res/interface/explanation.png");
+	}
+	
+
+	//Draws Transition Screen based on Player Input
+	@Override
+	public void render(GameContainer arg0, StateBasedGame sbg, Graphics g)
+			throws SlickException {
+		animationIntro.draw(0,0);
+		if (slide == 1)
+			panicImage.draw(0,0);
+		if (slide == 2)
+			explanationImage.draw(0,0);
+		if (slide >=3)
+			controlImage.draw(0,0);
+	}
+	
+	//Controls Keyboard Input
+	@Override
+	public void keyReleased (int key,char c){
+		switch (key){		
+		
+		case Input.KEY_T:
+			sbg.enterState(WinScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));	
+			break;
+		case Input.KEY_W:
+			sbg.enterState(GameScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));	
+			break;
+		default:
+			if (slide >=4)
+				sbg.enterState(GameScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));	
+			else
+				slide++;
+		}
+	}
+
+	
+	//Updates Animation on Transition Screen
+	@Override
+	public void update(GameContainer gc, StateBasedGame sbg, int delta)
+			throws SlickException {
+		animationIntro.update(delta);
+	}
+
+	
+	//Returns ID of state for state manager that controls
+	//Flow of game
+	@Override
+	public int getID() {
+		return ID;
+	}
+
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/gameStates/Ver2GameDriver.java b/Version 1.0(Current)/NewestVersion/src/gameStates/Ver2GameDriver.java
new file mode 100644
index 0000000..6ed2937
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/gameStates/Ver2GameDriver.java	
@@ -0,0 +1,31 @@
+package gameStates;
+
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import org.newdawn.slick.AppGameContainer;
+import org.newdawn.slick.SlickException;
+
+//Driver Used to run the game
+//Contains Main Method
+public class Ver2GameDriver {	
+
+	public static void main (String [] args){
+		
+		//All the code below is how we get this game rolling and running.
+		
+		int screenWidth = 1120; // Set screen width to 35 tiles long (35*32px)
+		int screenHeight = 512; // Set screen height to 16 tile long (16*32px)
+		
+			try
+			{
+				AppGameContainer appgc;
+				appgc = new AppGameContainer(new StateManager("Basic Game Template"),screenWidth,screenHeight,false);
+				appgc.start();
+			}
+			catch (SlickException ex)
+			{
+				Logger.getLogger(StateManager.class.getName()).log(Level.SEVERE, null, ex);
+			}
+	}
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/gameStates/WinScreen.java b/Version 1.0(Current)/NewestVersion/src/gameStates/WinScreen.java
new file mode 100644
index 0000000..228081b
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/gameStates/WinScreen.java	
@@ -0,0 +1,83 @@
+package gameStates;
+
+import inputRelated.EndGameButtons;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Random;
+
+import managers.SoundManager;
+
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Input;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.state.BasicGameState;
+import org.newdawn.slick.state.StateBasedGame;
+
+public class WinScreen extends BasicGameState{
+
+	public static final int ID = 5;
+	private EndGameButtons buttons;
+	
+	private GameContainer gc;
+	@Override
+	public void enter (GameContainer gc, StateBasedGame sbg){
+		SoundManager.changeSound("res/sound/Back To Programming.wav");
+		GameScreen.setWin(false);//Reset win boolean for future new games
+		try{
+			 
+    		File file = new File("save.txt");
+ 
+    		if(file.delete()){
+    			System.out.println(file.getName() + " is deleted!");
+    		}else{
+    			System.out.println("Delete operation is failed.");
+    		}
+    	}catch(Exception e){
+ 
+    		e.printStackTrace();
+    	}
+		//Reset loadedGame/Win values
+		GameScreen.setWin(false);
+		GameScreen.setLoadedGame(false);
+	}
+	
+	@Override
+	public void init(GameContainer gc, StateBasedGame sbg)
+			throws SlickException {
+			this.gc = gc;
+		    buttons = new EndGameButtons(gc, sbg, WinScreen.ID);
+	}
+
+	@Override
+	public void render(GameContainer gc, StateBasedGame sbg, Graphics g)
+			throws SlickException {
+		g.setColor(Color.white);
+		g.drawString("YOU WON!!!", 480,200);
+		buttons.render(gc, g);
+	}
+
+	@Override
+	public void update(GameContainer gc, StateBasedGame sbg, int delta)
+			throws SlickException {
+		
+	}
+	
+	// Manages the keyboard controls of the game
+		@Override
+		public void keyReleased (int key,char c){
+			switch (key){
+			case Input.KEY_Q:
+				gc.exit();//Exits game. 	
+				break;
+			}
+		}
+
+	@Override
+	public int getID() {
+		return ID;
+	}
+
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/inputRelated/BasicButton.java b/Version 1.0(Current)/NewestVersion/src/inputRelated/BasicButton.java
new file mode 100644
index 0000000..da8bb31
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/inputRelated/BasicButton.java	
@@ -0,0 +1,117 @@
+package inputRelated;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.newdawn.slick.Color;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.gui.GUIContext;
+import org.newdawn.slick.gui.MouseOverArea;
+import org.newdawn.slick.state.StateBasedGame;
+
+//////////////////////////////////////////////////////////////////////////////////////////
+//BASIC BUTTON TEMPLATE				      												//
+//Purpose: Creates Button Template        												//			
+//Limits: Relies on SLICK2D API           												//
+//Author: Deque							  												//
+//Source :https://evilzone.org/java/%28java-fames-tut%29-slick2d-buttons-buttons-buttons//
+//////////////////////////////////////////////////////////////////////////////////////////
+
+public class BasicButton extends MouseOverArea {
+
+	 //Variables for Button Functionality
+	 private boolean activated = false;
+	 private boolean unclickable = false;
+	 private boolean lastMouseOver = false;
+
+	 //Variables for Image of Button
+	 private Image inactiveButton;
+	 private Image activeButton;
+	 
+	 //Variables to reference gameScreen where its used
+     private final StateBasedGame sbg;
+     private final int stateID;
+
+     //Used for holding button press actions
+     private final List <ButtonAction> actions = new ArrayList <ButtonAction>();
+ 	
+     //Initializes Button
+     public BasicButton(GUIContext container, int x, int y,
+			StateBasedGame sbg, int stateID, Image inactiveButton, Image activeButton) throws SlickException {
+		 	super(container, activeButton, x, y);
+	        super.setMouseDownColor(Color.white);
+	        super.setMouseOverColor(Color.yellow);
+	        super.setMouseOverImage(activeButton);
+	        this.sbg = sbg;
+	        this.stateID = stateID;
+	 
+	        this.inactiveButton = inactiveButton;
+	        this.activeButton = activeButton;
+	}
+     
+    //Method to add actions to a button to perform
+	public void add(ButtonAction action){
+		actions.add(action);
+	}
+	
+	//Disables button
+	public void setUnClickable(boolean unclickable){
+			this.unclickable = unclickable;
+	}
+	
+	
+	//Method used to tell when the mouse is hovering over the button
+	@Override
+    public void mouseMoved(int oldx, int oldy, int newx, int newy) {
+	        if (sbg.getCurrentStateID() == stateID) {
+	            if (isMouseOver() && !lastMouseOver && !isActivated()) {
+	                lastMouseOver = true;
+	            } else if (!isMouseOver()) {
+	                lastMouseOver = false;
+	            }
+	        }
+	        super.mouseMoved(oldx, oldy, newx, newy);
+	    }
+
+	
+	//Renders button image depending on its activation
+	@Override
+    public void render(GUIContext guic, Graphics g) {
+	        if (isActivated()&&!unclickable) {
+	            g.drawImage(activeButton, getX(), getY());
+	            activated = false;
+	        }
+	        super.render(guic, g);
+		    if (unclickable)
+		    {
+		    	g.drawImage(inactiveButton, getX(), getY());
+		    }
+	    }
+	 
+	//Checks if button is activated
+	public boolean isActivated() {return activated;}
+	 
+	//Sets the button activated or not.
+    protected void setActivated(boolean b) {activated = b;}
+	    
+	    
+	//Method that gets button to perform its action when pressed
+	@Override
+	public void mousePressed(int button, int x, int y) {
+	    if (isMouseOver() && sbg.getCurrentStateID() == stateID) {
+	         activated = !activated;
+	         for (ButtonAction action: actions){
+	          	action.perform();
+	            }
+	        }
+	        super.mousePressed(button, x, y);
+	    }
+	
+	//Gets the list of actions for the button
+    public List <ButtonAction>getActions(){return actions;}
+}
+	
+	
+
diff --git a/Version 1.0(Current)/NewestVersion/src/inputRelated/ButtonAction.java b/Version 1.0(Current)/NewestVersion/src/inputRelated/ButtonAction.java
new file mode 100644
index 0000000..0083640
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/inputRelated/ButtonAction.java	
@@ -0,0 +1,9 @@
+package inputRelated;
+
+
+//Source :https://evilzone.org/java/%28java-fames-tut%29-slick2d-buttons-buttons-buttons/
+public interface ButtonAction {
+	public void perform();
+
+
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/inputRelated/ButtonListener.java b/Version 1.0(Current)/NewestVersion/src/inputRelated/ButtonListener.java
new file mode 100644
index 0000000..418a0c0
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/inputRelated/ButtonListener.java	
@@ -0,0 +1,22 @@
+package inputRelated;
+
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+
+public class ButtonListener implements ActionListener{
+
+	@Override
+	public void actionPerformed(ActionEvent e) {
+		if ("Start Game".equals(e.getActionCommand())){
+			
+		}
+		
+		else if ("Load Game".equals(e.getActionCommand())){
+			
+		}
+		
+		
+	}
+
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/inputRelated/EndGameButtons.java b/Version 1.0(Current)/NewestVersion/src/inputRelated/EndGameButtons.java
new file mode 100644
index 0000000..c986d57
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/inputRelated/EndGameButtons.java	
@@ -0,0 +1,75 @@
+package inputRelated;
+
+import gameStates.GameOverScreen;
+import gameStates.GameScreen;
+import managers.SoundManager;
+
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.state.StateBasedGame;
+import org.newdawn.slick.state.transition.FadeInTransition;
+import org.newdawn.slick.state.transition.FadeOutTransition;
+
+public class EndGameButtons {
+
+	//Button Variables
+	private BasicButton quitGameButton;
+	private BasicButton newGameButton;
+	
+	
+	//Used to for the actions of the buttons
+	private StateBasedGame sbg;
+	private GameContainer gc;
+	
+	
+	public EndGameButtons (GameContainer container, StateBasedGame stateGame, int stateID) throws SlickException{
+		
+		sbg = stateGame;
+		this.gc = container;
+		
+		
+		//Get the images of the buttons in their inactive/active states
+		Image activeNewGame = new Image("res/interface/newGame.png");
+		Image mouseOverNewGame = new Image("res/interface/newGameMouseOver.png");
+		Image activeQuitGame = new Image ("res/interface/exitGame.png");
+		Image mouseOverQuitGame = new Image("res/interface/exitGameMouseOver.png");
+		
+		newGameButton = new BasicButton(gc, 330, 350, 
+			    stateGame, stateID, activeNewGame, activeNewGame);
+		quitGameButton = new BasicButton(gc, 540, 350, 
+				stateGame,  stateID, activeQuitGame, activeQuitGame);
+		
+		newGameButton.setMouseOverImage(mouseOverNewGame);
+		 
+		quitGameButton.setMouseDownImage(mouseOverQuitGame);
+		quitGameButton.setMouseOverImage(mouseOverQuitGame);
+		
+		//Creates an anon class for the button's action.
+		newGameButton.add(new ButtonAction(){ 
+			public void perform(){
+			sbg.enterState(GameScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));	
+			SoundManager.changeSound("res/sound/Catacombs.wav");
+			}
+			});
+		
+		//Creates an anon class for the button's action.
+		quitGameButton.add(new ButtonAction(){ 
+			public void perform(){
+				//Delete game/Over write old game here
+				((GameContainer)gc).exit();	
+			}
+		});
+		
+		}
+	
+	
+	
+	public void render(GameContainer gc, Graphics g){
+		 newGameButton.render(gc, g);//Draw the buttons on screen.
+		 quitGameButton.render(gc,g);
+	}
+	
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/inputRelated/LoadingGame.java b/Version 1.0(Current)/NewestVersion/src/inputRelated/LoadingGame.java
new file mode 100644
index 0000000..8112c08
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/inputRelated/LoadingGame.java	
@@ -0,0 +1,113 @@
+package inputRelated;
+
+import gameStates.GameScreenAssets;
+
+import java.io.BufferedReader;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.LinkedList;
+
+import managers.CombatManager;
+import managers.MonsterManager;
+import mapRelated.BasicMap;
+import monsterRelated.Entity;
+
+import org.newdawn.slick.SlickException;
+
+import playerRelated.Player;
+
+public class LoadingGame {
+	
+	
+	
+	
+	public static BasicMap initLoadingGame(GameScreenAssets gameAssets, BasicMap changeMap, LinkedList<BasicMap> xTotalLevels,
+			   Player player, MonsterManager monsters, String[][] entityArray)
+			   throws SlickException
+	{	
+
+		int readFloor = 0;
+		int readPlayerPositionX = 0;
+		int readPlayerPositionY = 0;
+		int readPlayerLevel = 0;
+		int readPlayerExp = 0;
+		int readPlayerHealth = 0;
+		int[] readMonsterXPositions = new int[50];
+		int[] readMonsterYPositions = new int[50];
+		int[] readMonsterHealths = new int[50];
+
+		/*READ FROM SAVE FILE*/
+		try	
+		{
+			FileReader fr = new FileReader("save.txt");
+			BufferedReader br = new BufferedReader(fr);
+
+			//Reading player saved data
+			String readStringFloor = br.readLine();
+			readFloor = Integer.valueOf(readStringFloor);
+			String readStringPlayerPositionX = br.readLine();
+			readPlayerPositionX = Integer.valueOf(readStringPlayerPositionX);
+			String readStringPlayerPositionY = br.readLine();
+			readPlayerPositionY = Integer.valueOf(readStringPlayerPositionY);
+			String readStringPlayerLevel = br.readLine();
+			readPlayerLevel = Integer.valueOf(readStringPlayerLevel);
+			String readStringPlayerExp = br.readLine();
+			readPlayerExp = Integer.valueOf(readStringPlayerExp);
+			String readStringPlayerHealth = br.readLine();
+			readPlayerHealth = Integer.valueOf(readStringPlayerHealth);
+
+			//Reading monster saved data
+			String lineRead = br.readLine();
+			for (int i = 0; lineRead != null; i++)
+				{
+					if (lineRead != null)
+					{
+					String readStringMonsterXPosition = lineRead;
+					readMonsterXPositions[i] = Integer.valueOf(readStringMonsterXPosition);
+					lineRead = br.readLine();
+					}
+					
+					if (lineRead != null)
+					{
+						String readStringMonsterYPosition = lineRead;
+						readMonsterYPositions[i] = Integer.valueOf(readStringMonsterYPosition);
+						lineRead = br.readLine();
+					}
+					if (lineRead != null)
+					{
+					String readStringMonsterHealth = lineRead;
+					readMonsterHealths[i] = Integer.valueOf(readStringMonsterHealth);
+					lineRead = br.readLine();
+					}
+				
+				}
+
+			br.close();
+			fr.close();
+			}
+		catch (IOException e)
+		{
+			e.printStackTrace();
+		}	
+
+		//Set floor level
+		gameAssets.setFloorLevel(readFloor);
+		//Set current map
+		for (int i = readFloor - 1;i != 0;i--)
+		{
+			changeMap = xTotalLevels.removeLast();
+		}
+		//Set player related data
+		player.loadStats(readPlayerLevel, readPlayerExp, readPlayerHealth);
+		player.setPosition(readPlayerPositionX, readPlayerPositionY);
+		player.setMap(changeMap);
+		entityArray[((Entity)player).getPosition()[0]/32][((Entity)player).getPosition()[1]/32] = player.getName();
+		//Set monster related data
+		monsters.loadMonsterList(readMonsterXPositions, readMonsterYPositions, readMonsterHealths, entityArray, changeMap, readFloor);
+		CombatManager.setMonsterList(monsters.getMonsterList());
+
+		player.setEntityArray(entityArray);		
+		return changeMap;
+	}
+
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/inputRelated/MainMenuButtons.java b/Version 1.0(Current)/NewestVersion/src/inputRelated/MainMenuButtons.java
new file mode 100644
index 0000000..dc56cb8
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/inputRelated/MainMenuButtons.java	
@@ -0,0 +1,97 @@
+package inputRelated;
+
+import java.io.File;
+
+import gameStates.GameScreen;
+import gameStates.MainMenuScreen;
+import gameStates.TransitionScreen;
+
+
+import managers.SoundManager;
+
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.state.StateBasedGame;
+import org.newdawn.slick.state.transition.FadeInTransition;
+import org.newdawn.slick.state.transition.FadeOutTransition;
+
+public class MainMenuButtons {
+	
+	//Button Variables
+	private BasicButton loadGameButton;
+	private BasicButton newGameButton;
+	
+	
+	//Used to for the actions of the buttons
+	private StateBasedGame sbg;
+	private boolean savedGameExists = false;
+	
+	public MainMenuButtons (GameContainer gc, StateBasedGame stateGame) throws SlickException{
+	
+	sbg = stateGame;
+	
+	File f = new File("save.txt");
+	
+	if(f.exists() && f.isFile())
+		{
+		savedGameExists = true;
+		}
+	
+
+	//Get the images of the buttons in their inactive/active states
+	Image activeNewGame = new Image("res/interface/newGame.png");
+	Image mouseOverNewGame = new Image("res/interface/newGameMouseOver.png");
+	Image inactiveLoad = new Image ("res/interface/continueInActive.png");
+	Image activeLoad = new Image("res/interface/continueActive.png");
+	
+	
+	newGameButton = new BasicButton(gc, 330, 350, 
+									    stateGame, MainMenuScreen.ID, activeNewGame, activeNewGame);
+	loadGameButton = new BasicButton(gc, 540, 350, 
+										stateGame, MainMenuScreen.ID, inactiveLoad, activeLoad);
+	
+	newGameButton.setMouseDownImage(mouseOverNewGame);
+	newGameButton.setMouseOverImage(mouseOverNewGame);
+	
+	if (!savedGameExists){//Given that a saved game does not exist deactivate this button
+		loadGameButton.setUnClickable(true);	
+		loadGameButton.setMouseOverImage(inactiveLoad);
+		loadGameButton.setMouseOverColor(Color.white);
+		}
+	else
+	{
+		loadGameButton.setUnClickable(false);
+		loadGameButton.setMouseOverImage(new Image("res/interface/continueMouseOver.png"));
+	}	
+	//Creates an anon class for the button's action.
+	newGameButton.add(new ButtonAction(){ 
+		public void perform(){
+		sbg.enterState(TransitionScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));	
+	//	SoundManager.changeSound("res/sound/Play At Your Own Risk.wav");//I warned you. Not even sorry.
+		SoundManager.changeSound("res/sound/Catacombs.wav");
+		}
+		});
+	
+	
+	//Creates an anon class for the button's action.
+	loadGameButton.add(new ButtonAction(){ 
+		public void perform(){
+		if (savedGameExists){
+			GameScreen.setLoadedGame(true);
+			sbg.enterState(GameScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));	
+			}
+		}
+		});
+	}	
+	
+	//Draw buttons on main menu screen
+	public void render(GameContainer gc, Graphics g){
+		 newGameButton.render(gc, g);//Draw the buttons on screen.
+		 loadGameButton.render(gc,g);
+	}
+	
+	
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/inputRelated/SavingGame.java b/Version 1.0(Current)/NewestVersion/src/inputRelated/SavingGame.java
new file mode 100644
index 0000000..cb04552
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/inputRelated/SavingGame.java	
@@ -0,0 +1,53 @@
+package inputRelated;
+
+import gameStates.GameScreenAssets;
+
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.LinkedList;
+
+import managers.MonsterManager;
+import monsterRelated.BasicMonster;
+import playerRelated.Player;
+
+public class SavingGame {
+		
+	public static void SaveGame(GameScreenAssets gsa, Player p, MonsterManager mm){
+		try
+		{
+			FileWriter fw = new FileWriter("save.txt");
+			PrintWriter pw = new PrintWriter(fw);
+			//First Write Floor number. Newline.
+			pw.println(gsa.getFloorLevel());
+			//Player position. new line
+			pw.println(p.getPosition()[0]);
+			pw.println(p.getPosition()[1]);
+			//Player level
+			pw.println(p.getCurrentLevel());
+			//Player experience points. new line
+			pw.println(p.getExperiencePoints());
+			//Player health points. new line.
+			pw.println(p.getHealthPoints());
+			//Start loop for saving monster info
+			LinkedList<BasicMonster> mmLL = (LinkedList<BasicMonster>) mm.getMonsterList().clone();
+			while (mmLL.peekFirst() != null)
+			{
+				BasicMonster currentNode = mmLL.removeFirst();
+				//Don't have monster type as of now
+				//Write monster x-coordinate and y-coordinate
+				pw.println(currentNode.getPosition()[0]);
+				pw.println(currentNode.getPosition()[1]);
+				//Write monster health
+				pw.println(currentNode.getHealthPoints());
+			}
+			pw.close();
+			fw.close();
+		}
+		catch (IOException e)
+		{
+			e.printStackTrace();
+		}
+	}
+
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/inputRelated/SlideOutMenu.java b/Version 1.0(Current)/NewestVersion/src/inputRelated/SlideOutMenu.java
new file mode 100644
index 0000000..59820b5
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/inputRelated/SlideOutMenu.java	
@@ -0,0 +1,108 @@
+package inputRelated;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.gui.GUIContext;
+import org.newdawn.slick.gui.MouseOverArea;
+import org.newdawn.slick.state.StateBasedGame;
+
+////////////////////////////////////////////////////////
+//Slide Out Menu									  //
+//Purpose: Controls Slide Out Menu/Associated Buttons //
+//Limit: Does not smoothly pop out					  //
+//Has not other buttons than exiting the game		  //
+////////////////////////////////////////////////////////
+
+public class SlideOutMenu extends MouseOverArea{
+
+	//Used Changing States/Closing Game
+	private StateBasedGame sbg;
+	private GUIContext gc;
+	
+	//Sets menu's state
+	private boolean activated = false;
+	private boolean menuOpen = false;
+
+	private BasicButton exitGameButton;
+	
+	//Button Variables used for Constructor
+	private final List <ButtonAction> actions = new ArrayList <ButtonAction>();
+	private int stateID;
+	
+	//Slide Out Menu Initialization
+	public SlideOutMenu(GUIContext container,StateBasedGame game, int stateID,  Image image, int x, int y) throws SlickException {
+		super(container, image, x, y);
+		sbg = game;
+		gc = container;
+		this.stateID = stateID;
+	    super.setMouseOverColor(Color.yellow);
+	    exitGameButton = new BasicButton(container, 1140, y+315, game, 
+	    		stateID, new Image ("res/interface/saveExit.png"), new Image ("res/interface/saveExit.png"));
+	    
+	    exitGameButton.setMouseOverImage(new Image("res/interface/saveExitMouseOver.png"));
+		exitGameButton.add(new ButtonAction(){
+			public void perform(){
+				((GameContainer)gc).exit();	
+			}	
+		});
+
+	}
+
+	   //Draw Game Menu (Used for mouseOverDownImage and highlighting color)
+	   public void render(GameContainer gc, Graphics g) {
+	          super.render(gc, g);
+	          exitGameButton.render(gc,g);
+	   }
+	
+	
+	   //The menu is essentially one big button so it has to inherit/implement this method
+	   public boolean isActivated() {
+	        return activated;
+	    }
+	   
+	   //Used for the slide out menu
+	   public void add(ButtonAction action){
+		actions.add(action);
+	   }
+	
+	//Method that handles what happens you click on the slide out menu
+	//Depending on whether it's already open or not
+	@Override
+    public void mousePressed(int button, int x, int y) {
+		if (isMouseOver() && sbg.getCurrentStateID() == stateID) {
+            activated = !activated;
+            if (menuOpen == false){
+            	popOut();
+            }
+            else{
+            	popIn();
+            }
+        super.mousePressed(button, x, y);
+       }
+    }
+    
+	//Checks boolean
+	//Used for hot keys in game screen 
+	public boolean getMenuOpen(){return menuOpen;}
+	
+	//Pops the slide menu out
+	public void popOut(){
+		setX(300);
+    	exitGameButton.setX(610);
+    	menuOpen = true;
+	}
+	
+	//Pops the slide menu in
+	public void popIn(){
+		setX(1065);
+    	exitGameButton.setX(1150);
+    	menuOpen = false;
+	}
+	
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/managers/CombatManager.java b/Version 1.0(Current)/NewestVersion/src/managers/CombatManager.java
new file mode 100644
index 0000000..979633c
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/managers/CombatManager.java	
@@ -0,0 +1,139 @@
+package managers;
+
+import gameStates.GameScreenAssets;
+
+import java.util.LinkedList;
+import java.util.Random;
+
+import monsterRelated.BasicMonster;
+import playerRelated.Player;
+
+/////////////////////////////////////////////////////////////
+//Combat  Manager                                          //
+//Purpose: Deal with the combat inside the game		       //
+//Limit: Monsters will only attack if players attack       // 
+//Monsters will freeze movement if one monster is being    //
+//attacked.  											   //
+//Notes: Sends messages about the combat to text log	   //
+/////////////////////////////////////////////////////////////
+
+public class CombatManager {
+	
+	public static boolean battleHappening = false;
+	private static LinkedList <BasicMonster> monsterList = new LinkedList<BasicMonster>();
+	
+	
+	public static void setMonsterList(LinkedList <BasicMonster> monsters){monsterList = monsters;}
+		
+	// The monster will attack the player when it has been provoked	
+	public static String attackLoop(Player player, int criticalHitLimit, int missFactor, int monsterX, int monsterY ){
+		battleHappening = true;
+		if (getMonsterRef(monsterX, monsterY) == null)
+		{
+			GameScreenAssets.queueTextLog.addFirst("You are attacking a ghost! Oh no! Run away before it gets you!");
+			battleHappening = false;
+			return "Error! No Monster Found to Fight";
+		}
+		else
+		{
+			BasicMonster currentFoe = getMonsterRef(monsterX,monsterY);
+    		actualCombat(currentFoe, player, criticalHitLimit, missFactor);
+					
+		}
+		return null;
+	}
+	
+	
+	//Attacks Monster Accordingly to attack generate
+	//TO DO: ADD SOUNDS
+	private static void actualCombat(BasicMonster currentFoe, Player player, int criticalHitLimit, int missFactor){
+	
+		int attack = generateAttack(criticalHitLimit);//Generate Attack
+		
+		//Player Misses!
+		if (attack <= missFactor){
+			GameScreenAssets.queueTextLog.addFirst("You missed!");
+			SoundManager.playSoundEffect("res/sound/SFX/Swoosh.wav");
+			monsterAttacks (player,currentFoe);
+			}
+		
+		
+		//Average Hit
+		else if (attack > missFactor && attack <= criticalHitLimit-missFactor)
+		{
+		
+		GameScreenAssets.queueTextLog.addFirst("Average Hit: "+attack);
+		SoundManager.playSoundEffect("res/sound/SFX/Sword Swing.wav");
+		currentFoe.subtractHealth(attack);
+		currentFoe.setIsAttacked(true);
+			if (currentFoe.getHealthPoints() <= 0)
+			{
+				monsterDies(player, currentFoe);
+				return;
+			}
+			monsterAttacks (player,currentFoe);
+		}
+		
+		
+		//Critical Hit
+		else 
+		{
+		currentFoe.subtractHealth(attack);
+		currentFoe.setIsAttacked(true);
+		GameScreenAssets.queueTextLog.addFirst("Critical Hit: "+attack);
+		SoundManager.playSoundEffect("res/sound/SFX/Sword Swing.wav");
+			if (currentFoe.getHealthPoints() <= 0)
+			{
+				monsterDies(player, currentFoe);
+				return;
+			}
+			monsterAttacks (player,currentFoe);
+		}
+	}
+	
+	
+	// An attack roll is generated
+	private static int generateAttack(int criticalHitLimit){
+		Random gen = new Random();
+		int attack = gen.nextInt(criticalHitLimit);
+		return attack;
+	}
+	
+	
+	// Monster Attacks Back with randomly generated Number
+	private static void monsterAttacks(Player player, BasicMonster currentFoe){
+		int attack = generateAttack(currentFoe.damageLimit);
+		player.subtractHealth(attack);	
+		GameScreenAssets.queueTextLog.addFirst("Monster attacks back! Damage Done: "+attack);
+//		SoundManager.playSoundEffect("res/sound/SFX/Player Oof.wav");
+	
+	}
+	
+	
+	// Handles what happens when a monster is killed
+	private static void monsterDies(Player player, BasicMonster currentFoe){
+		GameScreenAssets.queueTextLog.addFirst("You've Killed the monster!");
+		SoundManager.playSoundEffect("res/sound/SFX/Potential Monster Die.wav");
+		player.addExperiencePoints(currentFoe.getExpPointGain());
+		battleHappening = false;
+		monsterList.remove(currentFoe);
+	
+	}
+	
+	
+	// Retrieves monster reference from the monster list
+	private static BasicMonster getMonsterRef(int x, int y){
+		BasicMonster monsterFound = null;
+		int [] monsterPosition = new int [2];
+		for (int i = 0; i < monsterList.size(); i++)
+			{
+			monsterPosition = monsterList.get(i).getPosition();
+			if (monsterPosition[0] == x && monsterPosition[1] == y)
+				{
+				monsterFound = monsterList.get(i);
+				}
+			}
+		return monsterFound;
+	}
+	
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/managers/EntityManager.java b/Version 1.0(Current)/NewestVersion/src/managers/EntityManager.java
new file mode 100644
index 0000000..45ad421
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/managers/EntityManager.java	
@@ -0,0 +1,14 @@
+package managers;
+
+public class EntityManager {
+
+	/*
+	public void initEntity (Player Poostin, )
+	
+	
+	public add 
+	*/
+	
+	
+	
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/managers/MonsterManager.java b/Version 1.0(Current)/NewestVersion/src/managers/MonsterManager.java
new file mode 100644
index 0000000..8007feb
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/managers/MonsterManager.java	
@@ -0,0 +1,309 @@
+
+package managers;
+
+import java.util.LinkedList;
+import java.util.Random;
+
+import mapRelated.BasicMap;
+import monsterRelated.BasicMonster;
+
+import org.newdawn.slick.Animation;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.SpriteSheet;
+
+/////////////////////////////////////////////////////////////
+//Monster Manager                                          //
+//Purpose: Manage Multiple Monsters in a level		       //
+//Limit: Currently only handles one type of monster.       //
+//Features: Spawns Monsters 2*Level. Save for Level 7 	   //
+/////////////////////////////////////////////////////////////
+
+public class MonsterManager {
+
+	
+	private LinkedList<BasicMonster> monsterList = new LinkedList<BasicMonster>();
+	private int level = 1;
+	private BasicMap currentMap;
+	private String[][] entityArray;
+	
+	
+	//Monster Type1
+	//Might Rename as "Soldiers" or "Guards"
+	//Because they will march between two points like guards on patrol.
+	private Image basicMonsterImage;
+	private SpriteSheet basicMonsterSheet;
+	private Animation basicMonsterAnimation;//Will bob monsters up and down some day
+	
+	
+	
+	
+	//For test purposes Only
+	public MonsterManager(){
+		
+	}
+	//For test purposes only
+	
+	//Sets Map for Monster Manager
+	public MonsterManager(BasicMap map){
+		currentMap = map;
+	}
+	
+	//Checks if Valid Entity Array
+	public String checkEntityArray(String [][] entityArray){
+		if (entityArray.length*entityArray[0].length != 35*16)
+			return "Entity Array Not Expected Size";
+		
+		for (String[] row: entityArray){
+			for (String s:row)
+			{
+				if (s == null)
+					return "EntityArray cannot have null objects";
+			}
+		}
+		
+		boolean playerFound = false;
+		for(String[] row:entityArray)
+		{
+			for (String s: row)
+			{
+				if (s.equals("P"))
+					playerFound = true;
+			}
+		}
+		
+		if (!playerFound)
+			return "Player not in EntityArray"; 
+		
+		return null;
+	}
+	
+	
+	//Sets entityArray for later monster spawning
+	public String setEntityArray(String [][]entityArray){
+		if ( checkEntityArray(entityArray) != null)
+		{
+			return "Invalid Entity Array";
+		}
+		this.entityArray = entityArray;
+		return null;
+	}
+	
+	//To do later: Put this into a private object and change this method to a private method.
+	public int[] findValidPlacement(int monsterPathSize, BasicMap map, String [][] array){
+		Random gen = new Random();
+		int newX = gen.nextInt(35)*BasicMap.TILESIZE;
+		int newY = gen.nextInt(16)*BasicMap.TILESIZE;
+		int[]  newPosition = {newX, newY};
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i ++){
+			for (int c = 0; c < BasicMap.heightByTiles; c++){
+				if (checkValidPlacement(newPosition, monsterPathSize, map, array) == null){
+					return newPosition;
+					}
+				newPosition[0] = (newX+i*BasicMap.TILESIZE)%(1120);
+				newPosition[1] = (newY+c*BasicMap.TILESIZE)%(512);
+				}
+
+			}
+		return null;
+	}
+	
+	//Checks if spawned at a valid spot
+	public String checkValidPlacement(int[]newPosition, int monsterPathSize, BasicMap map, String [][] array){
+		Boolean allClear = true;
+		int checkX = newPosition[0];
+		int checkY = newPosition[1];
+		for (int i = 0;i < monsterPathSize; i++)
+		{
+			if (checkX >= (1120) || checkY >= (512) || checkX < 0 || checkY < 0)
+				return "Out of Bounds";
+			else if (array[checkX/BasicMap.TILESIZE][checkY/BasicMap.TILESIZE] != " "){
+				allClear = false;
+				return "Entity Overlap";
+				}
+			else if (map.hasCollision(checkX, checkY))
+				{
+				allClear = false;
+				return "Map Overlap";
+				}
+			
+			checkX += BasicMap.TILESIZE;
+		}
+
+		if (allClear){
+			return null;
+		}
+		else{
+			return "Invalid Spot";
+		}
+
+	}
+	
+	
+	// Loads monster Images 
+	private void loadMonsterTypes() throws SlickException{
+		basicMonsterSheet= new SpriteSheet("res/monster/dummySheet.png",32,32); 
+		basicMonsterImage = basicMonsterSheet.getSubImage(0, 0);
+		Image [] monsterAnim = {basicMonsterSheet.getSubImage(0, 0), basicMonsterSheet.getSubImage(1, 0)};
+		int [] duration = {250,250};
+		basicMonsterAnimation = new Animation(monsterAnim, duration, false);
+	}
+	
+	//Initializes the amount of monsters per level
+	public void init(String [][] entityArray, BasicMap currentMap) throws SlickException{
+		if (checkEntityArray(entityArray) !=null)
+			return;
+		loadMonsterTypes();
+		this.entityArray = entityArray;
+		BasicMonster monster1 = null;
+		int pathSize = 4;
+		
+		//Adjusts path size for more confined maps.
+		if (level >= 3)
+			pathSize = 2;
+		
+		//Spawns number of monsters according to level
+		if (level < 7)
+		{
+			for (int i = 0; i < level*2; i++){
+				int[] spawnPosition = findValidPlacement (pathSize, currentMap, entityArray);
+				while (spawnPosition == null)
+					spawnPosition = findValidPlacement (pathSize, currentMap, entityArray);
+			
+				monster1 = new BasicMonster(currentMap, basicMonsterAnimation, basicMonsterImage, spawnPosition[0], spawnPosition[1]);
+				monsterList.add(monster1);
+				monster1.setPath(spawnPosition[0], spawnPosition[0]+3*BasicMap.TILESIZE);
+				entityArray[monster1.getPosition()[0]/BasicMap.TILESIZE]
+				     	   [monster1.getPosition()[1]/BasicMap.TILESIZE] = monster1.getName();
+			}
+		}
+		
+		//Special Treatment for Level 7
+		else
+		{
+			for (int i = 0; i < 7; i++){
+				int[] spawnPosition = findValidPlacement (pathSize, currentMap, entityArray);
+				while (spawnPosition == null)
+					spawnPosition = findValidPlacement (pathSize, currentMap, entityArray);
+			
+				monster1 = new BasicMonster(currentMap,basicMonsterAnimation, basicMonsterImage, spawnPosition[0], spawnPosition[1]);
+				monsterList.add(monster1);
+				monster1.setPath(spawnPosition[0], spawnPosition[0]+3*BasicMap.TILESIZE);
+				entityArray[monster1.getPosition()[0]/BasicMap.TILESIZE]
+				     	   [monster1.getPosition()[1]/BasicMap.TILESIZE] = monster1.getName();
+			}
+		
+		}
+		
+		//Sets up monster methods
+		BasicMonster [] monsters = monsterList.toArray(new BasicMonster [monsterList.size()]);
+		for (BasicMonster m: monsters){
+			m.setEntityArray(entityArray);
+			m.setMonsterMaxHealth(level*10);
+			m.setHealthPoints(level*10);
+			if (level == 1)//Special Level 1 treatment
+				m.damageLimit = 4;
+			else
+				m.damageLimit = 20+level*2;
+			m.setMap(currentMap);
+			}
+		
+	}
+	
+	//Calls render method for every monster inside the list.
+	public void render(Graphics g) throws SlickException{
+		
+		BasicMonster [] monsters = monsterList.toArray(new BasicMonster [monsterList.size()]);
+		for (BasicMonster m: monsters){
+			m.render(g);
+			}
+		
+	}
+
+	
+	public void loadMonsterList(int[] newMonsterXPositions, int[] newMonsterYPositions, 
+								int[] newMonsterHealths, String[][] newEntityArray, BasicMap newMap, int newLevel)
+	throws SlickException
+	{
+		this.level = newLevel;
+		loadMonsterTypes();
+		currentMap = newMap;
+		monsterList = new LinkedList<BasicMonster>();
+		BasicMonster monster;		
+
+		int numOfMonsters = newMonsterXPositions.length;
+		for (int i = 0;i < numOfMonsters;i++)
+		{
+			if (newMonsterXPositions[i] == 0 && newMonsterYPositions[i] == 0)
+				break;
+			monster = new BasicMonster(currentMap, basicMonsterAnimation, basicMonsterImage, newMonsterXPositions[i], newMonsterYPositions[i]);
+			monster.setHealthPoints(newMonsterHealths[i]);
+			monster.setPath(newMonsterXPositions[i], newMonsterXPositions[i]+3*BasicMap.TILESIZE);
+			newEntityArray[monster.getPosition()[0]/BasicMap.TILESIZE]
+			     	   [monster.getPosition()[1]/BasicMap.TILESIZE] = monster.getName();
+			monsterList.add(monster);
+		}
+		
+		BasicMonster [] monsters = monsterList.toArray(new BasicMonster [monsterList.size()]);
+		for (BasicMonster m: monsters){
+			m.setEntityArray(newEntityArray);
+			m.setMonsterMaxHealth(level*20);
+			m.damageLimit = level*2;
+			m.setMap(currentMap);
+			if (level == 1)//Special Level 1 treatment
+				m.damageLimit = 4;
+			else
+				m.damageLimit = 20+level*2;
+		}
+		this.entityArray = newEntityArray;
+		
+	}
+	
+	
+	
+	//Calls update method for every monster inside list
+	public void update(int[] playerPosition, int counter){
+
+		BasicMonster [] monsters = monsterList.toArray(new BasicMonster [monsterList.size()]);
+		for (BasicMonster m: monsters){
+			m.update(playerPosition, counter);
+			}
+	}
+	
+	
+	//Returns the entityArray with the monsters placed on them
+	public String [][] getEntityArray(){return entityArray;}	
+		
+	//Returns the linked list of monsters
+	public LinkedList<BasicMonster> getMonsterList() {return monsterList;}
+	
+	
+	//Method to change level and change the amount of monsters.
+	public void increaseFloorLevel(){level++;}
+	
+	//Calls the setMap function for all the monsters inside the list
+	public void setMap(BasicMap newMap){
+		BasicMonster [] monsters = monsterList.toArray(new BasicMonster [monsterList.size()]);
+		for (BasicMonster m: monsters){
+			m.setMap(newMap);
+			}
+	}
+	
+	//Clears the monsters for the next Level
+	public String clearMonsters(){
+		for (int i = 0; i < BasicMap.widthByTiles; i++){
+			for (int c = 0; c <BasicMap.heightByTiles; c ++){
+				if (entityArray[i][c] != "P")
+					entityArray[i][c] = " ";
+			}
+		}
+		if (checkEntityArray (entityArray) != null){
+			return "Error! You accidentally cleared the player";//"Technically this checks if you've created an array
+		}														//Of proper size, no nulls AND a player inside it.
+		monsterList.clear();
+		
+		return null;
+	}	
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/managers/SoundManager.java b/Version 1.0(Current)/NewestVersion/src/managers/SoundManager.java
new file mode 100644
index 0000000..9c6b983
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/managers/SoundManager.java	
@@ -0,0 +1,68 @@
+package managers;
+	import java.io.IOException;
+
+import org.newdawn.slick.openal.Audio;
+import org.newdawn.slick.openal.AudioLoader;
+import org.newdawn.slick.openal.SoundStore;
+import org.newdawn.slick.util.ResourceLoader;
+
+
+///////////////////////////////////////////
+//SoundManager							 //
+//Purpose: Manages the sounds in the game//
+//Limit: Limited to Slick2dAPI			 //
+//Will crash if sound file not found     //
+///////////////////////////////////////////
+
+
+public class SoundManager {
+	 
+		/** The wav sound effect */
+		private static Audio wavEffect;
+		
+		//Loads initial Backgroud music
+	    public SoundManager(String filename) {
+	 
+	        try {
+	 
+		    //load Wav sound
+		    wavEffect = AudioLoader.getAudio("WAV", ResourceLoader.getResourceAsStream(filename));
+			wavEffect.playAsMusic(1.0f,1.0f, true);  
+	        } catch (IOException e) {
+		    e.printStackTrace();
+		}
+	    	SoundStore.get().poll(0);
+			
+	    }
+	 
+	    //Updates music and keeps it playing
+		public void update() {
+			wavEffect.playAsMusic(1.0f,1.0f, true);  
+			SoundStore.get().poll(0);
+		}
+		
+		//Changes music playing in the background
+		public static void changeSound (String filename){
+			try{
+			wavEffect = AudioLoader.getAudio("WAV", ResourceLoader.getResourceAsStream(filename));
+			wavEffect.playAsMusic(1.0f,1.0f, true);  
+			}
+			catch (IOException e){
+				e.printStackTrace();
+			}
+		}
+
+		//Plays sound once
+		public static void playSoundEffect(String filename){
+			try{
+				wavEffect = AudioLoader.getAudio("WAV", ResourceLoader.getResourceAsStream(filename));
+				wavEffect.playAsSoundEffect(1.0f,1.0f, false);  	
+			}
+			catch (IOException e){
+				e.printStackTrace();
+			}
+
+		}
+	 
+}
+
diff --git a/Version 1.0(Current)/NewestVersion/src/mapRelated/BasicMap.java b/Version 1.0(Current)/NewestVersion/src/mapRelated/BasicMap.java
new file mode 100644
index 0000000..97214da
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/mapRelated/BasicMap.java	
@@ -0,0 +1,132 @@
+package mapRelated;
+
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.tiled.TiledMap;
+
+//////////////////////////////////////////////////////////////////////////////////
+//BasicMap																		//
+//Purpose: Basic Template for loading Maps from Tiled. 							//
+//Has Methods that manages operations related to maps							//
+//Limit: Limited to Tiled Program Loading										//
+//////////////////////////////////////////////////////////////////////////////////
+
+public class BasicMap
+{
+	private TiledMap map;
+	private char [][] mapArray;
+
+	public static final int widthByTiles = 35;
+	public static final int heightByTiles = 16;
+	public static final int TILESIZE = 32;
+	
+	////////////FOR TESTS ONLY//////////////
+	////////////////////////////////////////
+	public BasicMap(char [][] newArray){
+		
+		mapArray = newArray;
+	}
+	
+	
+	public BasicMap(){
+		mapArray = new char [widthByTiles][heightByTiles];
+	}
+	//////////////////////////////////////
+	//////////////////////////////////////
+	
+	
+	
+	//Loads Map based on .tmx file
+	public BasicMap(String tmxLocation) throws SlickException{
+		map = new TiledMap(tmxLocation);
+		mapArray = new char[widthByTiles][heightByTiles];
+		initMapArray();
+	}
+
+	//Initializes the Map
+	//Reads the load .tmx file
+	private void initMapArray (){
+		String value;
+		for (int c = 0; c < widthByTiles; c++){
+			for (int r = 0; r < heightByTiles; r ++)
+			{
+				int tileID = map.getTileId(c, r, 0);
+				if (r == 0 & c == 0)
+				{
+				System.out.println(tileID);
+				}
+                value = map.getTileProperty(tileID, "blocked", "false");
+                if ("true".equals(value))
+                {
+                    mapArray[c][r] = 'B';
+                }
+                value = map.getTileProperty(tileID, "stairs", "false");
+                if ("true".equals(value))
+                {
+                	mapArray[c][r] = 'S';
+                }
+                
+                value = map.getTileProperty(tileID, "win", "false");
+                if ("true".equals((value)))
+                {
+                	mapArray[c][r] = 'W';
+                }
+			}
+		}
+	}
+
+	
+	//Checks if a given x,y coordinate collides with a block on the map
+	public boolean hasCollision (float x, float y)
+	{
+		if (x < 0 || y < 0 || x >=1120 || y >= 512)
+			return false;
+		
+		int xBlock = (int)x / TILESIZE;
+	    int yBlock = (int)y / TILESIZE;
+	    
+	    //Just a test conditional code.
+	    if (mapArray[xBlock][yBlock] == 'B')
+	    	return true;
+	    
+	    else
+	    	return false;    
+	}
+		
+	//Renders the map on screen
+	public void render()
+	{
+		map.render(0,0);
+	}
+	
+	//Checks if a give x,y coord is a staircase
+	public boolean isStairs (float x, float y)
+	{
+		if (x < 0 || y < 0 || x >=1120 || y >= 512)
+			return false;
+		
+		int xStairs = (int)x / TILESIZE;
+	    int yStairs = (int)y / TILESIZE;
+	    
+	    if (mapArray[xStairs][yStairs] == 'S')
+	    	return true;
+	    else
+	    	return false;
+	}
+	
+
+
+	//Checks if a give x,y coord is a staircase
+	public boolean isWin (float x, float y)
+	{	
+	if (x < 0 || y < 0 || x >=1120 || y >= 512)
+		return false;
+	
+	int xStairs = (int)x / TILESIZE;
+    int yStairs = (int)y / TILESIZE;
+    
+    if (mapArray[xStairs][yStairs] == 'W')
+    	return true;
+    else
+    	return false;
+	}
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/monsterRelated/BasicMonster.java b/Version 1.0(Current)/NewestVersion/src/monsterRelated/BasicMonster.java
new file mode 100644
index 0000000..87714b8
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/monsterRelated/BasicMonster.java	
@@ -0,0 +1,295 @@
+package monsterRelated;
+
+
+import mapRelated.BasicMap;
+
+import org.newdawn.slick.Animation;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.SpriteSheet;
+
+
+public class BasicMonster extends Entity{
+
+	//Variables related to Images
+	protected Image monsterImage;
+	protected Animation monsterAnimation;
+	
+	//Variables related to spotting the player
+	protected double monsterSightRange;
+	protected boolean isActiveState = false;
+	
+
+	//Variables related to movement	
+	private int counter;
+	protected char direction;
+	private int pathStart = 7*BasicMap.TILESIZE, pathEnd = 9*BasicMap.TILESIZE;
+	private BasicMap map;
+	
+	//Variables related to combat
+	public int damageLimit = 18;//This can be overridden by its children later. Just watch for it.
+	protected boolean isAttacked = false;
+	
+	
+
+	///////////////////////////////////
+	//////////For TEST ONLY////////////
+	public BasicMonster(BasicMap map, int x, int y, int counter){
+		super(x,y);
+		this.counter = counter;
+		this.map = map;
+		name = "M";
+		monsterSightRange = 2;
+		counter = 0;
+		direction = 'R';
+		maxHealthPoints = 1000;
+		healthPoints = maxHealthPoints;
+		}
+
+	
+	public BasicMonster(BasicMap currentMap, Animation monsterLook,int x, int y) throws SlickException
+	{
+		super(x,y);
+		map = currentMap;
+		name = "M";
+		monsterSightRange = 2;
+		SpriteSheet basicMonsterSheet= new SpriteSheet("res/monster/dummySheet.png",32,32); 
+		monsterImage = basicMonsterSheet.getSubImage(0, 0);
+		monsterAnimation = monsterLook;
+		monsterAnimation.setAutoUpdate(true);
+		counter = 0;
+		direction = 'R';
+		maxHealthPoints = 100;
+		healthPoints = maxHealthPoints;
+	}
+	
+	
+
+	//////////////////////////////////// STILL TEST METHODS ABOVE//////////////////////////
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+	
+	
+	
+	
+	
+	
+	//Initializes Monster
+	public BasicMonster(BasicMap currentMap,Animation monsterAnimation, Image monsterLook,int x, int y)
+	{
+		super(x,y);
+		map = currentMap;
+		name = "M";
+		monsterSightRange = 2;
+		monsterImage = monsterLook;
+		this.monsterAnimation = monsterAnimation;
+		monsterAnimation.setAutoUpdate(true);
+		counter = 0;
+		direction = 'R';
+		maxHealthPoints = 20;
+		healthPoints = maxHealthPoints;
+	}
+
+	///////Methods dealing with the state of the monster///////
+	public boolean getMonsterState(){return isActiveState;}
+	
+	
+	public void setMonsterState(boolean foundPlayer){
+		isActiveState = foundPlayer;	
+	}
+	public void setIsAttacked (boolean attacked){isAttacked = attacked;}
+	
+	public void actDead() throws SlickException{
+		monsterImage = new Image ("res/monster/dead.png");
+	}
+	
+	
+	//Methods dealing with monster combat
+	public void setHealthPoints(int points) {healthPoints = points;}
+	public void setMonsterMaxHealth(int monsterMaxHealth) {monsterMaxHealth = maxHealthPoints;}
+	public int getExpPointGain() {return maxHealthPoints/2;}
+	
+	
+	//Draws Monster to Screen
+	public void render(Graphics g) throws SlickException{
+		if (!alive)
+			actDead();
+		monsterAnimation.draw((int)x, (int)y);
+	}
+	
+	//Updates Monster's Position
+	public String update(int [] playerPosition, int counter)
+	{
+		
+		this.counter = counter;
+		oldx = x;
+		oldy = y;
+		//Check for Overlap
+		if (playerPosition[0] < 0 || playerPosition [1] < 0)
+			return "Invalid Player Position! Going Off Map";
+		if (entityArray[playerPosition[0]/32][playerPosition[1]/32] == " " ||
+			entityArray[playerPosition[0]/32][playerPosition[1]/32] == "M"){
+			return "Player has disappeared from the map.";}
+
+		
+		isActiveState = search("P");
+		if (isActiveState || (isAttacked&&!isActiveState)){
+			findClosestSpot(playerPosition);
+		}
+		else{
+			wander(playerPosition);
+		}
+		
+		return null;
+	}
+		
+	
+	////////////////////////////////////////////
+	/////////////Movement Methods///////////////
+	////////////////////////////////////////////
+
+	//Sets path that monsters wanders along
+	public void setPath (int start, int end){
+		pathStart = start;
+		pathEnd = end;}
+	
+	//Moves monster according to its path
+	private void wander(int [] playerPosition){
+	if (!alive)
+		return;
+	
+	int newX1 = x+BasicMap.TILESIZE;
+	int newX2 = x-BasicMap.TILESIZE;	
+	if ((newX2>= 0 && newX1<=1048)&&counter >= 400){
+		//Change Direction
+		if (newX1 > pathEnd)
+			direction = 'L';
+
+		//move rightwards	
+		if (direction == 'R'&&!isTaken(newX1,y)){
+			if (map.hasCollision(newX1, y))
+			{
+				direction = 'L';
+				return;
+			}
+			updatePosition(newX1,y);
+			x = newX1;
+			
+			}
+		//move leftwards
+		else if (direction == 'L' &&!isTaken(newX2,y)){
+				if (map.hasCollision(newX2, y))
+				{
+					direction = 'R';
+					return;
+				}
+				updatePosition(newX2,y);
+				x = newX2;
+				//Change Direction
+				if (x  < pathStart){
+					direction = 'R';
+				}
+		}
+			
+		counter = 0;
+	}
+	else
+		counter++;
+	}
+	
+		
+	//Used to find closestSpot near the player
+	public void findClosestSpot(int[] player)
+	{
+		int newX = 0;
+		int newY = 0;
+		if (x == player[0]&& y!= player[1]){
+				closestSpotHorizontal (player, newX, newY);
+			}
+			
+		else if (y == player[1]&& x != player[0])
+		{
+			closestSpotVertical(player,newX, newY);
+		}
+		else if (y!= player[1]&& x!= player[0])
+		{
+			closestSpotDiagonal(player,newX, newY);
+				
+		    }
+	}	
+	
+	//Finds closest diagonal spots towards player
+	private void closestSpotDiagonal(int [] player, int newX, int newY)
+	{
+
+		if (y > player[1])
+			newY = y - BasicMap.TILESIZE;
+		else
+			newY = y + BasicMap.TILESIZE;
+		
+		if (x > player [0])
+			newX = x - BasicMap.TILESIZE;
+		else
+			newX = x + BasicMap.TILESIZE;		
+		
+		if (!isTaken(newX, newY) && !map.hasCollision(newX, newY))
+				{
+				updatePosition(newX,newY);
+				x = newX;
+				y = newY;
+				}
+		
+		else if (!isTaken(x, newY) && !map.hasCollision(x, newY))
+				{
+				updatePosition(x,newY);
+				y = newY;
+			    }
+		
+		else if (!isTaken(newX, y) && !map.hasCollision(newX, y))
+				{
+				updatePosition(newX, y);
+				x = newX;
+				}		
+	}
+	
+	
+
+	//Finds closest horizontal spots towards player
+	private void closestSpotHorizontal(int [] player, int newX, int newY){
+		if (player[1] > y)
+			newY = y + BasicMap.TILESIZE;
+		else
+			newY = y - BasicMap.TILESIZE;
+		
+		if (!isTaken(x,newY)&&!map.hasCollision(x,newY))
+			{		
+			updatePosition(x,newY);
+			y = newY;
+			}
+	}
+	
+	
+
+	//Finds closest vertical spots towards player
+	private void closestSpotVertical(int [] player, int newX, int newY){
+		
+		if (player[0] > x)
+			newX = x + BasicMap.TILESIZE;
+		else
+			newX = x - BasicMap.TILESIZE;
+		
+		if (!isTaken(newX,y)&&!map.hasCollision(newX, y))
+			{
+			updatePosition(newX,y);
+			x = newX;
+			}
+	}
+	
+	
+
+}
+
+	
+	
+
diff --git a/Version 1.0(Current)/NewestVersion/src/monsterRelated/Entity.java b/Version 1.0(Current)/NewestVersion/src/monsterRelated/Entity.java
new file mode 100644
index 0000000..40107da
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/monsterRelated/Entity.java	
@@ -0,0 +1,171 @@
+package monsterRelated;
+
+import mapRelated.BasicMap;
+
+public class Entity {
+	
+	//Has both the old position and current position 
+	protected int oldx = 0, oldy = 0;
+	protected int x,y;
+	
+	//Used to check for overlap with other monsters
+	protected String [][] entityArray;
+	
+	//Name is created (note: never let it equal to 1 )
+	protected String name;
+	
+	//Variables related with the health of the character
+	protected int healthPoints = 30;
+	protected int maxHealthPoints = 30;
+	protected boolean alive = true;
+	
+	//Map entity stands upon currently
+	protected BasicMap map;
+	
+	//Location of entity
+	public Entity (int x,int y){
+		this.x = x;
+		this.y = y;
+	}
+	
+/////////////////////////////////////////////////
+//METHODS USED FOR SEARCHING UPDATING LOCATION IN ENTITY ARRAY
+/////////////////////////////////////////////////
+	
+	//Updates position of entity in entityArray
+	public String updatePosition(int x, int y){
+		if (!alive)
+			return null;
+		
+		if (x < 0 || oldx < 0 || y< 0|| oldy < 0 || x >= 1120 || y >=512)	
+			return "Out of Bounds";
+		
+		oldx = this.x;
+		oldy = this.y;
+		entityArray[oldx/BasicMap.TILESIZE][oldy/BasicMap.TILESIZE] = " ";
+		entityArray[x/BasicMap.TILESIZE][y/BasicMap.TILESIZE] = name;
+		this.x = x;
+		this.y = y;
+		
+		return null;
+	}
+	
+	//Checks if the given spot current has an entity (player or monster) in it.
+	public boolean isTaken(int x, int y){
+		if (x < 0 || y < 0 || x >= 1120 || y >=512)
+			return false;
+		int xTile = x/BasicMap.TILESIZE;
+		int yTile = y/BasicMap.TILESIZE;
+		boolean isTaken = false;
+		if (entityArray[xTile][yTile] != " ")
+			isTaken = true;
+		return isTaken;
+	}
+	
+	//Searches entityArray and sees if another entity is near it.
+	public boolean search(String name){
+			boolean found = false;
+			//Search looks within the range of 2
+			for (int row = (x/BasicMap.TILESIZE)-2; row <= (x/BasicMap.TILESIZE)+2; row++)
+			{
+				for (int column = (y/BasicMap.TILESIZE)-2; column <= (y/BasicMap.TILESIZE)+2; column++)
+				{
+					//If within bounds of the map.
+					if (row >= 0 && row < BasicMap.heightByTiles && column >= 0 && column < BasicMap.widthByTiles)
+					{
+						if (entityArray[row][column]!= null&&entityArray[row][column].equals(name))
+						{
+							found = true;
+							break;
+						}
+					}
+					
+				}	
+			}	
+			return found;
+	}
+	
+/////////////////////////////////////////
+///////////Combat Methods////////////////
+/////////////////////////////////////////
+	
+	//Subtract entity's health Points
+	public String subtractHealth(int points){
+		if (points < 0)
+			return "Cannot subtract negative health points";
+		
+		if (healthPoints - points <= 0){
+			alive = false;
+			entityArray[x/BasicMap.TILESIZE][y/BasicMap.TILESIZE] = " ";
+			healthPoints = 0;
+		}
+		else
+			healthPoints -= points;
+		return null;
+	}
+	
+	//Add entity's healthPoints
+	public String addHealthPoints(int points){
+		if (points < 0)
+			return "Cannot add negative health points";
+			
+		if (healthPoints+points > maxHealthPoints)
+			healthPoints = maxHealthPoints;
+		else
+			healthPoints += points;
+		
+		return null;
+	}
+	
+	//Gets the health points of the entity
+	public int getHealthPoints(){return healthPoints;}
+	public int getMaxHealthPoints() {return maxHealthPoints;}
+	
+	
+	
+	
+	
+	
+	/////GENERAL GET/SET METHODS///////////////////////////
+	public String setEntityArray(String[][] entityArray){
+		if (entityArray == null)
+			return "Error No EntityArray Found!";
+		
+		if (entityArray.length*entityArray[0].length != 35*16)
+			return "Entity Array Not Expected Size";
+		
+		for (String[] row: entityArray){
+			for (String s:row)
+			{
+				if (s == null)
+					return "EntityArray cannot have null objects";
+			}
+		}
+		this.entityArray = entityArray;
+		
+		return null;}
+	
+	public String[][]getEntityArray(){return entityArray;}
+	
+	//Method helps check if entity is alive
+	public boolean getAlive(){return alive;}
+	
+	//Get name of entity
+	public String getName(){return name;}	
+	
+	//Get location of entity
+	public int[] getPosition(){
+		int[] position = new int[2];
+		position[0] = x;
+		position[1] = y;
+		return position;
+	}
+	
+	//Update Map on which entity stands on
+	public void setMap(BasicMap map){
+		this.map = map;
+	}	
+	
+	public void setName(String name){this.name = name;}
+	
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/playerRelated/Player.java b/Version 1.0(Current)/NewestVersion/src/playerRelated/Player.java
new file mode 100644
index 0000000..b5d51e1
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/playerRelated/Player.java	
@@ -0,0 +1,490 @@
+package playerRelated;
+
+import gameStates.GameScreen;
+import gameStates.GameScreenAssets;
+import managers.CombatManager;
+import managers.SoundManager;
+import mapRelated.BasicMap;
+import monsterRelated.Entity;
+
+import org.newdawn.slick.Animation;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.Input;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.SpriteSheet;
+import org.newdawn.slick.state.StateBasedGame;
+
+public class Player extends Entity{
+	
+	//Variables used for Slick 2 Game Components
+	private final GameContainer gc;
+	
+	//Used for stair case movement 
+	private boolean onStairs;
+	
+	//Variables used for Combat and related aspects
+	private int experiencePoints = 0;
+	private int pointsNextLevel = 10;
+	
+	private int playerLevel = 1;
+	private int criticalHitLimit= 30;
+	private int missFactor = 10;
+	
+	//Basic Sprite Variables
+	private SpriteSheet sheet;
+	private Animation currentSprite, up, down,left,right;
+
+	//Limited Vision Effect
+	private Image shadow;		
+	
+	////FOR TEST PURPOSES ONLY////
+	public Player (int x, int y){
+		super(x,y);
+		gc = null;
+		name = "P";
+	}
+	
+	public Player (int x, int y, BasicMap map){
+		super(x,y);
+		this.map = map;
+		gc = null;
+		name = "P";
+	}
+		
+	public void mockKeyBoard(char c){
+		switch(c) 
+		{
+		case 'u'://Up
+			moveUp();
+			break;
+		case 'd'://Down
+			moveDown();
+			break;
+		case 'l'://Left
+			moveLeft();
+			break;
+		case 'r'://Right
+			moveRight();
+			break;
+		case 'a'://Diagonal Up Left
+			moveDiagonalUpLeft();
+			break;
+		case 'b'://Diagonal Up Right
+			moveDiagonalUpRight();
+			break;
+		case 'c'://Diagonal Down Left
+			moveDiagonalDownLeft();
+			break;
+		case 'f'://Diagonal Down Right
+			moveDiagonalDownRight();
+			break;
+		case 'g':
+			moveNowhere();
+			break;
+		default:
+			break;
+		}
+		
+		
+	}
+	
+	
+	////FOR TEST PURPOSES ONLY////
+		
+		
+	public Player(GameContainer gc, StateBasedGame sbg, BasicMap currentMap,int x, int y) throws SlickException{
+		//Constructor used to 
+		super(x,y);
+		super.maxHealthPoints = 30;
+		super.healthPoints = maxHealthPoints;
+		
+		//Variables for the usage outside functions
+		this.gc = gc;
+		map = currentMap;
+		
+		//Initialize Variables
+		name = "P";
+		sheet = new SpriteSheet("res/player/template2.png", 32,32);
+		shadow = new Image("res/player/largerShadow.png");
+		loadPlayerSprite(sheet);
+		
+	}
+	
+	private void loadPlayerSprite(SpriteSheet playerSheet){
+				//Load Sprite Images for Player
+				Image [] upSprite = {sheet.getSubImage(0,3),
+								     sheet.getSubImage(1,3),
+								     sheet.getSubImage(2,3),
+								     sheet.getSubImage(3,3)};
+				Image [] downSprite = {sheet.getSubImage(0,0),
+					     			  sheet.getSubImage(1,0),
+					     			  sheet.getSubImage(2,0),
+					     			  sheet.getSubImage(3,0)};
+				Image [] rightSprite = {sheet.getSubImage(0,2),
+										sheet.getSubImage(1,2),
+										sheet.getSubImage(2,2),
+										sheet.getSubImage(3,2)};
+				
+				Image [] leftSprite = {sheet.getSubImage(0,1),
+					     			   sheet.getSubImage(1,1),
+					     			   sheet.getSubImage(2,1),
+					     			   sheet.getSubImage(3,1)};
+
+				//Set the duration of Animation in Milliseconds	
+				int [] duration = {300,300,300,300};
+				
+				//Initialize Animations
+				up = new Animation(upSprite, duration, false);
+				down = new Animation (downSprite, duration, false);
+				left = new Animation(leftSprite, duration, false);
+				right = new Animation (rightSprite,duration,false);		
+				currentSprite = down;
+				
+				//Allow animations to automatically play through
+				currentSprite.setAutoUpdate(true);
+				up.setAutoUpdate(true);
+				left.setAutoUpdate(true);
+				right.setAutoUpdate(true);
+	}
+	
+	
+	
+	public void render(Graphics g){
+	currentSprite.draw((int) x, (int) y);//Draw what the Current sprite should look like.
+	g.drawImage(shadow,(int)x-1110, (int)y-850); //Draw Shadow with a particular offset for the spotlight
+	}
+	
+	
+	public void update(long delta){
+		
+		//If the player is not alive change game state.
+		if (!alive){
+			return;
+		
+			}
+		
+		
+		
+		//Input used to get keyboard controls
+		Input input = gc.getInput();
+		 
+		//Diagonal Up Left
+		if (input.isKeyPressed(Input.KEY_NUMPAD7)||input.isKeyPressed(Input.KEY_7)){
+			 moveDiagonalUpLeft();
+		 }
+		
+		//Normal Up
+		else if (input.isKeyPressed(Input.KEY_UP)||input.isKeyPressed(Input.KEY_8)
+				||input.isKeyPressed(Input.KEY_NUMPAD8)){
+				moveUp();
+		}
+		
+		//Diagonal Up Right
+		else if (input.isKeyPressed(Input.KEY_NUMPAD9)||input.isKeyPressed(Input.KEY_9)){
+				moveDiagonalUpRight();
+		}
+
+		//Normal Left
+		else if (input.isKeyPressed(Input.KEY_LEFT)||input.isKeyPressed(Input.KEY_U)
+				||input.isKeyPressed(Input.KEY_NUMPAD4)){
+				moveLeft();
+		}
+		
+		//PASS TURN
+		else if (input.isKeyPressed(Input.KEY_NUMPAD5)||input.isKeyPressed(Input.KEY_I))
+			{
+			moveNowhere();
+			}
+		
+		//Normal Right
+		else if (input.isKeyPressed(Input.KEY_RIGHT)||input.isKeyPressed(Input.KEY_O)||
+				input.isKeyPressed(Input.KEY_NUMPAD6)){
+			moveRight();
+			}
+		
+		//Diagonal Down Left
+		else if (input.isKeyPressed(Input.KEY_NUMPAD1)||input.isKeyPressed(Input.KEY_J)){
+				moveDiagonalDownLeft();
+				}
+		
+		//Normal Down
+		else if (input.isKeyPressed(Input.KEY_DOWN)||input.isKeyPressed(Input.KEY_K)||
+				input.isKeyPressed(Input.KEY_NUMPAD2)){
+			moveDown();
+		}
+
+		//Diagonal Down Right
+		else if (input.isKeyPressed(Input.KEY_NUMPAD3)||input.isKeyPressed(Input.KEY_L)){
+			moveDiagonalDownRight();
+		}
+		 
+	}
+
+	
+////////////METHODS DEALING WITH MOVEMENT//////////////////////
+	
+	private void moveDiagonalUpLeft(){
+			 currentSprite = left;
+			int newX = x-BasicMap.TILESIZE;
+			int newY = y-BasicMap.TILESIZE;
+			if (isTaken(newX, newY))
+				attack(newX,newY);
+			else if (!(map.hasCollision(newX, newY)))
+				{
+				updatePosition(newX,newY);
+				x = newX;
+				y = newY;
+				
+				if (map.isStairs(x, y)){
+					onStairs = true;
+					}
+				if (map.isWin(x, y))
+					{
+					GameScreen.setWin(true);
+					}
+				}
+		 }
+	
+	
+	private void moveUp(){
+			currentSprite = up;
+			int newY = y - BasicMap.TILESIZE;
+			if (isTaken(x,newY))
+				attack(x, newY);
+			else if (!(map.hasCollision(x, newY))){
+				updatePosition(x,newY);
+				y = newY;
+				if (map.isStairs(x, y)){
+					onStairs = true;
+					}
+				if (map.isWin(x, y))
+				{
+				GameScreen.setWin(true);
+				}
+			
+			}
+			
+		}
+		
+		
+	private void moveDiagonalUpRight(){
+			currentSprite = right;
+			int newX = x + BasicMap.TILESIZE;
+			int newY = y - BasicMap.TILESIZE;
+			
+			if (isTaken(newX, newY))
+				attack(newX, newY);
+			else if (!(map.hasCollision(newX, newY)))	
+				{
+					updatePosition(newX,newY);
+					y = newY;
+					x = newX;	
+					if (map.isStairs(x, y)){
+						onStairs = true;
+						}
+					if (map.isWin(x, y))
+					{
+					GameScreen.setWin(true);
+					}
+				
+				}
+		}
+
+	private void moveLeft(){	
+			currentSprite = left;
+			int newX = x-BasicMap.TILESIZE;
+			if (isTaken(newX, y))
+				attack(newX,y);
+			else if (!(map.hasCollision(newX, y))){
+				updatePosition(newX,y);
+				x = newX;
+				if (map.isStairs(x, y)){
+					onStairs = true;
+					}
+				if (map.isWin(x, y))
+				{
+				GameScreen.setWin(true);
+				}
+			
+			}
+			
+		}
+		
+	private void moveNowhere()
+			{
+			currentSprite = down;
+			if (map.isStairs(x, y)){
+				onStairs = true;
+				}
+			if (map.isWin(x, y))
+			{
+			GameScreen.setWin(true);
+			}
+		
+			}
+		
+	private void moveRight(){
+			currentSprite = right;
+			int newX = x + BasicMap.TILESIZE;
+			if  (isTaken(newX, y))
+				attack(newX,y);
+			else if (!(map.hasCollision(newX, y))){
+				updatePosition(newX,y);
+				x = newX;
+				if (map.isStairs(x, y)){
+					onStairs = true;
+					}
+				if (map.isWin(x, y))
+				{
+				GameScreen.setWin(true);
+				}
+			
+				}
+			}	
+		
+		
+	private void moveDiagonalDownLeft(){
+				currentSprite = left;
+				int newX = x-BasicMap.TILESIZE;
+				int newY = y +BasicMap.TILESIZE;
+				if (isTaken(newX, newY))
+					attack(newX, newY);
+				else if (!(map.hasCollision(newX,  newY)))
+					{
+					updatePosition(newX,newY);
+					x = newX;
+					y = newY;
+					if (map.isStairs(x, y)){
+						onStairs = true;
+						}
+					if (map.isWin(x, y))
+					{
+					GameScreen.setWin(true);
+					}
+				
+					}
+				}
+				
+	private void moveDown(){
+			currentSprite = down;
+			int newY = y +BasicMap.TILESIZE;
+			if (isTaken(x, newY))
+				attack (x, newY);
+			else if (!(map.hasCollision(x, newY))){
+				updatePosition(x,newY);
+				y = newY;
+				if (map.isStairs(x, y)){
+					onStairs = true;
+					}
+				if (map.isWin(x, y))
+				{
+				GameScreen.setWin(true);
+				}
+			
+				}
+			
+			}
+
+	private void moveDiagonalDownRight(){
+			currentSprite = right;
+			int newX = x+BasicMap.TILESIZE;
+			int newY = y+BasicMap.TILESIZE;
+				if (isTaken(newX, newY)){
+					attack(newX, newY);
+				}
+				else if (!(map.hasCollision(newX,newY)))
+					{
+					updatePosition(newX,newY);
+					x = newX;
+					y = newY;
+					if (map.isStairs(x, y)){
+						onStairs = true;
+						}
+					if (map.isWin(x, y))
+					{
+					GameScreen.setWin(true);
+					}
+				
+					}
+			
+				}
+	
+///////////METHOD DEALING WITH LEVELING UP////////////////////
+	public String addExperiencePoints(int points){
+		if (points <0)
+			return "Can't gain negative EXP";
+		
+		//Add points given
+		experiencePoints += points;
+		if (levelUp())
+		{
+			GameScreenAssets.queueTextLog.add("Woohoo! Player has leveled Up!");
+			SoundManager.playSoundEffect("res/sound/SFX/Level Up Ding.wav");
+			return "Player has leveled up";
+		}
+		return null;
+	}
+	
+	//Method used when the player levels up
+	private boolean levelUp(){
+		
+		if (experiencePoints >= pointsNextLevel){
+			playerLevel++;
+			
+			//Increase Maximum Health & Heal Up Completely
+			maxHealthPoints += 50;
+			healthPoints = maxHealthPoints;
+			criticalHitLimit += 5;
+			if (missFactor > 5)
+				missFactor -= 1;
+			//Decrease Experience Points used up
+			//Increase amount needed to next level
+			experiencePoints = experiencePoints-pointsNextLevel;
+			pointsNextLevel *= 2;
+			return true;
+			}
+		return false;
+	}
+
+		
+	public int getCurrentLevel(){return playerLevel;}
+	
+	public int getExperiencePoints(){return experiencePoints;}
+	
+	public int getPointsNextLevel() {return pointsNextLevel;}
+///////////METHODS DEALING WITH COMBAT///////////////////	
+	
+	private void attack(int monsterX, int monsterY){
+	CombatManager.attackLoop(this,criticalHitLimit, missFactor, monsterX, monsterY);	
+	}
+	
+	
+//////////Method dealing with stairs///////////////
+
+	public boolean getOnStairs(){return onStairs;}
+	
+	public void setOnStairs(boolean var){onStairs = var;}
+
+	///Methods dealing loading////
+	//METHODS FOR LOADING
+	public void loadStats(int newLevel, int newExp, int newHealth)
+		{
+		playerLevel = newLevel;
+		experiencePoints = newExp;
+		pointsNextLevel = 10*(2*(newLevel));
+		maxHealthPoints = 30 + 50*(newLevel-1);
+		healthPoints = newHealth;
+		criticalHitLimit = 30+5*(newLevel-1);	
+		}
+		
+		
+		public void setPosition(int newX, int newY)
+		{
+			x = newX;
+			y = newY;
+		}
+	
+}
+
diff --git a/Version 1.0(Current)/NewestVersion/src/test/BasicMapTest.java b/Version 1.0(Current)/NewestVersion/src/test/BasicMapTest.java
new file mode 100644
index 0000000..4c948fa
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/test/BasicMapTest.java	
@@ -0,0 +1,48 @@
+package test;
+
+import static org.junit.Assert.*;
+import mapRelated.BasicMap;
+
+import org.junit.Test;
+
+public class BasicMapTest {
+
+	@Test
+	public void testHasCollision() {
+		char [][] test = new char [35][16];
+		test[3][4] = 'B';
+		BasicMap map = new BasicMap(test);
+		assertEquals(true, map.hasCollision(3*32,4*32));		
+		assertEquals(false, map.isStairs(4*32,6*32));
+		
+	}
+	
+	@Test
+	public void testIsStairs(){
+		char [][] test = new char [35][16];
+		test[3][4] = 'S';
+		BasicMap map = new BasicMap(test);
+		assertEquals(true, map.isStairs(3*32,4*32));		
+		assertEquals(false, map.isStairs(4*32,6*32));
+	}
+	
+	
+	@Test
+	public void testInvalidStairsInput(){
+		char [][] test = new char [35][16];
+		test [3][4] = 'S';
+		BasicMap map = new BasicMap(test);
+		assertEquals(false,map.isStairs(-40,-21));
+		
+	}
+	
+	@Test
+	public void testInvalidCollisioninput(){
+		char [][] test = new char [35][16];
+		test[3][4] = 'S';
+		BasicMap map = new BasicMap(test);
+		assertEquals(false, map.hasCollision(-40,-21));
+		
+	}
+	
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/test/BasicMonsterTest.java b/Version 1.0(Current)/NewestVersion/src/test/BasicMonsterTest.java
new file mode 100644
index 0000000..031383e
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/test/BasicMonsterTest.java	
@@ -0,0 +1,403 @@
+package test;
+
+import static org.junit.Assert.*;
+import mapRelated.BasicMap;
+import monsterRelated.BasicMonster;
+import monsterRelated.Entity;
+
+import org.junit.Test;
+import org.newdawn.slick.SlickException;
+
+public class BasicMonsterTest {
+	
+	
+	@Test
+	public void testGenericMove() throws SlickException{
+		//Arrange Data
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		String [][] test = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i < BasicMap.widthByTiles; i++){
+			for (int c = 0; c < BasicMap.heightByTiles; c++){
+				test [i][c] = " ";
+				testMap[i][c] = ' ';
+				}
+			}
+		BasicMap map = new BasicMap(testMap);
+		test[5][4] = "P";		
+		BasicMonster b = new BasicMonster (map, 7*32, 7*32, 0);
+		b.setEntityArray(test);
+		
+		//Act
+		int [] testPosition = {5*32,4*32};//Not in the way player
+		int [] monsterPos = {8*32, 7*32};//Monster's supposed current position
+			
+		//Assert
+		assertEquals(false, b.isTaken(8*32,7*32));
+		
+		//Act
+		b.update(testPosition,4000);//Move over by one.
+		
+		//Assert
+		assertArrayEquals(monsterPos, b.getPosition());
+		
+	}
+	
+	
+	@Test
+	public void testPlayerMissing(){
+		
+		//Arrange Data
+		BasicMap map = new BasicMap();
+		BasicMonster b = new BasicMonster (map, 4*32, 5*32, 0);
+		String [][] test = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i < BasicMap.widthByTiles; i++){
+			for (int c = 0; c < BasicMap.heightByTiles; c++){
+				test [i][c] = " ";
+				}
+			}
+		b.setEntityArray(test);
+		int[] testPosition = {5*BasicMap.TILESIZE, 8*BasicMap.TILESIZE};
+		assertEquals(false, ((Entity)b).isTaken(testPosition[0], testPosition[1]));
+		
+		//Assert and Act
+		assertEquals("Player has disappeared from the map.",b.update(testPosition,4000));//Has an error message.
+	
+	}
+	
+	@Test
+	public void testMonsterOverlappedPlayer(){
+		//Arrange Data
+				BasicMap map = new BasicMap();
+				BasicMonster b = new BasicMonster (map, 4*32, 5*32, 0);
+				String [][] test = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+				for (int i = 0; i < BasicMap.widthByTiles; i++){
+					for (int c = 0; c < BasicMap.heightByTiles; c++){
+						test [i][c] = " ";
+						}
+					}
+				
+				b.setEntityArray(test);
+				int[] testPosition = {5*BasicMap.TILESIZE, 8*BasicMap.TILESIZE};
+				assertEquals(false, ((Entity)b).isTaken(testPosition[0], testPosition[1]));
+				test[5][8] = "M";
+				//Assert and Act
+				assertEquals("Player has disappeared from the map.",b.update(testPosition,4000));//Has an error message.
+			
+		
+	}
+	
+	
+	
+	
+	@Test
+	public void testExpPointGain() throws SlickException{
+		BasicMap map = new BasicMap();
+		
+		BasicMonster m = new BasicMonster (map, 10,10,100);
+		assertEquals(1000, m.getMaxHealthPoints());
+		assertEquals(500, m.getExpPointGain());
+	}
+	
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////TESTS ABILITY TO SELECT A VALID SPOT WHEN NOT BLOCKED BY ANYTHING//////////////////////////////////
+
+
+	@Test
+	public void testMonsterDead(){	
+	String [][] testArray = new String [35][16];
+	char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+	testArray [4][5] = "P";
+	BasicMap map = new BasicMap(testMap);
+	BasicMonster m = new BasicMonster (map, 9*BasicMap.TILESIZE, 5*BasicMap.TILESIZE,100);
+	m.setEntityArray(testArray);
+    m.subtractHealth(1000);
+    
+    assertEquals(false, m.getAlive());
+	int [] playerPosition = {4*BasicMap.TILESIZE,5*BasicMap.TILESIZE};
+    m.update(playerPosition, 400);
+    int [] expectedPosition = {9*BasicMap.TILESIZE, 5*BasicMap.TILESIZE};
+    assertArrayEquals(expectedPosition, m.getPosition());
+	}
+
+	
+	
+	@Test
+	public void testFollowPlayerLeft() throws SlickException{
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		testArray[4][5] = "P";
+		int [] playerPosition = {4*BasicMap.TILESIZE,5*BasicMap.TILESIZE};
+		
+		BasicMap map = new BasicMap(testMap);
+		
+		BasicMonster b = new BasicMonster(map, 6*32, 5*32, 0);
+		b.setEntityArray(testArray);
+		int [] expected = {5*32,5*32};
+		
+		b.update(playerPosition, 400);
+		assertArrayEquals(expected, b.getPosition());
+	}
+	
+
+	@Test
+	public void testFollowPlayerBelow() throws SlickException{
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		testArray[5][7] = "P";
+		int [] playerPosition = {5*BasicMap.TILESIZE,7*BasicMap.TILESIZE};
+		
+		BasicMap map = new BasicMap(testMap);
+		
+		BasicMonster b = new BasicMonster(map, 5*32, 5*32, 0);
+		b.setEntityArray(testArray);
+		int [] expected = {5*32,6*32};
+		assertEquals(true, b.search("P"));
+		b.update(playerPosition, 400);
+		assertArrayEquals(expected, b.getPosition());
+	}
+	
+	@Test
+	public void testFollowPlayerRight() throws SlickException{
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		testArray[7][5] = "P";
+		int [] playerPosition = {7*BasicMap.TILESIZE,5*BasicMap.TILESIZE};
+		
+		BasicMap map = new BasicMap(testMap);
+		
+		BasicMonster b = new BasicMonster(map, 5*32, 5*32, 0);
+		b.setEntityArray(testArray);
+		int [] expected = {6*32,5*32};
+		assertEquals(true, b.search("P"));
+		b.update(playerPosition, 400);
+		assertArrayEquals(expected, b.getPosition());
+	}
+	
+	@Test
+	public void testFollowPlayerUp() throws SlickException{
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		testArray[5][7] = "P";
+		int [] playerPosition = {5*BasicMap.TILESIZE,7*BasicMap.TILESIZE};
+		
+		BasicMap map = new BasicMap(testMap);
+		
+		BasicMonster b = new BasicMonster(map, 5*32, 9*32, 0);
+		b.setEntityArray(testArray);
+		int [] expected = {5*32,8*32};
+		assertEquals(true, b.search("P"));
+		b.update(playerPosition, 400);
+		assertArrayEquals(expected, b.getPosition());
+	}
+	
+	@Test
+	public void testFollowPlayerDiagonalUpLeft() throws SlickException{
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		testArray[5][5] = "P";
+		int [] playerPosition = {5*BasicMap.TILESIZE,5*BasicMap.TILESIZE};
+		
+		BasicMap map = new BasicMap(testMap);
+		
+		BasicMonster b = new BasicMonster(map, 7*BasicMap.TILESIZE, 7*BasicMap.TILESIZE, 0);
+		b.setEntityArray(testArray);
+		int [] expected = {6*BasicMap.TILESIZE,6*BasicMap.TILESIZE};
+		assertEquals(true, b.search("P"));
+		b.update(playerPosition, 400);
+		assertArrayEquals(expected, b.getPosition());
+	}
+	
+	@Test
+	public void testFollowPlayerDiagonalUpRight() throws SlickException{
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		testArray[7][3] = "P";
+		int [] playerPosition = {7*BasicMap.TILESIZE,3*BasicMap.TILESIZE};
+		
+		BasicMap map = new BasicMap(testMap);
+		
+		BasicMonster b = new BasicMonster(map, 5*32, 5*32, 0);
+		b.setEntityArray(testArray);
+		int [] expected = {6*32,4*32};
+		assertEquals(true, b.search("P"));
+		b.update(playerPosition, 400);
+		assertArrayEquals(expected, b.getPosition());
+	}
+	
+	@Test
+	public void testFollowPlayerDiagonalDownLeft() throws SlickException{
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		testArray[5][9] = "P";
+		int [] playerPosition = {5*BasicMap.TILESIZE,9*BasicMap.TILESIZE};
+		
+		BasicMap map = new BasicMap(testMap);
+		
+		BasicMonster b = new BasicMonster(map, 7*BasicMap.TILESIZE, 7*BasicMap.TILESIZE, 0);
+		b.setEntityArray(testArray);
+		int [] expected = {6*BasicMap.TILESIZE,8*BasicMap.TILESIZE};
+		assertEquals(true, b.search("P"));
+		b.update(playerPosition, 400);
+		assertArrayEquals(expected, b.getPosition());
+	}
+	
+	@Test
+	public void testFollowPlayerDiagonalDownRight() throws SlickException{
+		//Arrange Data
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		testArray[7][9] = "P";
+		int [] playerPosition = {7*BasicMap.TILESIZE,9*BasicMap.TILESIZE};
+		
+		BasicMap map = new BasicMap(testMap);
+		
+		BasicMonster b = new BasicMonster(map, 5*32, 7*32, 0);
+		b.setEntityArray(testArray);
+		int [] expected = {6*32,8*32};		
+		assertEquals(true, b.search("P"));
+		
+		//Act
+		b.update(playerPosition, 400);
+		//Assert
+		assertArrayEquals(expected, b.getPosition());
+	}
+	
+	@Test
+	public void test_ChangeDirection(){
+		//Arrange Data
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		
+		testMap[8][7] = 'B';
+		testMap[6][7] = 'B';
+		testArray[7][9] = "P";
+		int [] playerPosition = {7*BasicMap.TILESIZE,9*BasicMap.TILESIZE};
+		
+		BasicMap map = new BasicMap(testMap);
+		
+		BasicMonster b = new BasicMonster(map, 5*32, 7*32, 0);
+		b.setEntityArray(testArray);
+		b.update(playerPosition, 400);
+		b.update(playerPosition, 400);
+		b.update(playerPosition, 400);
+		b.update(playerPosition, 400);
+		b.update(playerPosition, 400);
+		b.update(playerPosition, 400);
+		b.update(playerPosition, 400);
+		b.update(playerPosition, 400);
+		b.update(playerPosition, 400);
+		
+	}
+	
+	
+	public void testChangeDirection_Right(){
+		
+		fail("Not yet implemented");
+	}
+	
+	public void testChangeDirection_Left(){
+		
+		fail("Not yet implemented");
+		
+	}
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+/*
+ * Check change direction
+ * check player stops path
+ * Check Diagonal Wanders
+ * 
+ * 
+ */
+	
+
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/test/CombatManagerTest.java b/Version 1.0(Current)/NewestVersion/src/test/CombatManagerTest.java
new file mode 100644
index 0000000..3d16ce7
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/test/CombatManagerTest.java	
@@ -0,0 +1,41 @@
+package test;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.LinkedList;
+
+import managers.CombatManager;
+import mapRelated.BasicMap;
+import monsterRelated.BasicMonster;
+
+import org.junit.Test;
+
+import playerRelated.Player;
+
+public class CombatManagerTest {
+
+	
+	
+	
+	@Test
+	public void testMonsterRefNotFound(){
+		//Arrange
+		Player p = new Player(4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE);
+		//Act and Assert
+		assertEquals("Error! No Monster Found to Fight",CombatManager.attackLoop(p, 400, 10, 1, 2));
+	}
+	
+	@Test
+	public void testMonsterRefFound(){
+		//Arrange
+		Player p = new Player(4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE);
+		LinkedList<BasicMonster> testMonsterList = new LinkedList<BasicMonster>();
+		BasicMap map = new BasicMap();
+		BasicMonster m = new BasicMonster(map, 3*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, 4000);
+		testMonsterList.add(m);
+		CombatManager.setMonsterList(testMonsterList);
+		
+		//Act and assert
+		assertEquals(null, CombatManager.attackLoop(p, 300,10, 3*BasicMap.TILESIZE, 5*BasicMap.TILESIZE));
+	}
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/test/EntityTest.java b/Version 1.0(Current)/NewestVersion/src/test/EntityTest.java
new file mode 100644
index 0000000..033e50f
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/test/EntityTest.java	
@@ -0,0 +1,302 @@
+package test;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import mapRelated.BasicMap;
+import monsterRelated.Entity;
+
+import org.junit.Test;
+
+public class EntityTest {
+	
+///////ENTITY ARRAY TESTS///////////
+	
+	@Test
+	public void testValidEntityArray(){
+		
+			Entity e = new Entity(3*32,7*32);
+			
+			String [][] testArray = new String [35][16];
+
+			for (int i = 0; i < BasicMap.widthByTiles; i++)
+			{
+				for (int c = 0; c < BasicMap.heightByTiles; c++)
+				{
+					testArray[i][c] = " ";
+				}
+			}
+			
+			//Act and assert
+			assertEquals(null,e.setEntityArray(testArray));	
+	}
+	
+	@Test
+	public void test_Invalid_EntityArray_Size(){
+		Entity e = new Entity(3*32,4*32);
+		String [][] testArray = new String [25][15];
+		assertEquals("Entity Array Not Expected Size",e.setEntityArray(testArray));
+	}
+
+	@Test
+	public void test_Full_Of_Null_EntityArray(){
+		Entity e = new Entity(3*32,4*32);
+		String [][] testArray = new String [35][16];
+		assertEquals("EntityArray cannot have null objects", e.setEntityArray(testArray));
+		
+	}
+	@Test
+	public void test_NullReference_EntityArray(){
+		Entity e = new Entity (3*32, 4*32);
+		assertEquals("Error No EntityArray Found!", e.setEntityArray(null));
+	}
+	
+	
+
+//TEST SEARCH	
+	
+	@Test
+	public void testSearchOneCreature() {
+		//Arrange
+		Entity c = new Entity(4*32,4*32);
+		String [][] test = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+			{
+				test[i][d] = " ";
+			}
+		}
+		test[3][4] = "M";	
+		
+		//Act and Assert
+		assertEquals(null,c.setEntityArray(test));
+		
+		String[][] test1 = c.getEntityArray();
+		//Test if the we /definitely/ have the same array inside this creature
+		assertArrayEquals(test, test1);
+		//Test to see if there is a Player nearby
+		assertEquals(false, c.search("P"));
+		//Test to see if there is an 'M' or essentially if it can spot itself
+		assertEquals(true, c.search("M"));
+	}
+	
+	//Test update position
+	@Test
+	public void testInvalidPostion(){
+		Entity e = new Entity(5*32,5*32);
+		String [][] test = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+			{
+				test[i][d] = " ";
+			}
+		}
+		e.setEntityArray(test);
+		assertEquals("Out of Bounds", e.updatePosition(-100,-100));
+	}
+	
+	
+	
+	
+	
+	
+	@Test
+	public void testWanderCreature(){
+		//Arrange
+		Entity c = new Entity(3*32, 4*32);
+		c.setName("M");
+		String [][] test = new String[35][16];
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				test[i][d] = " ";
+		}
+		//Act
+		c.setEntityArray(test);
+		c.updatePosition(5*32, 7*32);
+		c.updatePosition(2*32, 4*32);
+		c.updatePosition(5*32, 5*32);
+		
+
+		String [][] test2 = new String[35][16];
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				test2[i][d] = " ";
+		}
+		test2[5][5] = "M";
+	
+		assertArrayEquals(test2,c.getEntityArray());
+		
+	}
+	
+	@Test
+	public void testSetPositionOneCreature(){
+		//Test Set-Up
+		Entity c = new Entity(3*32, 4*32);
+		c.setName("M");
+		//We /have/ to create an array with " " in every spot.
+		//Hence the terrible need for loop logic.
+		String [][] test = new String[35][16];
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				test[i][d] = " ";
+		}
+		//Writes an 'M' in a spot that we later erase.
+		test[3][4] = "M";
+		c.setEntityArray(test);
+		
+		//Updates the position of the creature
+		c.updatePosition(4*32, 4*32);
+		
+		//Create a blank another array to compare to
+		String[][] testEntity = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				testEntity[i][d] = " ";
+		}
+		//Manually store the new position
+		testEntity[4][4] = "M";
+		//Get the entityArray for this creature 
+		String[][] entityArray = c.getEntityArray();
+		//Check if they are the same.
+		assertArrayEquals(testEntity, entityArray);
+	}
+	
+	@Test
+	public void testTwoMovingCreatures(){
+		Entity c = new Entity(5*32,2*32);
+		Entity c2 = new Entity(7*32,9*32);
+		
+		String [][] testEntity = new String[BasicMap.widthByTiles][ BasicMap.heightByTiles];
+		
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				testEntity[i][d] = " ";
+		}
+		testEntity[3][5] = "T";
+		testEntity[5][5] = "B";
+		c.setEntityArray(testEntity);
+		c2.setEntityArray(testEntity);
+		
+		c.updatePosition(9*32, 9*32);
+		c2.updatePosition(5*32, 1*32);
+		
+		assertEquals(true, c2.isTaken(9*32, 9*32)); //C2 knows where the update position of c
+		assertArrayEquals(c.getEntityArray(), c2.getEntityArray());//They both have the same array
+		
+	}
+	
+	@Test
+	public void testIsTakenNegativeInput(){
+		Entity e = new Entity (4*32,5*32);
+		assertEquals(false, e.isTaken(-10,-20));	
+	}
+	
+
+	
+	@Test
+	public void testIsTakenOneCreature(){
+		//Set-Up Test
+		String[][] testEntity = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				testEntity[i][d] = " ";
+		}
+		testEntity[3][5] = "T";
+		Entity c = new Entity(3*32, 5*32);
+		c.setName("T");
+		c.setEntityArray(testEntity);
+		
+		//The entity array should know there is something in the array.
+		assertEquals(false, c.isTaken(4*32,5*32));
+		assertEquals(true,c.isTaken(3*32,5*32));
+	}
+	
+	@Test
+	public void testIsTakenTwoCreatures(){
+		String[][] testEntity = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				testEntity[i][d] = " ";
+		}
+		testEntity[3][5] = "T";
+		testEntity[5][5] = "B";
+		Entity c = new Entity(3*32, 5*32);
+		Entity c2 = new Entity(5*32, 5*32);
+		c.setName("T");
+		c.setName("B");
+		c.setEntityArray(testEntity);
+		c2.setEntityArray(testEntity);
+		//The entity array should know there is something in the array.
+		assertEquals(false, c.isTaken(4*32,5*32));
+		assertEquals(true,c.isTaken(5*32,5*32));
+		assertEquals(false, c2.isTaken(2*32, 6*32));
+		assertEquals(true, c.isTaken(3*32,5*32));
+	}
+	
+	
+	
+	
+///////////////////////////////////////////////////////////////////////////////////////////////	
+//Combat METHOD TESTS
+///////////////////////////////////////////////////////////////////////////////////////////////	
+	@Test
+	public void testSubtractNegativePoints(){
+		Entity e = new Entity (4,5);
+		assertEquals("Cannot subtract negative health points", e.subtractHealth(-10));		
+	}
+	
+	
+	
+	
+	@Test
+	public void testUpdateHealthPoints(){
+		Entity e = new Entity (4,5);
+		assertEquals(null, e.subtractHealth(10));
+		
+	}
+	
+	
+	@Test
+	public void testDead(){
+		Entity e = new Entity(4,5);
+		String [][] testArray = new String [35][16];
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+			}
+		}
+		e.setEntityArray(testArray);
+		e.subtractHealth(1000);
+		
+		assertEquals(false, e.getAlive());
+		assertEquals(0, e.getHealthPoints());
+	}
+	
+	
+	@Test
+	public void testAddValidHealthPoints(){
+		Entity e = new Entity(4,5);
+		assertEquals(null, e.addHealthPoints(10));
+		assertEquals(null, e.addHealthPoints(10));
+		assertEquals(30, e.getHealthPoints());
+	}
+	
+	@Test
+	public void testAddNegativeHealthPoints(){
+		Entity e = new Entity(4,5);
+		assertEquals("Cannot add negative health points", e.addHealthPoints(-50));	
+		
+	}
+	
+
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/test/GameScreenAssetsTest.java b/Version 1.0(Current)/NewestVersion/src/test/GameScreenAssetsTest.java
new file mode 100644
index 0000000..fbb9060
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/test/GameScreenAssetsTest.java	
@@ -0,0 +1,31 @@
+package test;
+
+import static org.junit.Assert.*;
+import gameStates.GameScreenAssets;
+
+import org.junit.Test;
+
+public class GameScreenAssetsTest {
+
+	
+	@Test
+	public void testTextLogCounter(){
+		GameScreenAssets game = new GameScreenAssets();
+		
+		assertEquals(1, game.updateTextLog(0));
+	}
+	
+	@Test
+	public void testTextLogUpdate(){
+		GameScreenAssets game = new GameScreenAssets();
+		assertEquals(0, game.updateTextLog(201));
+		
+	}
+	
+	@Test
+	public void testTextLogInvalidCounter(){
+		GameScreenAssets game = new GameScreenAssets();
+		assertEquals(0, game.updateTextLog(-100));
+		
+	}
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/test/MonsterManagerTest.java b/Version 1.0(Current)/NewestVersion/src/test/MonsterManagerTest.java
new file mode 100644
index 0000000..55f3eb1
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/test/MonsterManagerTest.java	
@@ -0,0 +1,376 @@
+package test;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import managers.MonsterManager;
+import mapRelated.BasicMap;
+
+import org.junit.Test;
+import org.newdawn.slick.SlickException;
+
+public class MonsterManagerTest {
+
+	@Test
+	public void testInvalidEntityArray(){
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [25][15];
+		assertEquals("Entity Array Not Expected Size",m.checkEntityArray(testArray));
+	}
+	
+	@Test
+	public void testNullEntityArray(){
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+		assertEquals("EntityArray cannot have null objects", m.checkEntityArray(testArray));
+		
+	}
+	
+	
+	@Test
+	public void testValidEntityArray(){
+		//Arrange
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+			}
+		}
+		testArray[4][5] = "P";
+		
+		//Act and assert
+		assertEquals(null,m.checkEntityArray(testArray));	
+	}
+
+	@Test
+	public void testPlayerNotInEntityArray(){
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+			}
+		}
+
+		assertEquals("Player has disappeared offf entityArray","Player not in EntityArray",m.checkEntityArray(testArray));	
+	}
+	
+	
+	@Test
+	public void testCheckValidPlacement(){
+		//Arrange
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+
+		//Double check that its a valid entity Array
+		assertEquals("Invalid Entity Array", m.setEntityArray(testArray));
+		testArray[5][7] = "P";
+		assertEquals(null, m.setEntityArray(testArray));
+		int [] testPosition = {4*BasicMap.TILESIZE,5*BasicMap.TILESIZE};
+		
+		
+		
+		
+		assertEquals(null, m.checkValidPlacement(testPosition, 4, new BasicMap(testMap), testArray));
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = 'B';
+			}
+		}
+		testMap[31][15] = ' ';
+		testMap[32][15] = ' ';
+		testMap[33][15] = ' ';
+		
+		testPosition[0] = 992;
+		testPosition[1] = 480;
+		assertEquals("Map Overlap", m.checkValidPlacement(testPosition, 4, new BasicMap (testMap), testArray));
+		
+	}
+
+	
+	@Test
+	public void testInvalidPositionGenerated(){
+		
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		BasicMap map = new BasicMap (testMap);
+		int [] newPosition = {-100,-100};
+		assertEquals("Out of Bounds", m.checkValidPlacement(newPosition, 4, map, testArray));
+		int [] thirdTestPosition = {1120, 512};
+		assertEquals("Out of Bounds", m.checkValidPlacement(thirdTestPosition, 4, map, testArray));
+	}
+	
+
+	
+	
+	
+	
+	@Test
+	public void testCheckOutOfBoundsPlacements(){
+		//Arrange
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap[i][c] = ' ';
+			}
+		}
+
+		//Double check that its a valid entity Array
+		assertEquals("Invalid Entity Array", m.setEntityArray(testArray));
+		testArray[5][7] = "P";
+		assertEquals(null, m.setEntityArray(testArray));
+		int [] testPosition = {2000,5};
+		
+			
+		assertEquals("Do not place monsters out of game's boundaries","Out of Bounds", m.checkValidPlacement(testPosition, 4, new BasicMap(testMap), testArray));
+	}
+
+	
+	
+	
+	@Test
+	public void testCheckEntityOverlap(){
+		//Arrange
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				 testMap[i][c] = ' ';
+				
+			}
+		}
+
+		//Double check that its a valid entity Array
+		assertEquals("Invalid Entity Array", m.setEntityArray(testArray));
+		testArray[5][7] = "P";
+		assertEquals(null, m.setEntityArray(testArray));
+		int [] testPosition = {5*BasicMap.TILESIZE,7*BasicMap.TILESIZE};
+				
+		assertEquals("Should be preventing placement over the player and other monsters","Entity Overlap", m.checkValidPlacement(testPosition, 4, new BasicMap(testMap), testArray));
+	}
+	
+	
+	@Test
+	public void testCheckMapOverlap(){
+		//Arrange
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap[i][c] = ' ';
+			}
+		}
+
+		//Double check that its a valid entity Array
+		assertEquals("Invalid Entity Array", m.setEntityArray(testArray));
+		testArray[5][7] = "P";
+		assertEquals(null, m.setEntityArray(testArray));
+		int [] testPosition = {9*BasicMap.TILESIZE,9*BasicMap.TILESIZE};
+		
+		
+		testMap[9][9] = 'B';
+		
+		assertEquals("We should be preventing placement that overlaps obstacles","Map Overlap", m.checkValidPlacement(testPosition, 4, new BasicMap(testMap), testArray));
+	}
+//	
+	@Test
+	public void testFindPlacement_NoBlocks (){
+		//Arrange
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap[i][c] = ' ';
+			}
+		}
+		int [] testPosition = m.findValidPlacement(4, new BasicMap(testMap), testArray);
+		
+		assertNotNull(testPosition);
+		
+	}
+
+	
+	@Test
+	public void testFindPlacement_OneSpotLeft_EntityArrayOnly (){
+		//Arrange
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = "M";
+				testMap[i][c] = ' ';
+			}
+		}
+		testArray[30][15] = " ";
+		testArray[31][15] = " ";
+		testArray[32][15] = " ";
+		testArray[33][15] = " ";
+		
+		MonsterManager m = new MonsterManager();
+		m.setEntityArray(testArray);
+		int [] testPosition = m.findValidPlacement(4, new BasicMap(testMap), testArray);
+		int [] expectedPosition = {30*BasicMap.TILESIZE,15*BasicMap.TILESIZE};
+		assertArrayEquals("Check that it can find Valid last spot",expectedPosition, testPosition);
+		
+	}
+	
+	@Test
+	public void testFindPlacement_OneSpotLeft_Edges(){
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = "M";
+				testMap[i][c] = ' ';
+			}
+		}
+		testArray[31][15] = " ";
+		testArray[32][15] = " ";
+		testArray[33][15] = " ";
+		testArray[34][15] = " ";
+		
+		MonsterManager m = new MonsterManager();
+		m.setEntityArray(testArray);
+		int [] testPosition = m.findValidPlacement(4, new BasicMap(testMap), testArray);
+		int [] expectedPosition = {31*BasicMap.TILESIZE,15*BasicMap.TILESIZE};
+		assertArrayEquals("Check that it can find corners",expectedPosition, testPosition);
+		
+		testArray[31][15] = "M";
+		testArray[32][15] = "M";
+		testArray[33][15] = "M";
+		testArray[34][15] = "M";
+	
+		testArray[34][12] = " ";
+		testArray[34][13] = " ";
+		testArray[34][14] = " ";
+		testArray[34][15] = " ";
+		testPosition = m.findValidPlacement(4, new BasicMap(testMap), testArray);
+		assertArrayEquals("Check that it cannot look vertically" ,null, testPosition);
+	}
+	
+	
+	
+	@Test
+	public void testFindPlacement_OneSpotLeft_MapArrayOnly (){
+		//Arrange
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap[i][c] = 'B';
+			}
+		}
+		
+		
+		testMap[30][15] = ' ';
+		testMap[31][15] = ' ';
+		testMap[32][15] = ' ';
+		testMap[33][15] = ' ';
+		
+		MonsterManager m = new MonsterManager();
+		int [] testPosition = m.findValidPlacement(4, new BasicMap(testMap), testArray);
+		int [] expectedPosition = {30*BasicMap.TILESIZE,15*BasicMap.TILESIZE};
+		assertArrayEquals("Check that it can see overlap with map",expectedPosition, testPosition);
+		
+	}
+
+	
+	
+	
+	@Test
+	public void testFindPlacement_NoSpotsLeft (){
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = "P";
+				testMap[i][c] = 'B';
+			}
+		}
+		int [] testPosition = new int [2];
+		testPosition = m.findValidPlacement(4, new BasicMap(testMap), testArray);
+		assertEquals( null, testPosition);
+	}
+	
+	
+	
+	@Test
+	public void testClearMonsters() throws SlickException{
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+			}
+		}
+		testArray[1][4] = "P";
+		assertEquals(null, m.setEntityArray(testArray));
+		assertEquals(null, m.clearMonsters());
+	}
+	
+}
diff --git a/Version 1.0(Current)/NewestVersion/src/test/PlayerTest.java b/Version 1.0(Current)/NewestVersion/src/test/PlayerTest.java
new file mode 100644
index 0000000..3589ced
--- /dev/null
+++ b/Version 1.0(Current)/NewestVersion/src/test/PlayerTest.java	
@@ -0,0 +1,133 @@
+package test;
+
+import static org.junit.Assert.*;
+
+
+import mapRelated.BasicMap;
+
+import org.junit.Test;
+
+import playerRelated.Player;
+
+public class PlayerTest {
+
+
+	
+	@Test
+	public void testExperiencePoints(){
+		Player player = new Player (10, 10);
+		player.addExperiencePoints(10);
+		assertEquals(0, player.getExperiencePoints());
+		assertEquals(20,player.getPointsNextLevel());
+		player.addExperiencePoints(20);
+		assertEquals(40,player.getPointsNextLevel());
+		player.addExperiencePoints(40);
+		assertEquals(80,player.getPointsNextLevel());
+		player.addExperiencePoints(80);
+		assertEquals(160,player.getPointsNextLevel());
+		player.addExperiencePoints(160);
+		assertEquals(320,player.getPointsNextLevel());	
+		player.addExperiencePoints(320);
+		assertEquals(640,player.getPointsNextLevel());	
+		assertEquals(7, player.getCurrentLevel());
+		
+	}
+
+	@Test
+	public void testNegativeExperiencePoints(){
+		//Arrange
+		Player player = new Player (10,10);		
+		assertEquals("Can't gain negative EXP",player.addExperiencePoints(-100));
+	}
+	@Test
+	public void test_NoLevelUp() {
+		Player player = new Player(10,10);
+		assertEquals(null, player.addExperiencePoints(1));
+	}
+	
+	
+	@Test 
+	public void testPlayerLevelUp(){
+		Player player = new Player (10,10);		
+		assertEquals("Player has leveled up",player.addExperiencePoints(2000));
+	}
+	
+	@Test
+	public void testPlayerMovement(){
+		
+		//Mock keyboard was call upon private method player movement
+		//The private methods would've originally been called depending on input from the keyboard
+		//In it's place characters have been used to individually call each method.
+		//Reflections (Private Objects for Java) proved to carry too many complications than it was worth.
+		
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		BasicMap map = new BasicMap(testMap);
+		Player p = new Player(4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, map);
+		p.setEntityArray(testArray);
+		int [] expected = {3*BasicMap.TILESIZE, 5*BasicMap.TILESIZE};
+		p.mockKeyBoard('l');
+		assertArrayEquals(expected, p.getPosition());
+		p.mockKeyBoard('r');
+		expected [0] = 4*BasicMap.TILESIZE;
+		assertArrayEquals(expected, p.getPosition());
+		expected [1] = 6*BasicMap.TILESIZE;
+		p.mockKeyBoard('d');
+		assertArrayEquals(expected, p.getPosition());
+		expected [1] = 5*BasicMap.TILESIZE;
+		p.mockKeyBoard('u');
+		assertArrayEquals(expected, p.getPosition());
+		
+		p.mockKeyBoard('a');
+		expected [0] -= BasicMap.TILESIZE;
+		expected [1] -= BasicMap.TILESIZE;
+		assertArrayEquals(expected, p.getPosition());
+		
+		p.mockKeyBoard('b');
+		expected [0] += BasicMap.TILESIZE;
+		expected [1] -= BasicMap.TILESIZE;
+		assertArrayEquals(expected, p.getPosition());
+		
+		p.mockKeyBoard('c');
+		expected [0] -= BasicMap.TILESIZE;
+		expected [1] += BasicMap.TILESIZE;
+		assertArrayEquals(expected, p.getPosition());
+		
+		
+		p.mockKeyBoard('f');
+		expected [0] += BasicMap.TILESIZE;
+		expected [1] += BasicMap.TILESIZE;
+		
+		assertArrayEquals(expected, p.getPosition());
+		p.mockKeyBoard('y');
+		assertArrayEquals(expected, p.getPosition());
+		p.mockKeyBoard('g');
+		assertArrayEquals(expected, p.getPosition());		
+	}
+	
+	/*
+	@Test
+	public void testPlayerMoveUp() throws SecurityException, NoSuchMethodException, IllegalAccessException,InvocationTargetException{
+		Player p = new Player(4*BasicMap.TILESIZE,5*BasicMap.TILESIZE);
+
+		Method privateUpMethod = Player.class.getDeclaredMethod("moveUp", String.class);
+
+		privateUpMethod.setAccessible(true);
+
+	    privateUpMethod.invoke(p, null);
+
+	}
+	*/	
+		
+		
+}
+
diff --git a/Version 1.0/NewestVersion/bin/gameStates/Game$1.class b/Version 1.0/NewestVersion/bin/gameStates/Game$1.class
new file mode 100644
index 0000000..d5d22fc
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/gameStates/Game$1.class differ
diff --git a/Version 1.0/NewestVersion/bin/gameStates/Game.class b/Version 1.0/NewestVersion/bin/gameStates/Game.class
new file mode 100644
index 0000000..1f1fc66
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/gameStates/Game.class differ
diff --git a/Version 1.0/NewestVersion/bin/gameStates/GameOver.class b/Version 1.0/NewestVersion/bin/gameStates/GameOver.class
new file mode 100644
index 0000000..fbe3090
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/gameStates/GameOver.class differ
diff --git a/Version 1.0/NewestVersion/bin/gameStates/GameScreenAssetsTest.class b/Version 1.0/NewestVersion/bin/gameStates/GameScreenAssetsTest.class
new file mode 100644
index 0000000..b95fb28
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/gameStates/GameScreenAssetsTest.class differ
diff --git a/Version 1.0/NewestVersion/bin/gameStates/LoadGame.class b/Version 1.0/NewestVersion/bin/gameStates/LoadGame.class
new file mode 100644
index 0000000..4773998
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/gameStates/LoadGame.class differ
diff --git a/Version 1.0/NewestVersion/bin/gameStates/Menu.class b/Version 1.0/NewestVersion/bin/gameStates/Menu.class
new file mode 100644
index 0000000..e387c71
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/gameStates/Menu.class differ
diff --git a/Version 1.0/NewestVersion/bin/inputRelated/AnimatedButton.class b/Version 1.0/NewestVersion/bin/inputRelated/AnimatedButton.class
new file mode 100644
index 0000000..48bcb3e
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/inputRelated/AnimatedButton.class differ
diff --git a/Version 1.0/NewestVersion/bin/inputRelated/BuildButton.class b/Version 1.0/NewestVersion/bin/inputRelated/BuildButton.class
new file mode 100644
index 0000000..c58b2b0
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/inputRelated/BuildButton.class differ
diff --git a/Version 1.0/NewestVersion/bin/inputRelated/GameOverButtons$1.class b/Version 1.0/NewestVersion/bin/inputRelated/GameOverButtons$1.class
new file mode 100644
index 0000000..c346a4d
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/inputRelated/GameOverButtons$1.class differ
diff --git a/Version 1.0/NewestVersion/bin/inputRelated/GameOverButtons$2.class b/Version 1.0/NewestVersion/bin/inputRelated/GameOverButtons$2.class
new file mode 100644
index 0000000..282a052
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/inputRelated/GameOverButtons$2.class differ
diff --git a/Version 1.0/NewestVersion/bin/inputRelated/GameOverButtons.class b/Version 1.0/NewestVersion/bin/inputRelated/GameOverButtons.class
new file mode 100644
index 0000000..cb7a1f3
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/inputRelated/GameOverButtons.class differ
diff --git a/Version 1.0/NewestVersion/bin/inputRelated/PopUpButtons$1.class b/Version 1.0/NewestVersion/bin/inputRelated/PopUpButtons$1.class
new file mode 100644
index 0000000..e26fdfb
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/inputRelated/PopUpButtons$1.class differ
diff --git a/Version 1.0/NewestVersion/bin/inputRelated/PopUpButtons$2.class b/Version 1.0/NewestVersion/bin/inputRelated/PopUpButtons$2.class
new file mode 100644
index 0000000..05c7b19
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/inputRelated/PopUpButtons$2.class differ
diff --git a/Version 1.0/NewestVersion/bin/inputRelated/PopUpButtons$3.class b/Version 1.0/NewestVersion/bin/inputRelated/PopUpButtons$3.class
new file mode 100644
index 0000000..2298360
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/inputRelated/PopUpButtons$3.class differ
diff --git a/Version 1.0/NewestVersion/bin/inputRelated/PopUpButtons.class b/Version 1.0/NewestVersion/bin/inputRelated/PopUpButtons.class
new file mode 100644
index 0000000..89e6154
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/inputRelated/PopUpButtons.class differ
diff --git a/Version 1.0/NewestVersion/bin/inputRelated/PopUpWindow.class b/Version 1.0/NewestVersion/bin/inputRelated/PopUpWindow.class
new file mode 100644
index 0000000..df5c65e
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/inputRelated/PopUpWindow.class differ
diff --git a/Version 1.0/NewestVersion/bin/managers/CombatManagerTest.class b/Version 1.0/NewestVersion/bin/managers/CombatManagerTest.class
new file mode 100644
index 0000000..e3df4f4
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/managers/CombatManagerTest.class differ
diff --git a/Version 1.0/NewestVersion/bin/managers/MonsterManagerTest.class b/Version 1.0/NewestVersion/bin/managers/MonsterManagerTest.class
new file mode 100644
index 0000000..687bbd4
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/managers/MonsterManagerTest.class differ
diff --git a/Version 1.0/NewestVersion/bin/mapRelated/BasicMapTest.class b/Version 1.0/NewestVersion/bin/mapRelated/BasicMapTest.class
new file mode 100644
index 0000000..8dc02a7
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/mapRelated/BasicMapTest.class differ
diff --git a/Version 1.0/NewestVersion/bin/monsterRelated/BasicMonsterTest.class b/Version 1.0/NewestVersion/bin/monsterRelated/BasicMonsterTest.class
new file mode 100644
index 0000000..4a9bf1f
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/monsterRelated/BasicMonsterTest.class differ
diff --git a/Version 1.0/NewestVersion/bin/monsterRelated/EntityTest.class b/Version 1.0/NewestVersion/bin/monsterRelated/EntityTest.class
new file mode 100644
index 0000000..370136f
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/monsterRelated/EntityTest.class differ
diff --git a/Version 1.0/NewestVersion/bin/monsterRelated/PrintingTests.class b/Version 1.0/NewestVersion/bin/monsterRelated/PrintingTests.class
new file mode 100644
index 0000000..b57b221
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/monsterRelated/PrintingTests.class differ
diff --git a/Version 1.0/NewestVersion/bin/playerRelated/Player.class b/Version 1.0/NewestVersion/bin/playerRelated/Player.class
index 9d21a80..78ac7ab 100644
Binary files a/Version 1.0/NewestVersion/bin/playerRelated/Player.class and b/Version 1.0/NewestVersion/bin/playerRelated/Player.class differ
diff --git a/Version 1.0/NewestVersion/bin/playerRelated/PlayerTest.class b/Version 1.0/NewestVersion/bin/playerRelated/PlayerTest.class
new file mode 100644
index 0000000..57335a9
Binary files /dev/null and b/Version 1.0/NewestVersion/bin/playerRelated/PlayerTest.class differ
diff --git a/Version 1.0/NewestVersion/res/interface/LoadGame2.png b/Version 1.0/NewestVersion/res/interface/LoadGame2.png
new file mode 100644
index 0000000..498ad6d
Binary files /dev/null and b/Version 1.0/NewestVersion/res/interface/LoadGame2.png differ
diff --git a/Version 1.0/NewestVersion/res/interface/MenuBlankSlate.png b/Version 1.0/NewestVersion/res/interface/MenuBlankSlate.png
new file mode 100644
index 0000000..7a11513
Binary files /dev/null and b/Version 1.0/NewestVersion/res/interface/MenuBlankSlate.png differ
diff --git a/Version 1.0/NewestVersion/res/interface/Sprial1.png b/Version 1.0/NewestVersion/res/interface/Sprial1.png
new file mode 100644
index 0000000..84309e0
Binary files /dev/null and b/Version 1.0/NewestVersion/res/interface/Sprial1.png differ
diff --git a/Version 1.0/NewestVersion/res/interface/loadGame.png b/Version 1.0/NewestVersion/res/interface/loadGame.png
new file mode 100644
index 0000000..0166675
Binary files /dev/null and b/Version 1.0/NewestVersion/res/interface/loadGame.png differ
diff --git a/Version 1.0/NewestVersion/res/interface/menu.png b/Version 1.0/NewestVersion/res/interface/menu.png
new file mode 100644
index 0000000..51ab7e0
Binary files /dev/null and b/Version 1.0/NewestVersion/res/interface/menu.png differ
diff --git a/Version 1.0/NewestVersion/res/interface/newGameButton1.png b/Version 1.0/NewestVersion/res/interface/newGameButton1.png
new file mode 100644
index 0000000..9186948
Binary files /dev/null and b/Version 1.0/NewestVersion/res/interface/newGameButton1.png differ
diff --git a/Version 1.0/NewestVersion/res/interface/newGameButton2.png b/Version 1.0/NewestVersion/res/interface/newGameButton2.png
new file mode 100644
index 0000000..244a767
Binary files /dev/null and b/Version 1.0/NewestVersion/res/interface/newGameButton2.png differ
diff --git a/Version 1.0/NewestVersion/res/interface/returnGame.png b/Version 1.0/NewestVersion/res/interface/returnGame.png
new file mode 100644
index 0000000..fc5353c
Binary files /dev/null and b/Version 1.0/NewestVersion/res/interface/returnGame.png differ
diff --git a/Version 1.0/NewestVersion/res/interface/returnGameMouseOver.png b/Version 1.0/NewestVersion/res/interface/returnGameMouseOver.png
new file mode 100644
index 0000000..881718b
Binary files /dev/null and b/Version 1.0/NewestVersion/res/interface/returnGameMouseOver.png differ
diff --git a/Version 1.0/NewestVersion/res/interface/sprial 3.png b/Version 1.0/NewestVersion/res/interface/sprial 3.png
new file mode 100644
index 0000000..b2e884a
Binary files /dev/null and b/Version 1.0/NewestVersion/res/interface/sprial 3.png differ
diff --git a/Version 1.0/NewestVersion/res/interface/sprial2.png b/Version 1.0/NewestVersion/res/interface/sprial2.png
new file mode 100644
index 0000000..84309e0
Binary files /dev/null and b/Version 1.0/NewestVersion/res/interface/sprial2.png differ
diff --git a/Version 1.0/NewestVersion/res/interface/test.png b/Version 1.0/NewestVersion/res/interface/test.png
new file mode 100644
index 0000000..781acdc
Binary files /dev/null and b/Version 1.0/NewestVersion/res/interface/test.png differ
diff --git a/Version 1.0/NewestVersion/res/interface/tester.png b/Version 1.0/NewestVersion/res/interface/tester.png
new file mode 100644
index 0000000..301db3a
Binary files /dev/null and b/Version 1.0/NewestVersion/res/interface/tester.png differ
diff --git a/Version 1.0/NewestVersion/save.txt b/Version 1.0/NewestVersion/save.txt
new file mode 100644
index 0000000..f0a5d59
--- /dev/null
+++ b/Version 1.0/NewestVersion/save.txt	
@@ -0,0 +1,12 @@
+1
+128
+160
+1
+0
+30
+800
+192
+10
+608
+192
+10
diff --git a/Version 1.0/NewestVersion/src/gameStates/Game.java b/Version 1.0/NewestVersion/src/gameStates/Game.java
new file mode 100644
index 0000000..9eb0401
--- /dev/null
+++ b/Version 1.0/NewestVersion/src/gameStates/Game.java	
@@ -0,0 +1,223 @@
+package gameStates;
+
+import inputRelated.ButtonAction;
+import inputRelated.LoadingGame;
+import inputRelated.SlideOutMenu;
+
+import java.util.LinkedList;
+
+import managers.CombatManager;
+import managers.MonsterManager;
+import managers.SoundManager;
+import mapRelated.BasicMap;
+import monsterRelated.Entity;
+
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.Input;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.openal.SoundStore;
+import org.newdawn.slick.state.BasicGameState;
+import org.newdawn.slick.state.StateBasedGame;
+
+import playerRelated.Player;
+
+public class Game extends BasicGameState {
+
+	//Used for quitting the game
+	private GameContainer gc;
+	private GameScreenAssets gameAssets;
+	
+	//Entity Stuff
+	private Player player;
+	private String[][] entityArray;
+	
+	//Handles Monsters on screen
+	private MonsterManager monsters;
+	
+	private BasicMap currentMap;
+	
+	//Counters for delaying textlog and monsters
+	private int textLogCounter = 0;//Must implement as private//Can possibly renamed Text log speed???
+
+	//Volume
+	private float volume = 1.0f;
+	
+	private LinkedList<BasicMap> totalLevels = new LinkedList<BasicMap>();
+	
+	
+	//State ID
+	public static final int ID = 1;
+
+	private boolean loadedGame = false;
+	
+	//Menu will put into game screen assets later.
+	SlideOutMenu menu;
+	
+	
+	
+	@Override
+	public void init(GameContainer gc, StateBasedGame stateGame) throws SlickException {
+		
+		if (loadedGame)
+			LoadingGame.initLoadingGame();
+		else{
+			
+		
+		//Used for changing game states
+		this.gc = gc;
+		gameAssets = new GameScreenAssets();
+
+        
+        //Draw Menu
+        menu = new SlideOutMenu(gc, stateGame, ID, new Image ("res/interface/menu2.png"), 1065, 50 );
+        menu.add(new ButtonAction(){ 
+    		public void perform(){
+    		//SoundManager.changeSound("res/sound/Play At Your Own Risk.wav");//I warned you. Not even sorry.	
+    		SoundManager.playSoundEffect("res/sound/SFX/Sword Swing.wav");
+    		}
+    		});
+    	
+		//Load ALL  Maps of game
+		//might move to map class???
+		BasicMap floorOne = new BasicMap("res/map/floor1.tmx");
+		BasicMap floorTwo = new BasicMap("res/map/floor2.tmx");
+		BasicMap floorThree = new BasicMap("res/map/floor3.tmx");
+		BasicMap floorFour = new BasicMap("res/map/floor4.tmx");
+		BasicMap floorFive = new BasicMap("res/map/floor5.tmx");
+		BasicMap floorSix = new BasicMap("res/map/floor6.tmx");
+		BasicMap floorSeven = new BasicMap("res/map/floor7.tmx");
+		//Add them to the Linked List, last level first.
+		totalLevels.add(floorSeven);
+		totalLevels.add(floorSix);
+		totalLevels.add(floorFive);
+        totalLevels.add(floorFour);
+		totalLevels.add(floorThree);
+		totalLevels.add(floorTwo);
+		totalLevels.add(floorOne);
+		//Get current map from the end.
+		currentMap = totalLevels.removeLast();
+		
+		
+		//Create player's character 
+		player = new Player(gc, stateGame,currentMap, 4*32, 5*32);
+		
+		//Place player's character onto map
+		initEntityArray();
+		
+		monsters = new MonsterManager(currentMap);
+		monsters.init(entityArray, currentMap);		
+		CombatManager.setMonsterList(monsters.getMonsterList());
+		
+		player.setEntityArray(monsters.getEntityArray());
+		
+		GameScreenAssets.statusUpdate = "Game is Now In Session";
+		}
+	}
+	
+	public void setLoadedGame(boolean value){loadedGame =value;}
+	
+	private void initEntityArray (){
+		String [][] newArray = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		entityArray = newArray;
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				entityArray[i][c] = " ";
+			}
+		}
+		entityArray[((Entity)player).getPosition()[0]/32][((Entity)player).getPosition()[1]/32] = player.getName();
+	}
+	
+	
+	@Override
+	public void render(GameContainer gc, StateBasedGame stateGame, Graphics g)
+			throws SlickException {
+		
+		//Render Map, Monsters, Player, GameScreen Assets
+		currentMap.render();
+		monsters.render(g);
+		player.render(g);
+		gameAssets.render(g, player);
+		menu.render(gc, g);
+		
+	}
+	
+	@Override
+	public void keyReleased (int key,char c){
+	switch (key){
+	case Input.KEY_Q:
+		gc.exit();//Exits game. 	
+		break;
+	case Input.KEY_1:
+		//Source of sound effect: https://www.freesound.org/people/JoelAudio/sounds/77611/
+		SoundManager.playSoundEffect("res/sound/SFX/Sword Swing.wav");
+		break;
+	case Input.KEY_M: 
+	case Input.KEY_ESCAPE:
+
+		//Put slide out menu here
+		
+		break;		
+	//Decrease volume
+	case Input.KEY_A:
+		volume -= 0.1f;
+        if (volume < 0.0f)
+           volume = 0.0f;
+		SoundStore.get().setSoundVolume(volume);
+		SoundStore.get().setMusicVolume(volume);
+		break;
+		
+	//Increase volume
+	case Input.KEY_S:
+		volume += 0.1f;
+        if (volume > 1.0f)
+           volume = 1.0f;
+        SoundStore.get().setSoundVolume(volume);
+        SoundStore.get().setMusicVolume(volume);
+
+		}
+	}
+
+	//Counters used to delay the text log and the movement of monsters
+	private int monsterCounter = 0; //Must combine later
+	
+	
+	@Override
+	public void update(GameContainer gc, StateBasedGame stateGame, int delta)
+			throws SlickException {
+		//Always let the player move.
+		player.update(monsterCounter);
+		
+		textLogCounter = gameAssets.updateTextLog(textLogCounter);
+		
+		//Prevent Monster from fleeing
+		if (monsters.getMonsterList()!= null){
+			monsters.update(player.getPosition(), monsterCounter);
+			monsterCounter++;
+			if (monsterCounter > 400)//Used to delay the monster's movement
+				monsterCounter = 0;
+			}
+		
+		//Load a new floor if the stairs are stepped on.
+		if (player.getOnStairs()&&totalLevels.peekLast()!= null){
+			currentMap = totalLevels.removeLast();
+			player.setMap(currentMap);
+			monsters.clearMonsters();
+			monsters.init(entityArray, currentMap);		
+			CombatManager.setMonsterList(monsters.getMonsterList());
+			player.setEntityArray(monsters.getEntityArray());
+			gameAssets.increaseFloorLevel();
+			SoundManager.changeSound("res/sound/Tank Battle.wav");
+			player.setOnStairs(false);
+		}
+	}
+	
+	@Override
+	public int getID() {
+		return ID;
+	}
+
+}
diff --git a/Version 1.0/NewestVersion/src/gameStates/GameOver.java b/Version 1.0/NewestVersion/src/gameStates/GameOver.java
new file mode 100644
index 0000000..7f81d35
--- /dev/null
+++ b/Version 1.0/NewestVersion/src/gameStates/GameOver.java	
@@ -0,0 +1,55 @@
+package gameStates;
+
+import java.awt.Font;
+
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Input;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.TrueTypeFont;
+import org.newdawn.slick.state.BasicGameState;
+import org.newdawn.slick.state.StateBasedGame;
+
+public class GameOver extends BasicGameState{
+	private TrueTypeFont font;
+	public static int ID = 3; 
+	private GameContainer gc;
+	@Override
+	public void init(GameContainer gc, StateBasedGame sbg)
+			throws SlickException {
+	    // load a default java font
+		this.gc = gc;
+	    Font awtFont = new Font("Times New Roman", Font.BOLD, 50);
+	    font = new TrueTypeFont(awtFont, false);		
+	}
+
+	@Override
+	public void render(GameContainer gc, StateBasedGame sbg, Graphics g)
+			throws SlickException {
+		//Draw Skull
+		font.drawString(300, 50, "GAME OVER!", Color.white);
+		g.setColor(Color.white);
+		g.drawString("Press 'Q' to quit",300,100);
+	}
+
+	@Override
+	public void update(GameContainer gc, StateBasedGame sbg, int delta)
+			throws SlickException {
+		
+	}
+	@Override
+	public void keyReleased (int key,char c){
+	switch (key){
+	case Input.KEY_Q:
+		gc.exit();//Exits game. 	
+		break;
+		}	
+	}
+
+	@Override
+	public int getID() {
+		return ID;
+	}
+
+}
diff --git a/Version 1.0/NewestVersion/src/gameStates/GameScreenAssetsTest.java b/Version 1.0/NewestVersion/src/gameStates/GameScreenAssetsTest.java
new file mode 100644
index 0000000..950616a
--- /dev/null
+++ b/Version 1.0/NewestVersion/src/gameStates/GameScreenAssetsTest.java	
@@ -0,0 +1,30 @@
+package gameStates;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+public class GameScreenAssetsTest {
+
+	
+	@Test
+	public void testTextLogCounter(){
+		GameScreenAssets game = new GameScreenAssets();
+		
+		assertEquals(1, game.updateTextLog(0));
+	}
+	
+	@Test
+	public void testTextLogUpdate(){
+		GameScreenAssets game = new GameScreenAssets();
+		assertEquals(0, game.updateTextLog(201));
+		
+	}
+	
+	@Test
+	public void testTextLogInvalidCounter(){
+		GameScreenAssets game = new GameScreenAssets();
+		assertEquals(0, game.updateTextLog(-100));
+		
+	}
+}
diff --git a/Version 1.0/NewestVersion/src/gameStates/LoadGame.java b/Version 1.0/NewestVersion/src/gameStates/LoadGame.java
new file mode 100644
index 0000000..a80a215
--- /dev/null
+++ b/Version 1.0/NewestVersion/src/gameStates/LoadGame.java	
@@ -0,0 +1,65 @@
+package gameStates;
+
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Input;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.state.BasicGameState;
+import org.newdawn.slick.state.StateBasedGame;
+
+//////////////////////////////////////////////////////////////////////////////////////
+//LoadGame																			//
+//Purpose: This class loads a saved game (after continue is selected)				//
+//Limit: Not yet Implemented														//
+//////////////////////////////////////////////////////////////////////////////////////
+
+public class LoadGame extends BasicGameState{
+
+	
+	private StateBasedGame game;
+	public static final int ID = 2;
+	@Override
+	public void init(GameContainer gc, StateBasedGame stateGame)
+			throws SlickException {
+		
+		this.game = stateGame;
+	}
+	
+	// Draws the game screen (UI, maps, etc)
+	@Override
+	public void render(GameContainer gc, StateBasedGame stateGame, Graphics g)
+			throws SlickException {
+		g.drawString("LOADING GAME...", 100, 50);
+		g.drawString("Press 'Q' to quit", 100, 0);
+
+	}
+
+	// Controls keyboard input
+	public void keyReleased (int key, char c){
+	switch (key){
+	case Input.KEY_Q:
+		GameContainer gc = game.getContainer();//Had to instantiate. I could've also made this another class variable.
+		gc.exit();//Exits game. 
+		break;
+		}	
+	}
+
+
+	//Updates the game screen
+	@Override
+	public void update(GameContainer gc, StateBasedGame stateGame, int delta)
+			throws SlickException {
+		
+		
+		
+	}
+
+	
+	//Returns ID of state for state manager that controls
+    //Flow of game
+	@Override
+	public int getID() {
+		return ID;
+	}
+
+}
diff --git a/Version 1.0/NewestVersion/src/gameStates/Menu.java b/Version 1.0/NewestVersion/src/gameStates/Menu.java
new file mode 100644
index 0000000..70804b7
--- /dev/null
+++ b/Version 1.0/NewestVersion/src/gameStates/Menu.java	
@@ -0,0 +1,63 @@
+package gameStates;
+
+import inputRelated.MainMenuButtons;
+
+import managers.SoundManager;
+
+import org.newdawn.slick.Animation;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.state.BasicGameState;
+import org.newdawn.slick.state.StateBasedGame;
+
+public class Menu extends BasicGameState {
+
+	
+	public static final int ID = 0; //Set the state's I.D 
+	private MainMenuButtons menuButtons;
+	
+	
+	
+	private Animation menuAnimation;
+	
+	@Override
+	public void init(GameContainer gc, StateBasedGame stateGame)
+			throws SlickException {
+		menuButtons = new MainMenuButtons(gc,stateGame);
+		Image [] menuImages = {new Image ("res/interface/design2.png"), new Image ("res/interface/design2slide2.png")}; 
+		int [] duration = {300,300};
+		menuAnimation = new Animation (menuImages, duration, false);
+		
+		
+		///Comment this back in if you want music.
+		SoundManager.changeSound("res/sound/Flying In The Face Of Hope.wav");
+	    
+		
+	}
+	
+	
+
+	@Override
+	public void render(GameContainer gc, StateBasedGame stateGame, Graphics g)
+			throws SlickException {
+		gc.setShowFPS(false); //FPS counter is hidden		
+		menuAnimation.draw(300,50);
+	    menuButtons.render(gc,g);//Renders the menu buttons
+	}
+
+	
+	@Override
+	public void update(GameContainer gc, StateBasedGame stateGame, int delta)
+			throws SlickException {
+			menuAnimation.update(delta);
+	}
+	
+	
+	@Override
+	public int getID() {
+		return ID;
+	}
+
+}
diff --git a/Version 1.0/NewestVersion/src/inputRelated/AnimatedButton.java b/Version 1.0/NewestVersion/src/inputRelated/AnimatedButton.java
new file mode 100644
index 0000000..6b43c67
--- /dev/null
+++ b/Version 1.0/NewestVersion/src/inputRelated/AnimatedButton.java	
@@ -0,0 +1,94 @@
+package inputRelated;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.newdawn.slick.Animation;
+import org.newdawn.slick.Color;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.gui.GUIContext;
+import org.newdawn.slick.gui.MouseOverArea;
+import org.newdawn.slick.state.StateBasedGame;
+
+public class AnimatedButton extends MouseOverArea {
+
+
+	//Source :https://evilzone.org/java/%28java-fames-tut%29-slick2d-buttons-buttons-buttons/
+	 private boolean activated = false;
+	 private boolean lastMouseOver = false;
+	 private final Animation animation;
+	 private final Image inactiveButton;
+	 private final Image activeButton;
+     private final StateBasedGame sbg;
+     private final int stateID;
+
+     private final List <ButtonAction> actions = new ArrayList <ButtonAction>();
+ 	
+     
+     public AnimatedButton(GUIContext container, Animation animation, int x, int y,
+			StateBasedGame sbg, int stateID, Image inactiveButton, Image activeButton) throws SlickException {
+		 	super(container, inactiveButton, x, y);
+	        super.setMouseDownColor(Color.white);
+	        super.setMouseOverColor(Color.yellow);
+	        this.animation = animation;
+	        this.sbg = sbg;
+	        this.stateID = stateID;
+	 
+	        this.inactiveButton = inactiveButton;
+	        this.activeButton = activeButton;
+	}
+	public void add(ButtonAction action){
+		actions.add(action);
+	}
+	
+	
+	 @Override
+	    public void mouseMoved(int oldx, int oldy, int newx, int newy) {
+	        if (sbg.getCurrentStateID() == stateID) {
+	            if (isMouseOver() && !lastMouseOver && !isActivated()) {
+	                lastMouseOver = true;
+	            } else if (!isMouseOver()) {
+	                lastMouseOver = false;
+	            }
+	        }
+	        super.mouseMoved(oldx, oldy, newx, newy);
+	    }
+	 
+	    @Override
+	    public void render(GUIContext guic, Graphics g) {
+	        if (activated) {
+	            g.drawImage(activeButton, getX() - 7, getY() - 5);
+	            g.drawAnimation(animation, getX() + 2, getY() + 2);
+	        } else {
+	            g.drawImage(inactiveButton, getX() - 7, getY() - 5);
+	            super.render(guic, g);
+	        }
+	    }
+	 
+	    public boolean isActivated() {
+	        return activated;
+	    }
+	 
+	    protected void setActivated(boolean b) {
+	        activated = b;
+	    }
+	    
+	
+	    @Override
+	    public void mouseClicked(int button, int x, int y, int clickCount) {
+	        if (isMouseOver() && sbg.getCurrentStateID() == stateID) {
+	            activated = !activated;
+	            for (ButtonAction action: actions){
+	            	action.perform();
+	            }
+	        }
+	        super.mouseClicked(button, x, y, clickCount);
+	    }
+	    
+	 
+}
+	
+	
+
diff --git a/Version 1.0/NewestVersion/src/inputRelated/BuildButton.java b/Version 1.0/NewestVersion/src/inputRelated/BuildButton.java
new file mode 100644
index 0000000..e6effa4
--- /dev/null
+++ b/Version 1.0/NewestVersion/src/inputRelated/BuildButton.java	
@@ -0,0 +1,38 @@
+package inputRelated;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.newdawn.slick.Animation;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.gui.GUIContext;
+import org.newdawn.slick.state.StateBasedGame;
+ 
+//Source :https://evilzone.org/java/%28java-fames-tut%29-slick2d-buttons-buttons-buttons/
+
+public class BuildButton extends BasicButton {
+ 
+    private static List<BuildButton> buttons = new ArrayList<BuildButton>();
+ 
+    public BuildButton(GUIContext guic, Animation animation, int x, int y, StateBasedGame sbg, int stateID, Image inactive, Image active)
+            throws SlickException {
+        super(guic, x, y, sbg, stateID, inactive, active);
+        buttons.add(this);
+    }
+ 
+    @Override
+    public void mouseClicked(int button, int x, int y, int clickCount) {
+        if (!isMouseOver()) {
+            // activate one button at a time
+            for (BuildButton b : buttons) {
+                if (b.isMouseOver()) {
+                    setActivated(false);
+                    break;
+                }
+            }
+        }
+        super.mouseClicked(button, x, y, clickCount);
+    }
+ 
+}
\ No newline at end of file
diff --git a/Version 1.0/NewestVersion/src/inputRelated/GameOverButtons.java b/Version 1.0/NewestVersion/src/inputRelated/GameOverButtons.java
new file mode 100644
index 0000000..dbfa040
--- /dev/null
+++ b/Version 1.0/NewestVersion/src/inputRelated/GameOverButtons.java	
@@ -0,0 +1,75 @@
+package inputRelated;
+
+import gameStates.GameOverScreen;
+import gameStates.GameScreen;
+import managers.SoundManager;
+
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.state.StateBasedGame;
+import org.newdawn.slick.state.transition.FadeInTransition;
+import org.newdawn.slick.state.transition.FadeOutTransition;
+
+public class GameOverButtons {
+
+	//Button Variables
+	private BasicButton quitGameButton;
+	private BasicButton newGameButton;
+	
+	
+	//Used to for the actions of the buttons
+	private StateBasedGame sbg;
+	private GameContainer gc;
+	
+	
+	public GameOverButtons (GameContainer container, StateBasedGame stateGame) throws SlickException{
+		
+		sbg = stateGame;
+		this.gc = container;
+		
+		
+		//Get the images of the buttons in their inactive/active states
+		Image activeNewGame = new Image("res/interface/newGame.png");
+		Image mouseOverNewGame = new Image("res/interface/newGameMouseOver.png");
+		Image activeQuitGame = new Image ("res/interface/exitGame.png");
+		Image mouseOverQuitGame = new Image("res/interface/exitGameMouseOver.png");
+		
+		newGameButton = new BasicButton(gc, 330, 350, 
+			    stateGame, GameOverScreen.ID, activeNewGame, activeNewGame);
+		quitGameButton = new BasicButton(gc, 540, 350, 
+				stateGame,  GameOverScreen.ID, activeQuitGame, activeQuitGame);
+		
+		newGameButton.setMouseOverImage(mouseOverNewGame);
+		 
+		quitGameButton.setMouseDownImage(mouseOverQuitGame);
+		quitGameButton.setMouseOverImage(mouseOverQuitGame);
+		
+		//Creates an anon class for the button's action.
+		newGameButton.add(new ButtonAction(){ 
+			public void perform(){
+			sbg.enterState(GameScreen.ID, new FadeOutTransition(Color.black), new FadeInTransition(Color.black));	
+			SoundManager.changeSound("res/sound/Catacombs.wav");
+			}
+			});
+		
+		//Creates an anon class for the button's action.
+		quitGameButton.add(new ButtonAction(){ 
+			public void perform(){
+				//Delete game/Over write old game here
+				((GameContainer)gc).exit();	
+			}
+		});
+		
+		}
+	
+	
+	
+	public void render(GameContainer gc, Graphics g){
+		 newGameButton.render(gc, g);//Draw the buttons on screen.
+		 quitGameButton.render(gc,g);
+	}
+	
+}
diff --git a/Version 1.0/NewestVersion/src/inputRelated/PopUpButtons.java b/Version 1.0/NewestVersion/src/inputRelated/PopUpButtons.java
new file mode 100644
index 0000000..d4f9427
--- /dev/null
+++ b/Version 1.0/NewestVersion/src/inputRelated/PopUpButtons.java	
@@ -0,0 +1,78 @@
+package inputRelated;
+
+import gameStates.Game;
+import gameStates.LoadGame;
+import gameStates.Menu;
+import managers.SoundManager;
+
+import org.newdawn.slick.Animation;
+import org.newdawn.slick.Color;
+import org.newdawn.slick.GameContainer;
+import org.newdawn.slick.Graphics;
+import org.newdawn.slick.Image;
+import org.newdawn.slick.SlickException;
+import org.newdawn.slick.state.StateBasedGame;
+import org.newdawn.slick.state.transition.FadeInTransition;
+import org.newdawn.slick.state.transition.FadeOutTransition;
+
+public class PopUpButtons {
+
+	//Initialize pop-up menu buttons
+	private AnimatedButton resumeButton;
+	private AnimatedButton saveButton;
+	private AnimatedButton quitButton;
+	
+	private Animation animationButton;
+	
+	private StateBasedGame sbg;
+	
+	public PopUpButtons (GameContainer gc, StateBasedGame stateGame) throws SlickException{
+		
+	sbg = stateGame;
+	
+	//Array instantiated to satisfy animated button class.
+	Image []  buttonImages = {new Image("res/interface/Sprial1.png")};
+	
+	//Duration of animation
+	int [] duration = {50};
+	animationButton = new Animation (buttonImages, duration,false);
+
+	//Get the images of the buttons in their inactive/active states
+	Image inactiveResume = new Image("PLACEHOLDER");
+	Image activeResume = new Image("PLACEHOLDER");
+	Image inactiveSave = new Image ("PLACEHOLDER");
+	Image activeSave = new Image("PLACEHOLDER");
+	Image activeQuit = new Image("PLACEHOLDER");
+	Image inactiveQuit = new Image("PLACEHOLDER");
+	
+	resumeButton = new AnimatedButton(gc, animationButton, 390, 350, stateGame, Menu.ID, inactiveResume, activeResume);
+	saveButton = new AnimatedButton(gc, animationButton, 590, 350, stateGame, Menu.ID, inactiveSave, activeSave);
+	quitButton = new AnimatedButton(gc, animationButton, 590, 350, stateGame, Menu.ID, inactiveQuit, activeQuit);
+
+	//Creates an anon class for the button's action.
+	resumeButton.add(new ButtonAction(){ 
+		public void perform(){
+				
+		}
+		});
+	
+	
+	//Creates an anon class for the button's action.
+	saveButton.add(new ButtonAction(){ 
+		public void perform(){
+				
+		}
+		});
+	quitButton.add(new ButtonAction(){
+		public void perform(){
+			
+		}
+		});
+	}
+	
+	public void render(GameContainer gc, Graphics g){
+		 resumeButton.render(gc, g);//Draw the buttons on screen.
+		 saveButton.render(gc,g);
+		 quitButton.render(gc,g);
+	}
+}
diff --git a/Version 1.0/NewestVersion/src/inputRelated/PopUpWindow.java b/Version 1.0/NewestVersion/src/inputRelated/PopUpWindow.java
new file mode 100644
index 0000000..d77a690
--- /dev/null
+++ b/Version 1.0/NewestVersion/src/inputRelated/PopUpWindow.java	
@@ -0,0 +1,28 @@
+package inputRelated;
+
+import javax.swing.JFrame;
+
+@SuppressWarnings("serial")
+public class PopUpWindow extends JFrame {
+	
+	public PopUpWindow(){
+		  setTitle("Simple example");
+	        setSize(300, 200);
+	        setLocationRelativeTo(null);
+	        setLocation(0,0);
+	        setDefaultCloseOperation(DISPOSE_ON_CLOSE);	
+	}
+	
+	
+	
+	
+	
+	
+	public void run(){
+		this.setVisible(true);
+		
+	}
+	
+	
+
+}
diff --git a/Version 1.0/NewestVersion/src/managers/CombatManagerTest.java b/Version 1.0/NewestVersion/src/managers/CombatManagerTest.java
new file mode 100644
index 0000000..e73a874
--- /dev/null
+++ b/Version 1.0/NewestVersion/src/managers/CombatManagerTest.java	
@@ -0,0 +1,40 @@
+package managers;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.LinkedList;
+
+import mapRelated.BasicMap;
+import monsterRelated.BasicMonster;
+
+import org.junit.Test;
+
+import playerRelated.Player;
+
+public class CombatManagerTest {
+
+	
+	
+	
+	@Test
+	public void testMonsterRefNotFound(){
+		//Arrange
+		Player p = new Player(4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE);
+		//Act and Assert
+		assertEquals("Error! No Monster Found to Fight",CombatManager.attackLoop(p, 400, 10, 1, 2));
+	}
+	
+	@Test
+	public void testMonsterRefFound(){
+		//Arrange
+		Player p = new Player(4*BasicMap.TILESIZE, 5*BasicMap.TILESIZE);
+		LinkedList<BasicMonster> testMonsterList = new LinkedList<BasicMonster>();
+		BasicMap map = new BasicMap();
+		BasicMonster m = new BasicMonster(map, 3*BasicMap.TILESIZE, 5*BasicMap.TILESIZE, 4000);
+		testMonsterList.add(m);
+		CombatManager.setMonsterList(testMonsterList);
+		
+		//Act and assert
+		assertEquals(null, CombatManager.attackLoop(p, 300,10, 3*BasicMap.TILESIZE, 5*BasicMap.TILESIZE));
+	}
+}
diff --git a/Version 1.0/NewestVersion/src/managers/MonsterManagerTest.java b/Version 1.0/NewestVersion/src/managers/MonsterManagerTest.java
new file mode 100644
index 0000000..3abf047
--- /dev/null
+++ b/Version 1.0/NewestVersion/src/managers/MonsterManagerTest.java	
@@ -0,0 +1,372 @@
+package managers;
+
+import static org.junit.Assert.*;
+import mapRelated.BasicMap;
+
+import org.junit.Test;
+
+public class MonsterManagerTest {
+
+	@Test
+	public void testInvalidEntityArray(){
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [25][15];
+		assertEquals("Entity Array Not Expected Size",m.checkEntityArray(testArray));
+	}
+	
+	@Test
+	public void testNullEntityArray(){
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+		assertEquals("EntityArray cannot have null objects", m.checkEntityArray(testArray));
+		
+	}
+	
+	
+	@Test
+	public void testValidEntityArray(){
+		//Arrange
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+			}
+		}
+		testArray[4][5] = "P";
+		
+		//Act and assert
+		assertEquals(null,m.checkEntityArray(testArray));	
+	}
+
+	@Test
+	public void testPlayerNotInEntityArray(){
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+			}
+		}
+
+		assertEquals("Player has disappeared offf entityArray","Player not in EntityArray",m.checkEntityArray(testArray));	
+	}
+	
+	
+	@Test
+	public void testCheckValidPlacement(){
+		//Arrange
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+
+		//Double check that its a valid entity Array
+		assertEquals("Invalid Entity Array", m.setEntityArray(testArray));
+		testArray[5][7] = "P";
+		assertEquals(null, m.setEntityArray(testArray));
+		int [] testPosition = {4*BasicMap.TILESIZE,5*BasicMap.TILESIZE};
+		
+		
+		
+		
+		assertEquals(null, m.checkValidPlacement(testPosition, 4, new BasicMap(testMap), testArray));
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = 'B';
+			}
+		}
+		testMap[31][15] = ' ';
+		testMap[32][15] = ' ';
+		testMap[33][15] = ' ';
+		
+		testPosition[0] = 992;
+		testPosition[1] = 480;
+		assertEquals("Map Overlap", m.checkValidPlacement(testPosition, 4, new BasicMap (testMap), testArray));
+		
+	}
+
+	
+	@Test
+	public void testInvalidPositionGenerated(){
+		
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		BasicMap map = new BasicMap (testMap);
+		int [] newPosition = {-100,-100};
+		assertEquals("Out of Bounds", m.checkValidPlacement(newPosition, 4, map, testArray));
+		int [] thirdTestPosition = {1120, 512};
+		assertEquals("Out of Bounds", m.checkValidPlacement(thirdTestPosition, 4, map, testArray));
+	}
+	
+
+	
+	
+	
+	
+	@Test
+	public void testCheckOutOfBoundsPlacements(){
+		//Arrange
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap[i][c] = ' ';
+			}
+		}
+
+		//Double check that its a valid entity Array
+		assertEquals("Invalid Entity Array", m.setEntityArray(testArray));
+		testArray[5][7] = "P";
+		assertEquals(null, m.setEntityArray(testArray));
+		int [] testPosition = {2000,5};
+		
+			
+		assertEquals("Do not place monsters out of game's boundaries","Out of Bounds", m.checkValidPlacement(testPosition, 4, new BasicMap(testMap), testArray));
+	}
+
+	
+	
+	
+	@Test
+	public void testCheckEntityOverlap(){
+		//Arrange
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				 testMap[i][c] = ' ';
+				
+			}
+		}
+
+		//Double check that its a valid entity Array
+		assertEquals("Invalid Entity Array", m.setEntityArray(testArray));
+		testArray[5][7] = "P";
+		assertEquals(null, m.setEntityArray(testArray));
+		int [] testPosition = {5*BasicMap.TILESIZE,7*BasicMap.TILESIZE};
+				
+		assertEquals("Should be preventing placement over the player and other monsters","Entity Overlap", m.checkValidPlacement(testPosition, 4, new BasicMap(testMap), testArray));
+	}
+	
+	
+	@Test
+	public void testCheckMapOverlap(){
+		//Arrange
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap[i][c] = ' ';
+			}
+		}
+
+		//Double check that its a valid entity Array
+		assertEquals("Invalid Entity Array", m.setEntityArray(testArray));
+		testArray[5][7] = "P";
+		assertEquals(null, m.setEntityArray(testArray));
+		int [] testPosition = {9*BasicMap.TILESIZE,9*BasicMap.TILESIZE};
+		
+		
+		testMap[9][9] = 'B';
+		
+		assertEquals("We should be preventing placement that overlaps obstacles","Map Overlap", m.checkValidPlacement(testPosition, 4, new BasicMap(testMap), testArray));
+	}
+//	
+	@Test
+	public void testFindPlacement_NoBlocks (){
+		//Arrange
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap[i][c] = ' ';
+			}
+		}
+		int [] testPosition = m.findValidPlacement(4, new BasicMap(testMap), testArray);
+		
+		assertNotNull(testPosition);
+		
+	}
+
+	
+	@Test
+	public void testFindPlacement_OneSpotLeft_EntityArrayOnly (){
+		//Arrange
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = "M";
+				testMap[i][c] = ' ';
+			}
+		}
+		testArray[30][15] = " ";
+		testArray[31][15] = " ";
+		testArray[32][15] = " ";
+		testArray[33][15] = " ";
+		
+		MonsterManager m = new MonsterManager();
+		m.setEntityArray(testArray);
+		int [] testPosition = m.findValidPlacement(4, new BasicMap(testMap), testArray);
+		int [] expectedPosition = {30*BasicMap.TILESIZE,15*BasicMap.TILESIZE};
+		assertArrayEquals("Check that it can find Valid last spot",expectedPosition, testPosition);
+		
+	}
+	
+	@Test
+	public void testFindPlacement_OneSpotLeft_Edges(){
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = "M";
+				testMap[i][c] = ' ';
+			}
+		}
+		testArray[31][15] = " ";
+		testArray[32][15] = " ";
+		testArray[33][15] = " ";
+		testArray[34][15] = " ";
+		
+		MonsterManager m = new MonsterManager();
+		m.setEntityArray(testArray);
+		int [] testPosition = m.findValidPlacement(4, new BasicMap(testMap), testArray);
+		int [] expectedPosition = {31*BasicMap.TILESIZE,15*BasicMap.TILESIZE};
+		assertArrayEquals("Check that it can find corners",expectedPosition, testPosition);
+		
+		testArray[31][15] = "M";
+		testArray[32][15] = "M";
+		testArray[33][15] = "M";
+		testArray[34][15] = "M";
+	
+		testArray[34][12] = " ";
+		testArray[34][13] = " ";
+		testArray[34][14] = " ";
+		testArray[34][15] = " ";
+		testPosition = m.findValidPlacement(4, new BasicMap(testMap), testArray);
+		assertArrayEquals("Check that it cannot look vertically" ,null, testPosition);
+	}
+	
+	
+	
+	@Test
+	public void testFindPlacement_OneSpotLeft_MapArrayOnly (){
+		//Arrange
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap[i][c] = 'B';
+			}
+		}
+		
+		
+		testMap[30][15] = ' ';
+		testMap[31][15] = ' ';
+		testMap[32][15] = ' ';
+		testMap[33][15] = ' ';
+		
+		MonsterManager m = new MonsterManager();
+		int [] testPosition = m.findValidPlacement(4, new BasicMap(testMap), testArray);
+		int [] expectedPosition = {30*BasicMap.TILESIZE,15*BasicMap.TILESIZE};
+		assertArrayEquals("Check that it can see overlap with map",expectedPosition, testPosition);
+		
+	}
+
+	
+	
+	
+	@Test
+	public void testFindPlacement_NoSpotsLeft (){
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = "P";
+				testMap[i][c] = 'B';
+			}
+		}
+		int [] testPosition = new int [2];
+		testPosition = m.findValidPlacement(4, new BasicMap(testMap), testArray);
+		assertEquals( null, testPosition);
+	}
+	
+	
+	
+	@Test
+	public void testClearMonsters(){
+		MonsterManager m = new MonsterManager();
+		String [][] testArray = new String [35][16];
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+			}
+		}
+		testArray[4][5] = "P";
+		assertEquals(null, m.setEntityArray(testArray));
+		assertEquals(null, m.clearMonsters());
+	}
+	
+}
diff --git a/Version 1.0/NewestVersion/src/mapRelated/BasicMapTest.java b/Version 1.0/NewestVersion/src/mapRelated/BasicMapTest.java
new file mode 100644
index 0000000..dfc93fc
--- /dev/null
+++ b/Version 1.0/NewestVersion/src/mapRelated/BasicMapTest.java	
@@ -0,0 +1,47 @@
+package mapRelated;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+public class BasicMapTest {
+
+	@Test
+	public void testHasCollision() {
+		char [][] test = new char [35][16];
+		test[3][4] = 'B';
+		BasicMap map = new BasicMap(test);
+		assertEquals(true, map.hasCollision(3*32,4*32));		
+		assertEquals(false, map.isStairs(4*32,6*32));
+		
+	}
+	
+	@Test
+	public void testIsStairs(){
+		char [][] test = new char [35][16];
+		test[3][4] = 'S';
+		BasicMap map = new BasicMap(test);
+		assertEquals(true, map.isStairs(3*32,4*32));		
+		assertEquals(false, map.isStairs(4*32,6*32));
+	}
+	
+	
+	@Test
+	public void testInvalidStairsInput(){
+		char [][] test = new char [35][16];
+		test [3][4] = 'S';
+		BasicMap map = new BasicMap(test);
+		assertEquals(false,map.isStairs(-40,-21));
+		
+	}
+	
+	@Test
+	public void testInvalidCollisioninput(){
+		char [][] test = new char [35][16];
+		test[3][4] = 'S';
+		BasicMap map = new BasicMap(test);
+		assertEquals(false, map.hasCollision(-40,-21));
+		
+	}
+	
+}
diff --git a/Version 1.0/NewestVersion/src/monsterRelated/BasicMonsterTest.java b/Version 1.0/NewestVersion/src/monsterRelated/BasicMonsterTest.java
new file mode 100644
index 0000000..db53781
--- /dev/null
+++ b/Version 1.0/NewestVersion/src/monsterRelated/BasicMonsterTest.java	
@@ -0,0 +1,149 @@
+package monsterRelated;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import mapRelated.BasicMap;
+
+import org.junit.Test;
+import org.newdawn.slick.SlickException;
+
+public class BasicMonsterTest {
+	
+	
+	@Test
+	public void testGenericMove() throws SlickException{
+		//Arrange Data
+		char [][] testMap = new char [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		String [][] test = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i < BasicMap.widthByTiles; i++){
+			for (int c = 0; c < BasicMap.heightByTiles; c++){
+				test [i][c] = " ";
+				testMap[i][c] = ' ';
+				}
+			}
+		BasicMap map = new BasicMap(testMap);
+		test[5][4] = "P";		
+		BasicMonster b = new BasicMonster (map, 7*32, 7*32, 0);
+		b.setEntityArray(test);
+		
+		//Act
+		int [] testPosition = {5*32,4*32};//Not in the way player
+		int [] monsterPos = {8*32, 7*32};//Monster's supposed current position
+			
+		//Assert
+		assertEquals(false, b.isTaken(8*32,7*32));
+		
+		//Act
+		b.update(testPosition,4000);//Move over by one.
+		
+		//Assert
+		assertArrayEquals(monsterPos, b.getPosition());
+		
+	}
+	
+	
+	@Test
+	public void testPlayerMissing(){
+		
+		//Arrange Data
+		BasicMap map = new BasicMap();
+		BasicMonster b = new BasicMonster (map, 4*32, 5*32, 0);
+		String [][] test = new String [BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i < BasicMap.widthByTiles; i++){
+			for (int c = 0; c < BasicMap.heightByTiles; c++){
+				test [i][c] = " ";
+				}
+			}
+		b.setEntityArray(test);
+		int[] testPosition = {5*BasicMap.TILESIZE, 8*BasicMap.TILESIZE};
+		assertEquals(false, b.isTaken(testPosition[0], testPosition[1]));
+		
+		//Assert and Act
+		assertEquals("Player has disappeared from the map.",b.update(testPosition,4000));//Has an error message.
+	
+	}
+	
+	@Test
+	public void testExpPointGain() throws SlickException{
+		BasicMap map = new BasicMap();
+		
+		BasicMonster m = new BasicMonster (map, 10,10,100);
+		assertEquals(1000, m.getMaxHealthPoints());
+		assertEquals(500, m.getExpPointGain());
+	}
+	
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////TESTS ABILITY TO SELECT A VALID SPOT WHEN NOT BLOCKED BY ANYTHING//////////////////////////////////
+	@Test
+	public void testClosestSpotNotNear() throws SlickException{
+		String [][] testArray = new String [35][16];
+		char [][] testMap = new char [35][16];
+		
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+				testMap [i][c] = ' ';
+			}
+		}
+		testArray[4][5] = "P";
+		int [] playerPosition = {4*BasicMap.TILESIZE,5*BasicMap.TILESIZE};
+		
+		BasicMap map = new BasicMap(testMap);
+		
+		BasicMonster b = new BasicMonster(map, 6*32, 5*32, 0);
+		b.setEntityArray(testArray);
+		int [] expected = {5*32,5*32};
+		
+		b.findClosestSpot( playerPosition);
+		
+		assertArrayEquals(expected, b.getPosition());
+	}
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+	
+	///////////////TESTS ABILITY TO NOT OVERLAP OBSTACLES///////////////////////////////////////////////////////////////////	
+//	@Test
+//	public void testClosestSpotNear() throws SlickException{
+//		
+//		fail("Not yet implemented");
+//	}
+//	
+//	public void testClosestSpotObstacle()throws SlickException{
+//			
+//			fail("Not yet implemented");
+//	}
+//		
+////////////////////////////////////////////////////////////////////////////////////////////////////	
+/////////////////////TESTS FOR BOUNDARIES IN CLOSEST SPOT//////////////////////////////////////////
+//	@Test
+//	public void testClosestSpotWallLeft()throws SlickException{
+//		
+//		fail("Not yet implemented");
+//	}
+//	
+//		
+//	
+//	@Test
+//	public void testClosestSpotWallRight()throws SlickException{
+//		
+//		fail("Not yet implemented");
+//	}
+//	
+//	public void testClosestSpotWallUp()throws SlickException{
+//		
+//		fail("Not yet implemented");
+//	}
+//	
+//	public void testClosestSpotWallDown()throws SlickException{
+//		
+//		fail("Not yet implemented");
+//	}
+//	
+//	
+//	
+//	
+//	
+
+}
diff --git a/Version 1.0/NewestVersion/src/monsterRelated/EntityTest.java b/Version 1.0/NewestVersion/src/monsterRelated/EntityTest.java
new file mode 100644
index 0000000..38cebec
--- /dev/null
+++ b/Version 1.0/NewestVersion/src/monsterRelated/EntityTest.java	
@@ -0,0 +1,292 @@
+package monsterRelated;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import mapRelated.BasicMap;
+
+import org.junit.Test;
+
+public class EntityTest {
+	
+///////ENTITY ARRAY TESTS///////////
+	
+	@Test
+	public void testValidEntityArray(){
+		
+			Entity e = new Entity(3*32,7*32);
+			
+			String [][] testArray = new String [35][16];
+
+			for (int i = 0; i < BasicMap.widthByTiles; i++)
+			{
+				for (int c = 0; c < BasicMap.heightByTiles; c++)
+				{
+					testArray[i][c] = " ";
+				}
+			}
+			
+			//Act and assert
+			assertEquals(null,e.setEntityArray(testArray));	
+	}
+	
+	@Test
+	public void testInvalidEntityArray(){
+		Entity e = new Entity(3*32,4*32);
+		String [][] testArray = new String [25][15];
+		assertEquals("Entity Array Not Expected Size",e.setEntityArray(testArray));
+	}
+
+	@Test
+	public void testNullEntityArray(){
+		Entity e = new Entity(3*32,4*32);
+		String [][] testArray = new String [35][16];
+		assertEquals("EntityArray cannot have null objects", e.setEntityArray(testArray));
+		
+	}
+	
+	
+
+//TEST SEARCH	
+	
+	@Test
+	public void testSearchOneCreature() {
+		//Arrange
+		Entity c = new Entity(4*32,4*32);
+		String [][] test = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+			{
+				test[i][d] = " ";
+			}
+		}
+		test[3][4] = "M";	
+		
+		//Act and Assert
+		assertEquals(null,c.setEntityArray(test));
+		
+		String[][] test1 = c.getEntityArray();
+		//Test if the we /definitely/ have the same array inside this creature
+		assertArrayEquals(test, test1);
+		//Test to see if there is a Player nearby
+		assertEquals(false, c.search("P"));
+		//Test to see if there is an 'M' or essentially if it can spot itself
+		assertEquals(true, c.search("M"));
+	}
+	
+	//Test update position
+	@Test
+	public void testInvalidPostion(){
+		Entity e = new Entity(5*32,5*32);
+		String [][] test = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+			{
+				test[i][d] = " ";
+			}
+		}
+		e.setEntityArray(test);
+		assertEquals("Out of Bounds", e.updatePosition(-100,-100));
+	}
+	
+	
+	
+	
+	
+	
+	@Test
+	public void testWanderCreature(){
+		//Arrange
+		Entity c = new Entity(3*32, 4*32);
+		c.name = "M";
+		String [][] test = new String[35][16];
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				test[i][d] = " ";
+		}
+		//Act
+		c.setEntityArray(test);
+		c.updatePosition(5*32, 7*32);
+		c.updatePosition(2*32, 4*32);
+		c.updatePosition(5*32, 5*32);
+		
+
+		String [][] test2 = new String[35][16];
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				test2[i][d] = " ";
+		}
+		test2[5][5] = "M";
+	
+		assertArrayEquals(test2,c.getEntityArray());
+		
+	}
+	
+	@Test
+	public void testSetPositionOneCreature(){
+		//Test Set-Up
+		Entity c = new Entity(3*32, 4*32);
+		c.name = "M";
+		//We /have/ to create an array with " " in every spot.
+		//Hence the terrible need for loop logic.
+		String [][] test = new String[35][16];
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				test[i][d] = " ";
+		}
+		//Writes an 'M' in a spot that we later erase.
+		test[3][4] = "M";
+		c.setEntityArray(test);
+		
+		//Updates the position of the creature
+		c.updatePosition(4*32, 4*32);
+		
+		//Create a blank another array to compare to
+		String[][] testEntity = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				testEntity[i][d] = " ";
+		}
+		//Manually store the new position
+		testEntity[4][4] = "M";
+		//Get the entityArray for this creature 
+		String[][] entityArray = c.getEntityArray();
+		//Check if they are the same.
+		assertArrayEquals(testEntity, entityArray);
+	}
+	
+	@Test
+	public void testTwoMovingCreatures(){
+		Entity c = new Entity(5*32,2*32);
+		Entity c2 = new Entity(7*32,9*32);
+		
+		String [][] testEntity = new String[BasicMap.widthByTiles][ BasicMap.heightByTiles];
+		
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				testEntity[i][d] = " ";
+		}
+		testEntity[3][5] = "T";
+		testEntity[5][5] = "B";
+		c.setEntityArray(testEntity);
+		c2.setEntityArray(testEntity);
+		
+		c.updatePosition(9*32, 9*32);
+		c2.updatePosition(5*32, 1*32);
+		
+		assertEquals(true, c2.isTaken(9*32, 9*32)); //C2 knows where the update position of c
+		assertArrayEquals(c.getEntityArray(), c2.getEntityArray());//They both have the same array
+		
+	}
+	
+	@Test
+	public void testIsTakenNegativeInput(){
+		Entity e = new Entity (4*32,5*32);
+		assertEquals(false, e.isTaken(-10,-20));	
+	}
+	
+	
+	
+	@Test
+	public void testIsTakenOneCreature(){
+		//Set-Up Test
+		String[][] testEntity = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				testEntity[i][d] = " ";
+		}
+		testEntity[3][5] = "T";
+		Entity c = new Entity(3*32, 5*32);
+		c.name = "T";
+		c.setEntityArray(testEntity);
+		
+		//The entity array should know there is something in the array.
+		assertEquals(false, c.isTaken(4*32,5*32));
+		assertEquals(true,c.isTaken(3*32,5*32));
+	}
+	
+	@Test
+	public void testIsTakenTwoCreatures(){
+		String[][] testEntity = new String[BasicMap.widthByTiles][BasicMap.heightByTiles];
+		for (int i = 0; i <BasicMap.widthByTiles; i++)
+		{
+			for (int d = 0; d < BasicMap.heightByTiles; d++)
+				testEntity[i][d] = " ";
+		}
+		testEntity[3][5] = "T";
+		testEntity[5][5] = "B";
+		Entity c = new Entity(3*32, 5*32);
+		Entity c2 = new Entity(5*32, 5*32);
+		c.name = "T";
+		c2.name = "B";
+		c.setEntityArray(testEntity);
+		c2.setEntityArray(testEntity);
+		//The entity array should know there is something in the array.
+		assertEquals(false, c.isTaken(4*32,5*32));
+		assertEquals(true,c.isTaken(5*32,5*32));
+		assertEquals(false, c2.isTaken(2*32, 6*32));
+		assertEquals(true, c.isTaken(3*32,5*32));
+	}
+	
+	
+///////////////////////////////////////////////////////////////////////////////////////////////	
+//Combat METHOD TESTS
+///////////////////////////////////////////////////////////////////////////////////////////////	
+	@Test
+	public void testSubtractNegativePoints(){
+		Entity e = new Entity (4,5);
+		assertEquals("Cannot subtract negative health points", e.subtractHealth(-10));		
+	}
+	
+	
+	
+	
+	@Test
+	public void testUpdateHealthPoints(){
+		Entity e = new Entity (4,5);
+		assertEquals(null, e.subtractHealth(10));
+		
+	}
+	@Test
+	public void testDead(){
+		Entity e = new Entity(4,5);
+		String [][] testArray = new String [35][16];
+		for (int i = 0; i < BasicMap.widthByTiles; i++)
+		{
+			for (int c = 0; c < BasicMap.heightByTiles; c++)
+			{
+				testArray[i][c] = " ";
+			}
+		}
+		e.setEntityArray(testArray);
+		e.subtractHealth(1000);
+		
+		assertEquals(false, e.getAlive());
+		assertEquals(0, e.getHealthPoints());
+	}
+	
+	
+	@Test
+	public void testAddValidHealthPoints(){
+		Entity e = new Entity(4,5);
+		assertEquals(null, e.addHealthPoints(10));
+		assertEquals(null, e.addHealthPoints(10));
+		assertEquals(30, e.getHealthPoints());
+	}
+	
+	@Test
+	public void testAddNegativeHealthPoints(){
+		Entity e = new Entity(4,5);
+		assertEquals("Cannot add negative health points", e.addHealthPoints(-50));	
+		
+	}
+	
+
+}
diff --git a/Version 1.0/NewestVersion/src/monsterRelated/PrintingTests.java b/Version 1.0/NewestVersion/src/monsterRelated/PrintingTests.java
new file mode 100644
index 0000000..6a29831
--- /dev/null
+++ b/Version 1.0/NewestVersion/src/monsterRelated/PrintingTests.java	
@@ -0,0 +1,49 @@
+package monsterRelated;
+
+import mapRelated.BasicMap;
+
+public class PrintingTests {
+	
+	///THIS IS A TERRIBLE TERRIBLE HABIT AND BAD PRACTICE WITH CODING
+	//BUT I LIKE PRINTING ALL VALUES IN ORDER TO NARROW DOWN THE PROBLEM OF THINGS
+	//So yeah....
+	
+	
+	public static void printEntityArray (String[][] entityArray){
+		System.out.println("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+		for (int i = 0; i < BasicMap.heightByTiles; i++)
+		{
+		
+			for (int c = 0; c < BasicMap.widthByTiles; c++){
+
+				System.out.print("|");
+				System.out.print(entityArray[c][i]);
+				System.out.print("|");
+			}	
+			System.out.println("");
+			System.out.println("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+			
+		}
+		
+	}
+
+	
+	public static void printCharArray (char[][] mapArray){
+		System.out.println("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+		for (int i = 0; i < BasicMap.heightByTiles; i++)
+		{
+		
+			for (int c = 0; c < BasicMap.widthByTiles; c++){
+
+				System.out.print("|");
+				System.out.print(mapArray[c][i]);
+				System.out.print("|");
+			}	
+			System.out.println("");
+			System.out.println("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
+			
+		}
+		
+	}
+
+}
diff --git a/Version 1.0/NewestVersion/src/playerRelated/Player.java b/Version 1.0/NewestVersion/src/playerRelated/Player.java
index 9720407..b5d51e1 100644
--- a/Version 1.0/NewestVersion/src/playerRelated/Player.java	
+++ b/Version 1.0/NewestVersion/src/playerRelated/Player.java	
@@ -477,7 +477,6 @@ public class Player extends Entity{
 		maxHealthPoints = 30 + 50*(newLevel-1);
 		healthPoints = newHealth;
 		criticalHitLimit = 30+5*(newLevel-1);	
-		missFactor = 10 - 5*(newLevel-1);
 		}
 		
 		
diff --git a/Version 1.0/NewestVersion/src/playerRelated/PlayerTest.java b/Version 1.0/NewestVersion/src/playerRelated/PlayerTest.java
new file mode 100644
index 0000000..47d7a4d
--- /dev/null
+++ b/Version 1.0/NewestVersion/src/playerRelated/PlayerTest.java	
@@ -0,0 +1,32 @@
+package playerRelated;
+
+import org.junit.Test;
+import org.newdawn.slick.SlickException;
+
+import static org.junit.Assert.*;
+
+public class PlayerTest {
+
+
+	
+	@Test
+	public void testExperiencePoints() throws SlickException{
+		Player player = new Player (10, 10);
+		player.addExperiencePoints(10);
+		assertEquals(0, player.getExperiencePoints());
+		assertEquals(20,player.getPointsNextLevel());
+	}
+
+	@Test
+	public void testNegativeExperiencePoints() throws SlickException{
+		//Arrange
+		Player player = new Player (10,10);		
+		assertEquals("Can't gain negative EXP",player.addExperiencePoints(-100));
+	}
+	
+	@Test 
+	public void testPlayerLevelUp() throws SlickException{
+		Player player = new Player (10,10);		
+		assertEquals("Player has leveled up",player.addExperiencePoints(2000));
+	}
+}

commit 377e7343eb1b843575385fdd88ee3eca7523173e
Author: Ihmayor <ihmayor@ucalgary.ca>
Date:   Tue Mar 31 22:04:12 2015 -0600

    MOST COMPLETED VERSION

diff --git a/Version 1.1/NewestVersion/.classpath b/Version 1.1/NewestVersion/.classpath
new file mode 100644
index 0000000..2bc554e
--- /dev/null
+++ b/Version 1.1/NewestVersion/.classpath	
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.7"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.USER_LIBRARY/Slick2D"/>
+	<classpathentry kind="lib" path="res"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/Version 1.1/NewestVersion/.project b/Version 1.1/NewestVersion/.project
new file mode 100644
index 0000000..6f00240
--- /dev/null
+++ b/Version 1.1/NewestVersion/.project	
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>NewestVersion</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/Version 1.1/NewestVersion/.settings/org.eclipse.jdt.core.prefs b/Version 1.1/NewestVersion/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..7341ab1
--- /dev/null
+++ b/Version 1.1/NewestVersion/.settings/org.eclipse.jdt.core.prefs	
@@ -0,0 +1,11 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.7
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.7
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.7
diff --git a/Version 1.1/NewestVersion/bin/gameStates/GameOverScreen.class b/Version 1.1/NewestVersion/bin/gameStates/GameOverScreen.class
new file mode 100644
index 0000000..5905a0a
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/gameStates/GameOverScreen.class differ
diff --git a/Version 1.1/NewestVersion/bin/gameStates/GameScreen.class b/Version 1.1/NewestVersion/bin/gameStates/GameScreen.class
new file mode 100644
index 0000000..c6fe944
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/gameStates/GameScreen.class differ
diff --git a/Version 1.1/NewestVersion/bin/gameStates/GameScreenAssets$1.class b/Version 1.1/NewestVersion/bin/gameStates/GameScreenAssets$1.class
new file mode 100644
index 0000000..749c8ab
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/gameStates/GameScreenAssets$1.class differ
diff --git a/Version 1.1/NewestVersion/bin/gameStates/GameScreenAssets.class b/Version 1.1/NewestVersion/bin/gameStates/GameScreenAssets.class
new file mode 100644
index 0000000..084dc5f
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/gameStates/GameScreenAssets.class differ
diff --git a/Version 1.1/NewestVersion/bin/gameStates/MainMenuScreen.class b/Version 1.1/NewestVersion/bin/gameStates/MainMenuScreen.class
new file mode 100644
index 0000000..d2eabbb
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/gameStates/MainMenuScreen.class differ
diff --git a/Version 1.1/NewestVersion/bin/gameStates/StateManager.class b/Version 1.1/NewestVersion/bin/gameStates/StateManager.class
new file mode 100644
index 0000000..4e49262
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/gameStates/StateManager.class differ
diff --git a/Version 1.1/NewestVersion/bin/gameStates/TransitionScreen.class b/Version 1.1/NewestVersion/bin/gameStates/TransitionScreen.class
new file mode 100644
index 0000000..59792a6
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/gameStates/TransitionScreen.class differ
diff --git a/Version 1.1/NewestVersion/bin/gameStates/Ver2GameDriver.class b/Version 1.1/NewestVersion/bin/gameStates/Ver2GameDriver.class
new file mode 100644
index 0000000..3b88f7a
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/gameStates/Ver2GameDriver.class differ
diff --git a/Version 1.1/NewestVersion/bin/gameStates/WinScreen.class b/Version 1.1/NewestVersion/bin/gameStates/WinScreen.class
new file mode 100644
index 0000000..b394ac3
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/gameStates/WinScreen.class differ
diff --git a/Version 1.1/NewestVersion/bin/inputRelated/BasicButton.class b/Version 1.1/NewestVersion/bin/inputRelated/BasicButton.class
new file mode 100644
index 0000000..6e4bb52
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/inputRelated/BasicButton.class differ
diff --git a/Version 1.1/NewestVersion/bin/inputRelated/ButtonAction.class b/Version 1.1/NewestVersion/bin/inputRelated/ButtonAction.class
new file mode 100644
index 0000000..c199b7a
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/inputRelated/ButtonAction.class differ
diff --git a/Version 1.1/NewestVersion/bin/inputRelated/EndGameButtons$1.class b/Version 1.1/NewestVersion/bin/inputRelated/EndGameButtons$1.class
new file mode 100644
index 0000000..60c2f35
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/inputRelated/EndGameButtons$1.class differ
diff --git a/Version 1.1/NewestVersion/bin/inputRelated/EndGameButtons$2.class b/Version 1.1/NewestVersion/bin/inputRelated/EndGameButtons$2.class
new file mode 100644
index 0000000..a2ecf1d
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/inputRelated/EndGameButtons$2.class differ
diff --git a/Version 1.1/NewestVersion/bin/inputRelated/EndGameButtons.class b/Version 1.1/NewestVersion/bin/inputRelated/EndGameButtons.class
new file mode 100644
index 0000000..0f8b20a
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/inputRelated/EndGameButtons.class differ
diff --git a/Version 1.1/NewestVersion/bin/inputRelated/LoadingGame.class b/Version 1.1/NewestVersion/bin/inputRelated/LoadingGame.class
new file mode 100644
index 0000000..cdbb856
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/inputRelated/LoadingGame.class differ
diff --git a/Version 1.1/NewestVersion/bin/inputRelated/MainMenuButtons$1.class b/Version 1.1/NewestVersion/bin/inputRelated/MainMenuButtons$1.class
new file mode 100644
index 0000000..9e5b977
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/inputRelated/MainMenuButtons$1.class differ
diff --git a/Version 1.1/NewestVersion/bin/inputRelated/MainMenuButtons$2.class b/Version 1.1/NewestVersion/bin/inputRelated/MainMenuButtons$2.class
new file mode 100644
index 0000000..623cf3b
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/inputRelated/MainMenuButtons$2.class differ
diff --git a/Version 1.1/NewestVersion/bin/inputRelated/MainMenuButtons.class b/Version 1.1/NewestVersion/bin/inputRelated/MainMenuButtons.class
new file mode 100644
index 0000000..765e8d4
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/inputRelated/MainMenuButtons.class differ
diff --git a/Version 1.1/NewestVersion/bin/inputRelated/SavingGame.class b/Version 1.1/NewestVersion/bin/inputRelated/SavingGame.class
new file mode 100644
index 0000000..e48347b
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/inputRelated/SavingGame.class differ
diff --git a/Version 1.1/NewestVersion/bin/inputRelated/SlideOutMenu$1.class b/Version 1.1/NewestVersion/bin/inputRelated/SlideOutMenu$1.class
new file mode 100644
index 0000000..11ad6b6
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/inputRelated/SlideOutMenu$1.class differ
diff --git a/Version 1.1/NewestVersion/bin/inputRelated/SlideOutMenu.class b/Version 1.1/NewestVersion/bin/inputRelated/SlideOutMenu.class
new file mode 100644
index 0000000..7529ee1
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/inputRelated/SlideOutMenu.class differ
diff --git a/Version 1.1/NewestVersion/bin/managers/CombatManager.class b/Version 1.1/NewestVersion/bin/managers/CombatManager.class
new file mode 100644
index 0000000..82b4254
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/managers/CombatManager.class differ
diff --git a/Version 1.1/NewestVersion/bin/managers/MonsterManager.class b/Version 1.1/NewestVersion/bin/managers/MonsterManager.class
new file mode 100644
index 0000000..3f59573
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/managers/MonsterManager.class differ
diff --git a/Version 1.1/NewestVersion/bin/managers/SoundManager.class b/Version 1.1/NewestVersion/bin/managers/SoundManager.class
new file mode 100644
index 0000000..1f9aaba
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/managers/SoundManager.class differ
diff --git a/Version 1.1/NewestVersion/bin/mapRelated/BasicMap.class b/Version 1.1/NewestVersion/bin/mapRelated/BasicMap.class
new file mode 100644
index 0000000..3158a7e
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/mapRelated/BasicMap.class differ
diff --git a/Version 1.1/NewestVersion/bin/monsterRelated/BasicMonster.class b/Version 1.1/NewestVersion/bin/monsterRelated/BasicMonster.class
new file mode 100644
index 0000000..ef5284a
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/monsterRelated/BasicMonster.class differ
diff --git a/Version 1.1/NewestVersion/bin/monsterRelated/Entity.class b/Version 1.1/NewestVersion/bin/monsterRelated/Entity.class
new file mode 100644
index 0000000..1fa6af2
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/monsterRelated/Entity.class differ
diff --git a/Version 1.1/NewestVersion/bin/playerRelated/Player.class b/Version 1.1/NewestVersion/bin/playerRelated/Player.class
new file mode 100644
index 0000000..4a52d45
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/playerRelated/Player.class differ
diff --git a/Version 1.1/NewestVersion/bin/test/BasicMapTest.class b/Version 1.1/NewestVersion/bin/test/BasicMapTest.class
new file mode 100644
index 0000000..ad12c64
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/test/BasicMapTest.class differ
diff --git a/Version 1.1/NewestVersion/bin/test/BasicMonsterTest.class b/Version 1.1/NewestVersion/bin/test/BasicMonsterTest.class
new file mode 100644
index 0000000..2d23a16
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/test/BasicMonsterTest.class differ
diff --git a/Version 1.1/NewestVersion/bin/test/CombatManagerTest.class b/Version 1.1/NewestVersion/bin/test/CombatManagerTest.class
new file mode 100644
index 0000000..7f7436b
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/test/CombatManagerTest.class differ
diff --git a/Version 1.1/NewestVersion/bin/test/EntityTest.class b/Version 1.1/NewestVersion/bin/test/EntityTest.class
new file mode 100644
index 0000000..88a36b6
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/test/EntityTest.class differ
diff --git a/Version 1.1/NewestVersion/bin/test/GameScreenAssetsTest.class b/Version 1.1/NewestVersion/bin/test/GameScreenAssetsTest.class
new file mode 100644
index 0000000..fb37f16
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/test/GameScreenAssetsTest.class differ
diff --git a/Version 1.1/NewestVersion/bin/test/MonsterManagerTest.class b/Version 1.1/NewestVersion/bin/test/MonsterManagerTest.class
new file mode 100644
index 0000000..e17b806
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/test/MonsterManagerTest.class differ
diff --git a/Version 1.1/NewestVersion/bin/test/PlayerTest.class b/Version 1.1/NewestVersion/bin/test/PlayerTest.class
new file mode 100644
index 0000000..10bb954
Binary files /dev/null and b/Version 1.1/NewestVersion/bin/test/PlayerTest.class differ
diff --git a/Version 1.1/NewestVersion/res/interface/MorrisRoman-Black.ttf b/Version 1.1/NewestVersion/res/interface/MorrisRoman-Black.ttf
new file mode 100644
index 0000000..791f725
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/MorrisRoman-Black.ttf differ
diff --git a/Version 1.1/NewestVersion/res/interface/MorrisRomanAlternate-Black.ttf b/Version 1.1/NewestVersion/res/interface/MorrisRomanAlternate-Black.ttf
new file mode 100644
index 0000000..c93fbbf
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/MorrisRomanAlternate-Black.ttf differ
diff --git a/Version 1.1/NewestVersion/res/interface/Sketch Gothic School.ttf b/Version 1.1/NewestVersion/res/interface/Sketch Gothic School.ttf
new file mode 100644
index 0000000..ab77776
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/Sketch Gothic School.ttf differ
diff --git a/Version 1.1/NewestVersion/res/interface/Thumbs.db b/Version 1.1/NewestVersion/res/interface/Thumbs.db
new file mode 100644
index 0000000..3a6310b
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/Thumbs.db differ
diff --git a/Version 1.1/NewestVersion/res/interface/continueActive.png b/Version 1.1/NewestVersion/res/interface/continueActive.png
new file mode 100644
index 0000000..3a165d7
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/continueActive.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/continueInActive.png b/Version 1.1/NewestVersion/res/interface/continueInActive.png
new file mode 100644
index 0000000..d368d99
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/continueInActive.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/continueMouseOver.png b/Version 1.1/NewestVersion/res/interface/continueMouseOver.png
new file mode 100644
index 0000000..5766450
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/continueMouseOver.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/controls.png b/Version 1.1/NewestVersion/res/interface/controls.png
new file mode 100644
index 0000000..49142a8
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/controls.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/controls2.png b/Version 1.1/NewestVersion/res/interface/controls2.png
new file mode 100644
index 0000000..79080b1
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/controls2.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/ember1.png b/Version 1.1/NewestVersion/res/interface/ember1.png
new file mode 100644
index 0000000..e662be9
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/ember1.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/ember2.png b/Version 1.1/NewestVersion/res/interface/ember2.png
new file mode 100644
index 0000000..5add1a5
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/ember2.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/ember3.png b/Version 1.1/NewestVersion/res/interface/ember3.png
new file mode 100644
index 0000000..31c3648
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/ember3.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/ember4.png b/Version 1.1/NewestVersion/res/interface/ember4.png
new file mode 100644
index 0000000..ae314d2
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/ember4.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/exitGameActive.png b/Version 1.1/NewestVersion/res/interface/exitGameActive.png
new file mode 100644
index 0000000..d8f7b94
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/exitGameActive.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/exitGameMouseOver.png b/Version 1.1/NewestVersion/res/interface/exitGameMouseOver.png
new file mode 100644
index 0000000..5a2aab4
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/exitGameMouseOver.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/mainMenu1.png b/Version 1.1/NewestVersion/res/interface/mainMenu1.png
new file mode 100644
index 0000000..f34af79
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/mainMenu1.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/mainMenu2.png b/Version 1.1/NewestVersion/res/interface/mainMenu2.png
new file mode 100644
index 0000000..4ed2ea6
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/mainMenu2.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/mainMenu3.png b/Version 1.1/NewestVersion/res/interface/mainMenu3.png
new file mode 100644
index 0000000..0c611c5
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/mainMenu3.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/miniMenu.png b/Version 1.1/NewestVersion/res/interface/miniMenu.png
new file mode 100644
index 0000000..755b80f
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/miniMenu.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/newGameActive.png b/Version 1.1/NewestVersion/res/interface/newGameActive.png
new file mode 100644
index 0000000..1ffd201
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/newGameActive.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/newGameMouseOver.png b/Version 1.1/NewestVersion/res/interface/newGameMouseOver.png
new file mode 100644
index 0000000..323ec7e
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/newGameMouseOver.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/panic.png b/Version 1.1/NewestVersion/res/interface/panic.png
new file mode 100644
index 0000000..e2f6627
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/panic.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/playerSkipIntroSlide.png b/Version 1.1/NewestVersion/res/interface/playerSkipIntroSlide.png
new file mode 100644
index 0000000..348175f
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/playerSkipIntroSlide.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/saveExit.png b/Version 1.1/NewestVersion/res/interface/saveExit.png
new file mode 100644
index 0000000..f1c7142
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/saveExit.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/saveExitMouseOver.png b/Version 1.1/NewestVersion/res/interface/saveExitMouseOver.png
new file mode 100644
index 0000000..7305f79
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/saveExitMouseOver.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/skull.png b/Version 1.1/NewestVersion/res/interface/skull.png
new file mode 100644
index 0000000..ee30520
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/skull.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/winAnimation1.png b/Version 1.1/NewestVersion/res/interface/winAnimation1.png
new file mode 100644
index 0000000..bef5b12
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/winAnimation1.png differ
diff --git a/Version 1.1/NewestVersion/res/interface/winAnimation2.png b/Version 1.1/NewestVersion/res/interface/winAnimation2.png
new file mode 100644
index 0000000..74650c3
Binary files /dev/null and b/Version 1.1/NewestVersion/res/interface/winAnimation2.png differ
diff --git a/Version 1.1/NewestVersion/res/map/32x32.bmp b/Version 1.1/NewestVersion/res/map/32x32.bmp
new file mode 100644
index 0000000..baf1eec
Binary files /dev/null and b/Version 1.1/NewestVersion/res/map/32x32.bmp differ
diff --git a/Version 1.1/NewestVersion/res/map/Thumbs.db b/Version 1.1/NewestVersion/res/map/Thumbs.db
new file mode 100644
index 0000000..ce0e33b
Binary files /dev/null and b/Version 1.1/NewestVersion/res/map/Thumbs.db differ
diff --git a/Version 1.1/NewestVersion/res/map/clifveg2.bmp b/Version 1.1/NewestVersion/res/map/clifveg2.bmp
new file mode 100644
index 0000000..0002313
Binary files /dev/null and b/Version 1.1/NewestVersion/res/map/clifveg2.bmp differ
diff --git a/Version 1.1/NewestVersion/res/map/floor1.tmx b/Version 1.1/NewestVersion/res/map/floor1.tmx
new file mode 100644
index 0000000..55f24d1
--- /dev/null
+++ b/Version 1.1/NewestVersion/res/map/floor1.tmx	
@@ -0,0 +1,50 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="35" height="16" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="clifveg2" tilewidth="32" tileheight="32">
+  <image source="clifveg2.bmp" trans="5555ff" width="640" height="480"/>
+ </tileset>
+ <tileset firstgid="301" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="tilea2.png" width="512" height="384"/>
+ </tileset>
+ <tileset firstgid="493" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="0">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="24">
+   <properties>
+    <property name="stairs" value="tru"/>
+   </properties>
+  </tile>
+ </tileset>
+ <layer name="Tile Layer 1" width="35" height="16">
+  <properties>
+   <property name="blocked" value="false"/>
+  </properties>
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC+2TSwqAMBBDR73ECJ7Se7voDVyoUMN8S8WFLh5oDTadpGUgKh9kpgN8Ro2mf8JLTVQjrWfxvGW8LCcsrGUy6eGFYW8O+rDy9+bmaer90cvlWftHNjuG7+toa5nu8+vdYStHaU4XLV4ivUHf0V719KJlrL1b/cn20Tqzl2mdD2oZiN6X7F2qu9vSE+2Mk3FP3mL7EdkBu24TysAIAAA=
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.1/NewestVersion/res/map/floor2.tmx b/Version 1.1/NewestVersion/res/map/floor2.tmx
new file mode 100644
index 0000000..fe81ffd
--- /dev/null
+++ b/Version 1.1/NewestVersion/res/map/floor2.tmx	
@@ -0,0 +1,55 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="35" height="16" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="clifveg2" tilewidth="32" tileheight="32">
+  <image source="clifveg2.bmp" trans="5555ff" width="640" height="480"/>
+ </tileset>
+ <tileset firstgid="301" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="tilea2.png" width="512" height="384"/>
+ </tileset>
+ <tileset firstgid="493" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="0">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="6">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="194">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <layer name="Tile Layer 1" width="35" height="16">
+  <properties>
+   <property name="blocked" value="false"/>
+  </properties>
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC/vEyMDwaRDh9Uz4MaXmNzAhMDXdgmxuIRMqHx3T0y2EwqIIj/vo7RYYu4iEeKZHHKGrRQ8zctNuIRYxfOGES46YMC5iwq4e3X/0cAshNdjksIUVOW4hJh5xuQVfOiHXLcx43IcvjmjhFnxi6PK0dAshdaSUVaToI8VceuO3oxgrBgAWIVKowAgAAA==
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.1/NewestVersion/res/map/floor3.tmx b/Version 1.1/NewestVersion/res/map/floor3.tmx
new file mode 100644
index 0000000..3cda2e0
--- /dev/null
+++ b/Version 1.1/NewestVersion/res/map/floor3.tmx	
@@ -0,0 +1,58 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="35" height="16" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="tilea2.png" width="512" height="384"/>
+ </tileset>
+ <tileset firstgid="193" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="0">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="24">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="3354">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <tileset firstgid="4737" name="clifveg2" tilewidth="32" tileheight="32">
+  <image source="clifveg2.bmp" width="640" height="480"/>
+ </tileset>
+ <tileset firstgid="5037" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+ </tileset>
+ <layer name="Tile Layer 1" width="35" height="16">
+  <properties>
+   <property name="blocked" value="false"/>
+  </properties>
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC+2UsQ3AIAwEvUDmyfyZIgXLRCmQEHrbD/4iRYovABsO86YdZu1jOm19vivaM4vJ8ubcPvbmVQxsPuJBsRUGhoepU1TXqle8d8n4FIp4dmIrvvW8wNw/O2+nZuP5kUdnb2TrOxwRA/Ip66/K/xLViu37MU7V44qcW9Rj6H7IV5W/ZpXV41G9wavLfiE9XPlC58AIAAA=
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.1/NewestVersion/res/map/floor4.tmx b/Version 1.1/NewestVersion/res/map/floor4.tmx
new file mode 100644
index 0000000..8bb18c8
--- /dev/null
+++ b/Version 1.1/NewestVersion/res/map/floor4.tmx	
@@ -0,0 +1,93 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="35" height="16" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="tilea2.png" width="512" height="384"/>
+ </tileset>
+ <tileset firstgid="193" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="0">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="6">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="24">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="194">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="3354">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4229">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4232">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <tileset firstgid="4737" name="clifveg2" tilewidth="32" tileheight="32">
+  <image source="clifveg2.bmp" width="640" height="480"/>
+ </tileset>
+ <tileset firstgid="5037" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="6">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <layer name="Tile Layer 1" width="35" height="16">
+  <properties>
+   <property name="blocked" value="false"/>
+  </properties>
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC+2UQQ6CMBREaVy5hovoHeRi3oCFxyDBG0iCa3cegyvoT/hhMkypxZ1x8VJabf90/sBQFMXwA3Slxn57TPj/bBzfYzvxTd1+Yhfm55iWfVg++znH6jsddp7Shhr9/i3A8xif+o13RKx+HWavOlEb5yPss3q+FusX97wX90YtPmK/sAaexX5uzYjaj2teDz1UPcN9KV8Yzylnh71AzdxL1GK5tfFQreclRi1y6+tYk+esZRS+rGk5Bw33iX3A9x113Isl5s211CgtuHYSvvA3JpYrq33JgLWo7KYyndLSZGhRfjxXtKS+g7m+NKRlyzufIrdHtz+SF6t4ECLACAAA
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.1/NewestVersion/res/map/floor5.tmx b/Version 1.1/NewestVersion/res/map/floor5.tmx
new file mode 100644
index 0000000..44d46ac
--- /dev/null
+++ b/Version 1.1/NewestVersion/res/map/floor5.tmx	
@@ -0,0 +1,133 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="35" height="16" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="tilea2.png" width="512" height="384"/>
+ </tileset>
+ <tileset firstgid="193" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="0">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="6">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="19">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="21">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="24">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="154">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="194">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="3354">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4227">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4229">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4232">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <tileset firstgid="4737" name="clifveg2" tilewidth="32" tileheight="32">
+  <image source="clifveg2.bmp" width="640" height="480"/>
+ </tileset>
+ <tileset firstgid="5037" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="151">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="152">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="153">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="154">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="156">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="194">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <layer name="Tile Layer 1" width="35" height="16">
+  <properties>
+   <property name="blocked" value="false"/>
+  </properties>
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC+2VQRKCMAxFwwmUkb0bb+AVdPAOHoIjeRbrOL2WVsw0fJIWC7py8QfSMuT1JwRPRP6prpkmT8vr/pYXLPtdFMa8tgTfqY7S9jl3CwyHppfGJ1n43cdqmEfm1db4eY1F8wVZZIwsFpfFwrHmT8iBsVU3rFHIjVyW+Fm8l72LOWRfoE9riirxxeLWzpzzZUVRlhfIYvWTxnKuhixa76b6BXNN/abm+pLrXdmX1jzY0ngu8J4ju19S8yVVo+DVhfp50dbja2pGuYLZadXotoln0jjazLx0Qp8yWXqxFPryDZZf/+fm6PqXqgctJT+TwAgAAA==
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.1/NewestVersion/res/map/floor6.tmx b/Version 1.1/NewestVersion/res/map/floor6.tmx
new file mode 100644
index 0000000..63c876c
--- /dev/null
+++ b/Version 1.1/NewestVersion/res/map/floor6.tmx	
@@ -0,0 +1,148 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="35" height="16" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="tilea2.png" width="512" height="384"/>
+ </tileset>
+ <tileset firstgid="193" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="0">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="6">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="19">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="21">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="24">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="154">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="194">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="207">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="3354">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4227">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4229">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4232">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4492">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4493">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <tileset firstgid="4737" name="clifveg2" tilewidth="32" tileheight="32">
+  <image source="clifveg2.bmp" width="640" height="480"/>
+ </tileset>
+ <tileset firstgid="5037" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="151">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="152">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="153">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="154">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="156">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="194">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <layer name="Tile Layer 1" width="35" height="16">
+  <properties>
+   <property name="blocked" value="false"/>
+  </properties>
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC+2VwQ2AIAxF6wgylRfYzKv7eHIE11FCiIS0yC/15uGHxkD7it/qHZE31kZJlvnqvDkuJXFY8Ug1e1jKPuozrWdoHo6lztfKL+3v6Ul6Xxwjt1qxoP327NP4HPEdx6E5O8Kh8QviW+Se31gOSqpjhAX53lo8sXa442VO0rCgXNLs8AVHcA+Lxt9c7xzXKdSItTNL1DqNzWJkZnI1sk9Kv3wly/9O1E6/OF3Xgm9swAgAAA==
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.1/NewestVersion/res/map/floor7.tmx b/Version 1.1/NewestVersion/res/map/floor7.tmx
new file mode 100644
index 0000000..76c0b31
--- /dev/null
+++ b/Version 1.1/NewestVersion/res/map/floor7.tmx	
@@ -0,0 +1,188 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="35" height="16" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="tilea2.png" width="512" height="384"/>
+ </tileset>
+ <tileset firstgid="193" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="0">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="6">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="19">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="21">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="24">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="150">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="154">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="194">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="207">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="854">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="925">
+   <properties>
+    <property name="win" value="true"/>
+   </properties>
+  </tile>
+  <tile id="1251">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="3354">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4227">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4229">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4232">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4492">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4493">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <tileset firstgid="4737" name="clifveg2" tilewidth="32" tileheight="32">
+  <image source="clifveg2.bmp" width="640" height="480"/>
+ </tileset>
+ <tileset firstgid="5037" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="6">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="148">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="149">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="151">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="152">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="153">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="154">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="156">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="194">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="925">
+   <properties>
+    <property name="win" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <layer name="Tile Layer 1" width="35" height="16">
+  <properties>
+   <property name="blocked" value="false"/>
+  </properties>
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC/MVYmDwHQJ4GgMCk6N/CStpGJ87cPGPMRCHQeZ7CBKHcbkFW1ggix0jkoa5JZwRYScuNrJbYPbgig/k+IL5e50wbgyzo4tIjO4WfOkC3S0gMULuINYtXuKYcURsOmVnpG24kOImkDtA7kG2m5rpBZsbcLnnGFI8+eHJW+TmI2R3INPYwgg5vWATp6R8wVeWYBPD5VZ0t1ADE8rXxxhQ3UFLtxDCx+gYLsS6hVhxYvFBhlGMDQMAMVG8hcAIAAA=
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.1/NewestVersion/res/map/secondTestMap.tmx b/Version 1.1/NewestVersion/res/map/secondTestMap.tmx
new file mode 100644
index 0000000..8681c38
--- /dev/null
+++ b/Version 1.1/NewestVersion/res/map/secondTestMap.tmx	
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="35" height="16" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="clifveg2" tilewidth="32" tileheight="32">
+  <image source="clifveg2.bmp" trans="5555ff" width="640" height="480"/>
+ </tileset>
+ <tileset firstgid="301" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="tilea2.png" width="512" height="384"/>
+ </tileset>
+ <tileset firstgid="493" name="32x32" tilewidth="32" tileheight="32">
+  <image source="32x32.bmp" width="2048" height="2272"/>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <layer name="Tile Layer 1" width="35" height="16">
+  <properties>
+   <property name="blocked" value="false"/>
+  </properties>
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC8WUUQoAIQhE21sYdP/77Q32S4hBa6vRPgYqMl+jWEsp1dH7cOXl2dFtlkb0iMGikkMmFosYZ9m9IoY3qxyZLHpv1OtRLOLk7mNYvgiscd9AMw4my2p8FAsK/cDaRc7aEYtVoygG6139/2weR3nxd25k1WbHw5ssp298cFJwwcAIAAA=
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.1/NewestVersion/res/map/singleTilePassageWay.tmx b/Version 1.1/NewestVersion/res/map/singleTilePassageWay.tmx
new file mode 100644
index 0000000..0d774b0
--- /dev/null
+++ b/Version 1.1/NewestVersion/res/map/singleTilePassageWay.tmx	
@@ -0,0 +1,50 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="35" height="16" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="clifveg2" tilewidth="32" tileheight="32">
+  <image source="../../../../Pictures/SENG 301/Resource Folder/clifveg2.bmp" trans="5555ff" width="640" height="480"/>
+ </tileset>
+ <tileset firstgid="301" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="../../../../Pictures/SENG 301/tilea2.png" width="512" height="384"/>
+ </tileset>
+ <tileset firstgid="493" name="32x32" tilewidth="32" tileheight="32">
+  <image source="../../../../Pictures/SENG 301/Resource Folder/32x32.bmp" width="2048" height="2272"/>
+  <tile id="0">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="4">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="5">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="13">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+  <tile id="22">
+   <properties>
+    <property name="stairs" value="true"/>
+   </properties>
+  </tile>
+  <tile id="24">
+   <properties>
+    <property name="stairs" value="tru"/>
+   </properties>
+  </tile>
+ </tileset>
+ <layer name="Tile Layer 1" width="35" height="16">
+  <properties>
+   <property name="blocked" value="false"/>
+  </properties>
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC+2UUQ5AQAxEi0tU4v638+EGImxSY2fb4o+PSViz25ft1NKJLB/UKLvwGT3oZ943WFo12De2NyOPrcWL69Mhletapid3WLCnCrU1yBHpP+P0PLY+shTmTK9b/FrZ2/KqnO/PSp1aGTbvrHI3Rdl5q+WSeaLz5v0r7rKwHrN3zI9WxPijLCwDyGFnC7NiFZ2X7CzZPHk5idbYNPTxrGdy+UTzr6pW2YhYzcAIAAA=
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.1/NewestVersion/res/map/testMap..txt b/Version 1.1/NewestVersion/res/map/testMap..txt
new file mode 100644
index 0000000..627e217
--- /dev/null
+++ b/Version 1.1/NewestVersion/res/map/testMap..txt	
@@ -0,0 +1,218 @@
+[header]
+width=100
+height=100
+tilewidth=32
+tileheight=32
+orientation=orthogonal
+
+[tilesets]
+tileset=tilea2.png,32,32,0,0
+
+[layer]
+type=Tile Layer 1
+data=
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,183,183,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,183,183,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
+
+[layer]
+type=Ojects
+data=
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,105,105,105,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,105,105,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,105,0,0,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,105,105,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+
diff --git a/Version 1.1/NewestVersion/res/map/testMap.tmx b/Version 1.1/NewestVersion/res/map/testMap.tmx
new file mode 100644
index 0000000..aa072a2
--- /dev/null
+++ b/Version 1.1/NewestVersion/res/map/testMap.tmx	
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<map version="1.0" orientation="orthogonal" renderorder="right-down" width="20" height="20" tilewidth="32" tileheight="32" nextobjectid="1">
+ <tileset firstgid="1" name="tilea2" tilewidth="32" tileheight="32">
+  <image source="tilea2.png" width="512" height="384"/>
+  <tile id="2">
+   <properties>
+    <property name="blocked" value="true"/>
+   </properties>
+  </tile>
+ </tileset>
+ <layer name="Tile Layer 1" width="20" height="20">
+  <data encoding="base64" compression="gzip">
+   H4sIAAAAAAAAC2NmYGBgpiIWoiLGZh4u+4hxAy7z8LEHi3nY/Euuebj0EBN+pMQ7MfLkiFPbPFLCb7CYR2y4E5s/iUlPxGJcaZUS8wiFCynlDyHzSC3TCOnHVU5RuwylR5mMjgHDQcVQQAYAAA==
+  </data>
+ </layer>
+</map>
diff --git a/Version 1.1/NewestVersion/res/map/tilea2.png b/Version 1.1/NewestVersion/res/map/tilea2.png
new file mode 100644
index 0000000..1348d5a
Binary files /dev/null and b/Version 1.1/NewestVersion/res/map/tilea2.png differ
diff --git a/Version 1.1/NewestVersion/res/monster/Thumbs.db b/Version 1.1/NewestVersion/res/monster/Thumbs.db
new file mode 100644
index 0000000..9a95ffd
Binary files /dev/null and b/Version 1.1/NewestVersion/res/monster/Thumbs.db differ
diff --git a/Version 1.1/NewestVersion/res/monster/dead.png b/Version 1.1/NewestVersion/res/monster/dead.png
new file mode 100644
index 0000000..84309e0
Binary files /dev/null and b/Version 1.1/NewestVersion/res/monster/dead.png differ
diff --git a/Version 1.1/NewestVersion/res/monster/dummySheet.png b/Version 1.1/NewestVersion/res/monster/dummySheet.png
new file mode 100644
index 0000000..c4225b3
Binary files /dev/null and b/Version 1.1/NewestVersion/res/monster/dummySheet.png differ
diff --git a/Version 1.1/NewestVersion/res/player/Thumbs.db b/Version 1.1/NewestVersion/res/player/Thumbs.db
new file mode 100644
index 0000000..6213e3c
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/Thumbs.db differ
diff --git a/Version 1.1/NewestVersion/res/player/intro1.png b/Version 1.1/NewestVersion/res/player/intro1.png
new file mode 100644
index 0000000..4fc89e0
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro1.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro10.png b/Version 1.1/NewestVersion/res/player/intro10.png
new file mode 100644
index 0000000..3d28ca8
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro10.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro11.png b/Version 1.1/NewestVersion/res/player/intro11.png
new file mode 100644
index 0000000..d8f24e6
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro11.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro12.png b/Version 1.1/NewestVersion/res/player/intro12.png
new file mode 100644
index 0000000..06d2d5f
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro12.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro13.png b/Version 1.1/NewestVersion/res/player/intro13.png
new file mode 100644
index 0000000..ce751d3
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro13.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro14.png b/Version 1.1/NewestVersion/res/player/intro14.png
new file mode 100644
index 0000000..1835d00
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro14.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro15.png b/Version 1.1/NewestVersion/res/player/intro15.png
new file mode 100644
index 0000000..c2f4c79
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro15.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro16.png b/Version 1.1/NewestVersion/res/player/intro16.png
new file mode 100644
index 0000000..cba8ea0
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro16.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro17.png b/Version 1.1/NewestVersion/res/player/intro17.png
new file mode 100644
index 0000000..e3295f1
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro17.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro18.png b/Version 1.1/NewestVersion/res/player/intro18.png
new file mode 100644
index 0000000..6ce5bc8
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro18.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro19.png b/Version 1.1/NewestVersion/res/player/intro19.png
new file mode 100644
index 0000000..be85aa1
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro19.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro2.png b/Version 1.1/NewestVersion/res/player/intro2.png
new file mode 100644
index 0000000..f29c741
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro2.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro20.png b/Version 1.1/NewestVersion/res/player/intro20.png
new file mode 100644
index 0000000..bc438b4
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro20.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro21.png b/Version 1.1/NewestVersion/res/player/intro21.png
new file mode 100644
index 0000000..4ab4681
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro21.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro22.png b/Version 1.1/NewestVersion/res/player/intro22.png
new file mode 100644
index 0000000..2d73478
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro22.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro23.png b/Version 1.1/NewestVersion/res/player/intro23.png
new file mode 100644
index 0000000..1cc8af4
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro23.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro24.png b/Version 1.1/NewestVersion/res/player/intro24.png
new file mode 100644
index 0000000..c923ed5
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro24.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro25.png b/Version 1.1/NewestVersion/res/player/intro25.png
new file mode 100644
index 0000000..3dc1d3f
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro25.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro26.png b/Version 1.1/NewestVersion/res/player/intro26.png
new file mode 100644
index 0000000..d1bdcef
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro26.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro27.png b/Version 1.1/NewestVersion/res/player/intro27.png
new file mode 100644
index 0000000..b9cb634
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro27.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro28.png b/Version 1.1/NewestVersion/res/player/intro28.png
new file mode 100644
index 0000000..348175f
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro28.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro3.png b/Version 1.1/NewestVersion/res/player/intro3.png
new file mode 100644
index 0000000..f8e3b6f
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro3.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro4.png b/Version 1.1/NewestVersion/res/player/intro4.png
new file mode 100644
index 0000000..28f1e6b
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro4.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro5.png b/Version 1.1/NewestVersion/res/player/intro5.png
new file mode 100644
index 0000000..3ede5ca
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro5.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro6.png b/Version 1.1/NewestVersion/res/player/intro6.png
new file mode 100644
index 0000000..4d46365
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro6.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro7.png b/Version 1.1/NewestVersion/res/player/intro7.png
new file mode 100644
index 0000000..7b85f7d
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro7.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro8.png b/Version 1.1/NewestVersion/res/player/intro8.png
new file mode 100644
index 0000000..0bd2af7
Binary files /dev/null and b/Version 1.1/NewestVersion/res/player/intro8.png differ
diff --git a/Version 1.1/NewestVersion/res/player/intro9.png b/